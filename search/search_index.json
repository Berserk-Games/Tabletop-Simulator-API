{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Welcome to Lua Scripting in Tabletop Simulator! Scripting is an advanced feature and it\u2019s expected you already know something about it. However, for complete novices, check out this beginners scripting guide to Lua created by MrStump, to help you along the way. A game is composed of one Global Script and zero to many Object Scripts. The Global Script is a script that lives in your game that can run background tasks and do general game management type functions. Object scripts are attached to an individual object. Objects are anything with a physical model in the game - chess piece, dice, decks, cards, bags, custom models, boards, etc. Both types of scripts can call the same functions, but Object scripts have access to a reference of the Object it is attached to with the self keyword. Resources You are able to follow the links on the left side of the page for available tools to help utilize and learn the basics of scripting. When at the top of the page, you will see a link to the Lua API for documentation on all of the available Tabletop Simulator Lua functionality. Links on the right side of the page help navigate the article you are viewing. Writing Lua Scripts The Lua code is written via our in-game code editor or via our Official Plugin for the Atom Text Editor . Lua scripts are stored in the .json file of the save game as a plain text string. There is no need for an external internet host for Lua scripts, everything is self-contained in your game\u2019s save file. Workshop uploads work the same way.","title":"Introduction"},{"location":"#introduction","text":"Welcome to Lua Scripting in Tabletop Simulator! Scripting is an advanced feature and it\u2019s expected you already know something about it. However, for complete novices, check out this beginners scripting guide to Lua created by MrStump, to help you along the way. A game is composed of one Global Script and zero to many Object Scripts. The Global Script is a script that lives in your game that can run background tasks and do general game management type functions. Object scripts are attached to an individual object. Objects are anything with a physical model in the game - chess piece, dice, decks, cards, bags, custom models, boards, etc. Both types of scripts can call the same functions, but Object scripts have access to a reference of the Object it is attached to with the self keyword.","title":"Introduction"},{"location":"#resources","text":"You are able to follow the links on the left side of the page for available tools to help utilize and learn the basics of scripting. When at the top of the page, you will see a link to the Lua API for documentation on all of the available Tabletop Simulator Lua functionality. Links on the right side of the page help navigate the article you are viewing.","title":"Resources"},{"location":"#writing-lua-scripts","text":"The Lua code is written via our in-game code editor or via our Official Plugin for the Atom Text Editor . Lua scripts are stored in the .json file of the save game as a plain text string. There is no need for an external internet host for Lua scripts, everything is self-contained in your game\u2019s save file. Workshop uploads work the same way.","title":"Writing Lua Scripts"},{"location":"assetbundle/","text":"AssetBundle is a special Object type that has access to custom AssetBundle related functions like looping and trigger effects. Example Usage: self.AssetBundle.getLoopingEffects() Function Summary Object Functions Function Name Description Return getLoopingEffectIndex() Index of the currently looping effect. Indexs starts at 0. getLoopingEffects() Returns a Table with the keys \"index\" and \"name\" for each looping effect. getTriggerEffects() Returns a Table with the keys \"index\" and \"name\" for each trigger effect. playLoopingEffect( index) Starts playing a looping effect. Indexs starts at 0. playTriggerEffect( index) Starts playing a trigger effect. Indexs starts at 0. Function Details getLoopingEffects() Returns a Table with the keys \"index\" and \"name\" for each looping effect. -- Example usage effectTable = self . AssetBundle . getLoopingEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, } getTriggerEffects() Returns a Table with the keys \"index\" and \"name\" for each trigger effect. -- Example usage effectTable = self . AssetBundle . getTriggerEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, }","title":"AssetBundle"},{"location":"assetbundle/#function-summary","text":"","title":"Function Summary"},{"location":"assetbundle/#object-functions","text":"Function Name Description Return getLoopingEffectIndex() Index of the currently looping effect. Indexs starts at 0. getLoopingEffects() Returns a Table with the keys \"index\" and \"name\" for each looping effect. getTriggerEffects() Returns a Table with the keys \"index\" and \"name\" for each trigger effect. playLoopingEffect( index) Starts playing a looping effect. Indexs starts at 0. playTriggerEffect( index) Starts playing a trigger effect. Indexs starts at 0.","title":"Object Functions"},{"location":"assetbundle/#function-details","text":"","title":"Function Details"},{"location":"assetbundle/#getloopingeffects","text":"Returns a Table with the keys \"index\" and \"name\" for each looping effect. -- Example usage effectTable = self . AssetBundle . getLoopingEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, }","title":"getLoopingEffects()"},{"location":"assetbundle/#gettriggereffects","text":"Returns a Table with the keys \"index\" and \"name\" for each trigger effect. -- Example usage effectTable = self . AssetBundle . getTriggerEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, }","title":"getTriggerEffects()"},{"location":"atom/","text":"Atom is a free, open source, and cross-platform text editor created by GitHub : Atom is a text editor that's modern, approachable, yet hackable to the core - a tool you can customize to do anything but also use productively without ever touching a config file. We created an official plugin for the Atom text editor to make writing Lua scripts for Tabletop Simulator super easy and fun! This page provides a basic overview of how to install and use the plugin; if you would like a more in-depth explanation of its features and how to install/use it then please see its documentation: Atom Plugin Documentation Home Installation Instructions Features Commands Settings Our official plugin introduces syntax highlighting, code autocompletion for the Tabletop Simulator Lua API, and functions to interact with the game. The in-game editor will continue to exist for quick access to scripts, but development on it will cease to continue. Prefer another text editor? Take look at our External Editor API to make your own plugin. Features This is only a summarized list of features Atom offers. Check out a more complete documentation on the plugin specifically in the plugin wiki . Syntax Highlighting All standard Lua syntax is highlighted in multiple colors to help with readability. Code Autocompletion The entire Tabletop Simulator Lua Scripting API (with the exception of the Player class) has been added to the native Atom autocomplete system. Easily see all of the member variables and functions available to you with their parameters, return type, short description, and a link directly to our Knowledge Base with more information for that variable or function. Functions belonging to the Lua standard library classes such as math, coroutine, or os link directly to the official Lua documentation. Tabletop Simulator Interactivity The Atom plugin can directly connect to a running instance of Tabletop Simulator to get all of the existing Lua scripts on Objects and to call Save & Play. Both functions can be called directly from the Packages menu or the right click contextual menu. TTS must be running with the game loaded for these functions to work. Command Action Taken Get Lua Scripts Downloads all existing scripts in a loaded Tabletop Simulator game with Atom. You will need to call Get Lua Scripts every time you change to a different game in TTS. Save & Play Saves all Lua files in Atom, uploads them to a loaded Tabletop Simulator game, and reloads the current game (same as Save & Play in the in-game editor). Every time you start up Atom, the cached local *.lua files are deleted. Installing Atom Download and install Atom from the official website . Installing the Official Plugin Click on File -> Settings Select the Install tab in Settings Type in tabletopsimulator-lua into the search field and press the Enter key or click the Packages button Click the blue Install button for the tabletopsimulator-lua package Setting Up Atom Tab Width By default, Tabletop Simulator scripts use a tab width of four spaces. You are not required to adhere to this spacing. By default, Atom has a tab width of two spaces. To optionally make Atom default to a tab width of four spaces: Click on File -> Settings Select the Editor tab in Settings Scroll down to Tab Length Set the Tab Length to 4 Tables as Pipe Operators To enable tabs showing up as pipe operators \"|\" as an indent guide: Click on File -> Settings Select the Editor tab in Settings Scroll down to Show Indent Guide Check Show Indent Guide Updating Atom Plugin The plugin will automatically check for updates when Atom is started. If a new update is found, it will update itself. You will have to manually restart Atom for the new version of the plugin to be loaded. You can check Atom's console if it found an update (ctrl + alt + i). Atom Tips These are just a few basic tips to help get the most out of Atom. Print Messages All print() functions automatically send their messages to Atom's console (ctrl + shift + i). Error Messages All Lua errors are automatically sent to Atom's console (ctrl + shift + i). Quick Save + Play Hitting Ctrl + Shift + S will trigger Save & Play.","title":"Atom"},{"location":"atom/#features","text":"This is only a summarized list of features Atom offers. Check out a more complete documentation on the plugin specifically in the plugin wiki .","title":"Features"},{"location":"atom/#syntax-highlighting","text":"All standard Lua syntax is highlighted in multiple colors to help with readability.","title":"Syntax Highlighting"},{"location":"atom/#code-autocompletion","text":"The entire Tabletop Simulator Lua Scripting API (with the exception of the Player class) has been added to the native Atom autocomplete system. Easily see all of the member variables and functions available to you with their parameters, return type, short description, and a link directly to our Knowledge Base with more information for that variable or function. Functions belonging to the Lua standard library classes such as math, coroutine, or os link directly to the official Lua documentation.","title":"Code Autocompletion"},{"location":"atom/#tabletop-simulator-interactivity","text":"The Atom plugin can directly connect to a running instance of Tabletop Simulator to get all of the existing Lua scripts on Objects and to call Save & Play. Both functions can be called directly from the Packages menu or the right click contextual menu. TTS must be running with the game loaded for these functions to work. Command Action Taken Get Lua Scripts Downloads all existing scripts in a loaded Tabletop Simulator game with Atom. You will need to call Get Lua Scripts every time you change to a different game in TTS. Save & Play Saves all Lua files in Atom, uploads them to a loaded Tabletop Simulator game, and reloads the current game (same as Save & Play in the in-game editor). Every time you start up Atom, the cached local *.lua files are deleted.","title":"Tabletop Simulator Interactivity"},{"location":"atom/#installing-atom","text":"Download and install Atom from the official website .","title":"Installing Atom"},{"location":"atom/#installing-the-official-plugin","text":"Click on File -> Settings Select the Install tab in Settings Type in tabletopsimulator-lua into the search field and press the Enter key or click the Packages button Click the blue Install button for the tabletopsimulator-lua package","title":"Installing the Official Plugin"},{"location":"atom/#setting-up-atom","text":"","title":"Setting Up Atom"},{"location":"atom/#tab-width","text":"By default, Tabletop Simulator scripts use a tab width of four spaces. You are not required to adhere to this spacing. By default, Atom has a tab width of two spaces. To optionally make Atom default to a tab width of four spaces: Click on File -> Settings Select the Editor tab in Settings Scroll down to Tab Length Set the Tab Length to 4","title":"Tab Width"},{"location":"atom/#tables-as-pipe-operators","text":"To enable tabs showing up as pipe operators \"|\" as an indent guide: Click on File -> Settings Select the Editor tab in Settings Scroll down to Show Indent Guide Check Show Indent Guide","title":"Tables as Pipe Operators"},{"location":"atom/#updating-atom-plugin","text":"The plugin will automatically check for updates when Atom is started. If a new update is found, it will update itself. You will have to manually restart Atom for the new version of the plugin to be loaded. You can check Atom's console if it found an update (ctrl + alt + i).","title":"Updating Atom Plugin"},{"location":"atom/#atom-tips","text":"These are just a few basic tips to help get the most out of Atom. Print Messages All print() functions automatically send their messages to Atom's console (ctrl + shift + i). Error Messages All Lua errors are automatically sent to Atom's console (ctrl + shift + i). Quick Save + Play Hitting Ctrl + Shift + S will trigger Save & Play.","title":"Atom Tips"},{"location":"backgrounds/","text":"The static global Backgrounds class provides the ability to interact with the background. Example Usage: Backgrounds . getBackground () . Function Summary Function Name Description Return getBackground() Returns the Background name. setBackground( name) Changes the Background. getCustomURL() Returns the url of the image for the Background. setCustomURL( url) Changes the image for the Background","title":"Background"},{"location":"backgrounds/#function-summary","text":"Function Name Description Return getBackground() Returns the Background name. setBackground( name) Changes the Background. getCustomURL() Returns the url of the image for the Background. setCustomURL( url) Changes the image for the Background","title":"Function Summary"},{"location":"base/","text":"These are a loose collection of functions which can be used to perform a variety of actions within Tabletop Simulator. These functions can utilize in-game Objects, but none of them can be enacted on in-game Objects. They all deal with the game space. Function Summary Global Functions General functions which work within any script. Function Name Description Return addContextMenuItem( label, toRunFunc, keep_open, require_table) Adds a menu item to the Global right-click context menu. Global menu is shown when player right-clicks on empty space or table. clearContextMenu() Clears all menu items added by function addContextMenuItem . copy( object_list) Copy a list of Objects to the clipboard. Works with paste(...) . destroyObject( obj) Destroy an Object. flipTable() Flip the table. getAllObjects() Use getObjects() . Returns a Table of all Objects in the game except hand zones . getObjectFromGUID( guid) Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getObjects() Returns a Table of all Objects in the game. getObjectsWithTag( tag) Returns Table of all Objects which have the specified tag attached. getObjectsWithAnyTags( tags) Returns Table of all Objects which have at least one of the specified tags attached. getObjectsWithAllTags( tags) Returns Table of all Objects which have all of the specified tags attached. getSeatedPlayers() Returns a Table of the Player Colors strings of seated players. group( objects) Groups objects together, like how the G key does for players. paste( parameters) Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . setLookingForPlayers( lfp) Enables/disables looking for group. This is visible in the server browsers, indicating if you are recruiting for a game. spawnObject( parameters) Spawns an Object. See Built-in and Custom Spawnable Object pages for further details. spawnObjectData( parameters) Spawns an Object using a data table. Works with getData() . spawnObjectJSON( parameters) Spawns an Object using a JSON string. Works with getJSON() . startLuaCoroutine( function_owner, function_name) Start a coroutine. stringColorToRGB( player_color) Converts a Player Color string into a Color Table for tinting. Hotkey Functions Function Name Description Return addHotkey( label, toRunFunc, trigger_on_key_up) Adds a bindable Hotkey to the game. User may assign a key to it in Options->Game Keys after the game was created. clearHotkeys() Clears all Hotkeys added by addHotkey showHotkeyConfig() Shows the Hotkey configuration window under Options->Game Keys. Message Functions Functions which handle sending and displaying data. Function Name Description Return broadcastToAll( message, message_tint) Print an on-screen message to all Players, as well as their in-game chat. broadcastToColor( message, player_color, message_tint) Print an on-screen message to a specified Player, as well as their in-game chat. log( value, label, tags) Logs a message to the host's System Console. (Shortcut: ~) logString( value, label, tags, concise, displayTag) Returns a String formatted similarly to the output of log(...) . logStyle( tag, tint, prefix, postfix) Set style options for the specified tag type for the log. print( message) Prints a string into chat that only the host is able to see. Used for debugging scripts. printToAll( message, message_tint) Print a message into the chat of all connected players. printToColor( message, player_color, message_tint) Print a message to a specific Player Color . sendExternalMessage( data) Send a table to your external script editor, most likely Atom. This is for custom editor functionality. Function Details Global Function details addContextMenuItem(...) Adds a menu item to the Global right-click context menu. Global menu is shown when player right-clicks on empty space or table. addContextMenuItem(label, toRunFunc, keep_open, require_table) label : Label for the menu item. toRunFunc : Execute if menu item is selected. player_color Player Color who selected the menu item. menu_position Global position of the right-click context menu. keep_open : Keep context menu open after menu item was selected. Optional, Default: keep_open = false. Close context menu after selection. require_table : Show added menu item when right-clicked on empty space or table. Optional, Default: require_table = false. Show when right-clicked on empty space or table function onLoad () addContextMenuItem ( \"doStuff\" , itemAction ) end function itemAction ( player_color , menu_position ) print ( player_color ) end copy(...) Copy a list of Objects to the clipboard. Works with paste(...) . copy(object_list) object_list : A Table of in-game objects to be copied. This is similar to highlighting the objects in-game and copying them. object_list = { getObjectFromGUID ( \"######\" ), getObjectFromGUID ( \"######\" ), } copy ( object_list ) destroyObject(...) Destroy an Object. destroyObject(obj) obj : The Object you wish to delete from the instance. getObjectFromGUID(...) Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getObjectFromGUID(guid) guid : GUID of the Object to get a reference of. GUID can be obtained by right clicking an object and going to Scripting. In a script, it can be obtained from any Object by using .getGUID(). group(...) Groups objects together, like how the G key does for players. It returns a table of object references to any decks/stacks formed. Not all objects CAN be grouped. If the G key won't work on them, neither will this function. group(objects) objects : A list of objects to be grouped together. Format of the returned table A table containing the grouped objects, numerically indexed. Object(s) Different types of object are grouped independently i.e. cards will form into a deck, each type of checker will form their own stack. -- Example function onLoad () local objects = { -- IMPORTANT: To get the example to work, you need to replace ###### by a real GUID of the object. getObjectFromGUID ( \"######\" ), -- card getObjectFromGUID ( \"######\" ), -- card getObjectFromGUID ( \"######\" ), -- checker getObjectFromGUID ( \"######\" ), -- checker } local objGroupedList = group ( objects ) log ( objGroupedList ) end -- Possible Output for objGroupedList { 1 : < Deck > 2 : < CheckerStack > } paste(...) Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . paste(parameters) parameters : A Table containing instructions of where to spawn the Objects. parameters.position : Position of the first object to paste. Optional, defaults to {0, 3, 0}. parameters.snap_to_grid : If snap-to-grid is active on the spawned item/s. Optional, defaults to false (off). spawnObject(...) Spawns an Object. See Built-in and Custom Spawnable Objects pages for details of specific spawnable objects. If you are spawning a custom Object , you should call setCustomObject immediately after spawnObject to set its custom properties. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObject(parameters) parameters : A Table of parameters used to determine how spawnObject will act. parameters.type : Built-in or Custom Game Object name. parameters.position : Position to place Object. Optional, defaults to {x=0, y=3, z=0}. parameters.rotation : Rotation of the Object. Optional, defaults to {x=0, y=0, z=0} parameters.scale : Scale of the Object. Optional, defaults to {x=1, y=1, z=1} parameters.sound : If the spawned Object noise is played. Optional, defaults to true. parameters.snap_to_grid : If snap-to-grid is active on the Object. Optional, defaults to false. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { type = \"rpg_BEAR\" , position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , \"Bear\" , \"Green\" ) end } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end spawnObjectData(...) Spawns an Object using a data table. Works with getData() . It works just like spawnObject, but instead of a type , you supply a data table. The other parameters will overwrite those in the Data. spawnObjectData(parameters) parameters : A Table of parameters used to determine how spawnObjectData will act. parameters.data : getData() table. parameters.position : Position to place Object. Optional, defaults to data table's value. parameters.rotation : Rotation of the Object. Optional, defaults to data table's value. parameters.scale : Scale of the Object. Optional, defaults to data table's value. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. local futureName = \"Spawned By Script!\" spawnParams = { data = self . getData (), position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, callback_function = function ( obj ) spawn_callback ( obj , futureName , \"Red\" ) end --alternative format: --callback_function = |obj| spawn_callback(obj, futureName, \"Red\") } spawnObjectData ( spawnParams ) function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end Tip You can modify an object's data prior to spawning, this is currently the only way to \"Create States\" via API (using the \"States\" key). spawnObjectJSON(...) Spawns an Object using a JSON string. Works with getJSON() . It works just like spawnObject, but instead of a type , you supply a json string. The other parameters will overwrite those in the JSON. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObjectJSON(parameters) parameters : A Table of parameters used to determine how spawnObjectJSON will act. parameters.json : getJSON() string. parameters.position : Position to place Object. Optional, defaults to JSON's value. parameters.rotation : Rotation of the Object. Optional, defaults to JSON's value. parameters.scale : Scale of the Object. Optional, defaults to JSON's value. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { json = self . getJSON (), position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , futureName , \"Red\" ) end --alternative format: --callback_function = |obj| spawn_callback(obj, futureName, \"Red\") } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end startLuaCoroutine(...) Start a coroutine. A coroutine is similar to a function, but has the unique ability to have its run paused until the next frame of the game using coroutine.yield(0) . Attention You MUST return a 1 at the end of any coroutine or it will throw an error. startLuaCoroutine(function_owner, function_name) function_owner : The Object that the function being called is on. Global is a valid target. function_name : Name of the function being called as a coroutine. function onLoad () startLuaCoroutine ( Global , \"print_coroutine\" ) end -- Prints a message, waits 250 frames, prints another message function print_coroutine () print ( \"Routine has Started\" ) count = 0 while count < 250 do count = count + 1 coroutine.yield ( 0 ) end print ( \"Routine has Finished\" ) return 1 end stringColorToRGB(...) Converts a Player Color string into a Color Table for tinting. stringColorToRGB(player_color) player_color A String of a Player Color . printToAll ( \"Blue message\" , stringColorToRGB ( \"Blue\" )) addHotkey(...) Adds a bindable Hotkey to the game. User may assign a key to it in Options->Game Keys after the game was created. addHotkey(label, toRunFunc, trigger_on_key_up) label : A String for the Hotkey. toRunFunc (player_color, hovered_object, world_position, key_down_up): The function that is executed at the moment the binded key is pressed. player_color : Player Color who pressed the Hotkey. hovered_object : The object over which the Player's pointer hovers at the moment. nil if there is no object under the Player's pointer. world_position : Word Position of the Player's pointer who pressed the Hotkey. key_down_up : Indicates the moment at which the function toRunFunc is executed. true : Key is released. false : Key is pressed. trigger_on_key_up : Controls the timing at which the function toRunFunc is executed. Optional, Default: trigger_on_key_up = false. true : Executes the function 2 times. At the moment the key is pressed and released. false : Executes the function 1 time. At the moment the key is pressed. Important The key binding does not overwrite the key binding under Setting. e.g. if \"R\" (default: shuffle) is assigned as Hotkey, the Hotkey function and the default shuffle is executed by pressing the key \"R\". The added Hotkeys are not persistent, therefore the function addHotkey(...) needs to called each time the game is loaded. The key assigned by the player remains, if the label is unchanged. function onLoad () addHotkey ( \"This is the first Hotkey for the game.\" , hotkey1 ) addHotkey ( \"This is the second Hotkey for the game.\" , hotkey2 ) end function hotkey1 ( player_color , hovered_object , world_position , key_down_up ) print ( player_color ) end function hotkey2 ( player_color , hovered_object , world_position , key_down_up ) print ( player_color ) end Message Function Details broadcastToAll(...) Print an on-screen message to all Players. broadcastToAll(message, message_tint) message : Message to display on-screen. message_tint : A Table containing the RGB color tint for the text. msg = \"Hello all.\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToAll ( msg , rgb ) broadcastToColor(...) Print an on-screen message to a specified Player and their in-game chat. broadcastToColor(message, player_color, message_tint) message : Message to display on-screen. player_color : Player Color to receive the message. message_tint : RGB color tint for the text. msg = \"Hello White.\" color = \"White\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToColor ( msg , color , rgb ) log(...) Logs a message to the host's System Console (accessible from ~ pane of in-game chat window). log(value, label, tags) value : The value you want to log. label : Text to be logged before value . Optional, defaults to an empty String. Empty Strings are not displayed. tags : The log tag/style or a space separated list of log tags/styles. (See: logStyle(...) ) Optional, defaults to logging with the <default> log style. If value is not already a , then it will be converted to a human-readable representation. If value is a , then the table's contents (keys & values) will be displayed. The contents of nested tables will also be displayed up to a user-configurable depth. Tip Table contents max depth is configurable via the log_max_table_depth System Console command. As an advanced feature, multiple log tags may be provided by space-separating several tags (in the one String) provided as the tags parameter. The message style will be taken from the first tag that the user has not explicitly disabled. Example Log a simple message: log ( \"Something happened\" ) Example Log a table (of objects): log ( getObjects ()) Example Log a message with a label and using the \"error\" log style: log ( \"Something unexpected happened.\" , \"Oh no!\" , \"error\" ) logString(...) Returns a String formatted similarly to the output of log(...) . logString(value, label, tags, concise, displayTag) value : The value you want to log. label : Text to be logged before value . Optional, defaults to an empty String. Empty Strings are not displayed. tags : The log tag/style or a space separated list of log tags/styles. Optional, defaults to logging without any tags. concise : Whether the resultant String should be generated in a more compact form (less newline characters). Optional, defaults to `false`. displayTag : Whether the specified tag(s) should be included as prefix of the resultant String. Optional, defaults to `false`. If value is not already a , then it will be converted to a human-readable representation. If value is a , then the table's contents (keys & values) will be included in the resultant String. The contents of nested tables will also be displayed up to a user-configurable depth. Tip Table contents max depth is configurable via the log_max_table_depth System Console command. In some circumstances log strings have newlines inserted e.g. between the label and the textual representation of value . Providing true as the value for concise will use space separators instead of newlines. Example Print , as opposed to log, the contents of a table (of objects): print ( logString ( getObjects ())) logStyle(...) Configures style options for a log(...) tag. Tip Tag log styles can also be set via the System Console with the log_style_tag command. logStyle(tag, tint, prefix, postfix) tag : A String of the log's tag. tint : RGB value to tint the log entry's text. String color will also work. Example: \"Red\" prefix : Text to place before this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. postfix : Text to place after this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. Example Sets the log style (grey text and a suffix) for the log tag \"seats\" . Then proceeds to log a table of available seat colors, using this tag/style. logStyle ( \"seats\" , { 0.5 , 0.5 , 0.5 }, \"\" , \"End List\" ) log ( Player . getAvailableColors (), nil , \"seats\" ) print(...) Print a string into chat that only the host is able to see. Used for debugging scripts. print(message) message : Text to print into the chat log. printToAll(...) Print a message into the in-game chat of all connected players. printToAll(message, message_tint) message : Message to place into players' in-game chats. message_tint : RGB values for the text's color tint. printToAll ( \"Hello World!\" , { r = 1 , g = 0 , b = 0 }) printToColor(...) Print a message to the in-game chat of a specific player. printToColor(message, player_color, message_tint) message : Message to place into the player's in-game chat. player_color : Player Color of the player that will receive the message. message_tint : RGB values for the text's color tint. printToColor ( \"Hello Red.\" , \"Red\" , { r = 1 , g = 0 , b = 0 })","title":"Base"},{"location":"base/#function-summary","text":"","title":"Function Summary"},{"location":"base/#global-functions","text":"General functions which work within any script. Function Name Description Return addContextMenuItem( label, toRunFunc, keep_open, require_table) Adds a menu item to the Global right-click context menu. Global menu is shown when player right-clicks on empty space or table. clearContextMenu() Clears all menu items added by function addContextMenuItem . copy( object_list) Copy a list of Objects to the clipboard. Works with paste(...) . destroyObject( obj) Destroy an Object. flipTable() Flip the table. getAllObjects() Use getObjects() . Returns a Table of all Objects in the game except hand zones . getObjectFromGUID( guid) Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getObjects() Returns a Table of all Objects in the game. getObjectsWithTag( tag) Returns Table of all Objects which have the specified tag attached. getObjectsWithAnyTags( tags) Returns Table of all Objects which have at least one of the specified tags attached. getObjectsWithAllTags( tags) Returns Table of all Objects which have all of the specified tags attached. getSeatedPlayers() Returns a Table of the Player Colors strings of seated players. group( objects) Groups objects together, like how the G key does for players. paste( parameters) Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . setLookingForPlayers( lfp) Enables/disables looking for group. This is visible in the server browsers, indicating if you are recruiting for a game. spawnObject( parameters) Spawns an Object. See Built-in and Custom Spawnable Object pages for further details. spawnObjectData( parameters) Spawns an Object using a data table. Works with getData() . spawnObjectJSON( parameters) Spawns an Object using a JSON string. Works with getJSON() . startLuaCoroutine( function_owner, function_name) Start a coroutine. stringColorToRGB( player_color) Converts a Player Color string into a Color Table for tinting.","title":"Global Functions"},{"location":"base/#hotkey-functions","text":"Function Name Description Return addHotkey( label, toRunFunc, trigger_on_key_up) Adds a bindable Hotkey to the game. User may assign a key to it in Options->Game Keys after the game was created. clearHotkeys() Clears all Hotkeys added by addHotkey showHotkeyConfig() Shows the Hotkey configuration window under Options->Game Keys.","title":"Hotkey Functions"},{"location":"base/#message-functions","text":"Functions which handle sending and displaying data. Function Name Description Return broadcastToAll( message, message_tint) Print an on-screen message to all Players, as well as their in-game chat. broadcastToColor( message, player_color, message_tint) Print an on-screen message to a specified Player, as well as their in-game chat. log( value, label, tags) Logs a message to the host's System Console. (Shortcut: ~) logString( value, label, tags, concise, displayTag) Returns a String formatted similarly to the output of log(...) . logStyle( tag, tint, prefix, postfix) Set style options for the specified tag type for the log. print( message) Prints a string into chat that only the host is able to see. Used for debugging scripts. printToAll( message, message_tint) Print a message into the chat of all connected players. printToColor( message, player_color, message_tint) Print a message to a specific Player Color . sendExternalMessage( data) Send a table to your external script editor, most likely Atom. This is for custom editor functionality.","title":"Message Functions"},{"location":"base/#function-details","text":"","title":"Function Details"},{"location":"base/#global-function-details","text":"","title":"Global Function details"},{"location":"base/#addcontextmenuitem","text":"Adds a menu item to the Global right-click context menu. Global menu is shown when player right-clicks on empty space or table. addContextMenuItem(label, toRunFunc, keep_open, require_table) label : Label for the menu item. toRunFunc : Execute if menu item is selected. player_color Player Color who selected the menu item. menu_position Global position of the right-click context menu. keep_open : Keep context menu open after menu item was selected. Optional, Default: keep_open = false. Close context menu after selection. require_table : Show added menu item when right-clicked on empty space or table. Optional, Default: require_table = false. Show when right-clicked on empty space or table function onLoad () addContextMenuItem ( \"doStuff\" , itemAction ) end function itemAction ( player_color , menu_position ) print ( player_color ) end","title":"addContextMenuItem(...)"},{"location":"base/#copy","text":"Copy a list of Objects to the clipboard. Works with paste(...) . copy(object_list) object_list : A Table of in-game objects to be copied. This is similar to highlighting the objects in-game and copying them. object_list = { getObjectFromGUID ( \"######\" ), getObjectFromGUID ( \"######\" ), } copy ( object_list )","title":"copy(...)"},{"location":"base/#destroyobject","text":"Destroy an Object. destroyObject(obj) obj : The Object you wish to delete from the instance.","title":"destroyObject(...)"},{"location":"base/#getobjectfromguid","text":"Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getObjectFromGUID(guid) guid : GUID of the Object to get a reference of. GUID can be obtained by right clicking an object and going to Scripting. In a script, it can be obtained from any Object by using .getGUID().","title":"getObjectFromGUID(...)"},{"location":"base/#group","text":"Groups objects together, like how the G key does for players. It returns a table of object references to any decks/stacks formed. Not all objects CAN be grouped. If the G key won't work on them, neither will this function. group(objects) objects : A list of objects to be grouped together. Format of the returned table A table containing the grouped objects, numerically indexed. Object(s) Different types of object are grouped independently i.e. cards will form into a deck, each type of checker will form their own stack. -- Example function onLoad () local objects = { -- IMPORTANT: To get the example to work, you need to replace ###### by a real GUID of the object. getObjectFromGUID ( \"######\" ), -- card getObjectFromGUID ( \"######\" ), -- card getObjectFromGUID ( \"######\" ), -- checker getObjectFromGUID ( \"######\" ), -- checker } local objGroupedList = group ( objects ) log ( objGroupedList ) end -- Possible Output for objGroupedList { 1 : < Deck > 2 : < CheckerStack > }","title":"group(...)"},{"location":"base/#paste","text":"Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . paste(parameters) parameters : A Table containing instructions of where to spawn the Objects. parameters.position : Position of the first object to paste. Optional, defaults to {0, 3, 0}. parameters.snap_to_grid : If snap-to-grid is active on the spawned item/s. Optional, defaults to false (off).","title":"paste(...)"},{"location":"base/#spawnobject","text":"Spawns an Object. See Built-in and Custom Spawnable Objects pages for details of specific spawnable objects. If you are spawning a custom Object , you should call setCustomObject immediately after spawnObject to set its custom properties. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObject(parameters) parameters : A Table of parameters used to determine how spawnObject will act. parameters.type : Built-in or Custom Game Object name. parameters.position : Position to place Object. Optional, defaults to {x=0, y=3, z=0}. parameters.rotation : Rotation of the Object. Optional, defaults to {x=0, y=0, z=0} parameters.scale : Scale of the Object. Optional, defaults to {x=1, y=1, z=1} parameters.sound : If the spawned Object noise is played. Optional, defaults to true. parameters.snap_to_grid : If snap-to-grid is active on the Object. Optional, defaults to false. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { type = \"rpg_BEAR\" , position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , \"Bear\" , \"Green\" ) end } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end","title":"spawnObject(...)"},{"location":"base/#spawnobjectdata","text":"Spawns an Object using a data table. Works with getData() . It works just like spawnObject, but instead of a type , you supply a data table. The other parameters will overwrite those in the Data. spawnObjectData(parameters) parameters : A Table of parameters used to determine how spawnObjectData will act. parameters.data : getData() table. parameters.position : Position to place Object. Optional, defaults to data table's value. parameters.rotation : Rotation of the Object. Optional, defaults to data table's value. parameters.scale : Scale of the Object. Optional, defaults to data table's value. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. local futureName = \"Spawned By Script!\" spawnParams = { data = self . getData (), position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, callback_function = function ( obj ) spawn_callback ( obj , futureName , \"Red\" ) end --alternative format: --callback_function = |obj| spawn_callback(obj, futureName, \"Red\") } spawnObjectData ( spawnParams ) function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end Tip You can modify an object's data prior to spawning, this is currently the only way to \"Create States\" via API (using the \"States\" key).","title":"spawnObjectData(...)"},{"location":"base/#spawnobjectjson","text":"Spawns an Object using a JSON string. Works with getJSON() . It works just like spawnObject, but instead of a type , you supply a json string. The other parameters will overwrite those in the JSON. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObjectJSON(parameters) parameters : A Table of parameters used to determine how spawnObjectJSON will act. parameters.json : getJSON() string. parameters.position : Position to place Object. Optional, defaults to JSON's value. parameters.rotation : Rotation of the Object. Optional, defaults to JSON's value. parameters.scale : Scale of the Object. Optional, defaults to JSON's value. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { json = self . getJSON (), position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , futureName , \"Red\" ) end --alternative format: --callback_function = |obj| spawn_callback(obj, futureName, \"Red\") } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end","title":"spawnObjectJSON(...)"},{"location":"base/#startluacoroutine","text":"Start a coroutine. A coroutine is similar to a function, but has the unique ability to have its run paused until the next frame of the game using coroutine.yield(0) . Attention You MUST return a 1 at the end of any coroutine or it will throw an error. startLuaCoroutine(function_owner, function_name) function_owner : The Object that the function being called is on. Global is a valid target. function_name : Name of the function being called as a coroutine. function onLoad () startLuaCoroutine ( Global , \"print_coroutine\" ) end -- Prints a message, waits 250 frames, prints another message function print_coroutine () print ( \"Routine has Started\" ) count = 0 while count < 250 do count = count + 1 coroutine.yield ( 0 ) end print ( \"Routine has Finished\" ) return 1 end","title":"startLuaCoroutine(...)"},{"location":"base/#stringcolortorgb","text":"Converts a Player Color string into a Color Table for tinting. stringColorToRGB(player_color) player_color A String of a Player Color . printToAll ( \"Blue message\" , stringColorToRGB ( \"Blue\" ))","title":"stringColorToRGB(...)"},{"location":"base/#addhotkey","text":"Adds a bindable Hotkey to the game. User may assign a key to it in Options->Game Keys after the game was created. addHotkey(label, toRunFunc, trigger_on_key_up) label : A String for the Hotkey. toRunFunc (player_color, hovered_object, world_position, key_down_up): The function that is executed at the moment the binded key is pressed. player_color : Player Color who pressed the Hotkey. hovered_object : The object over which the Player's pointer hovers at the moment. nil if there is no object under the Player's pointer. world_position : Word Position of the Player's pointer who pressed the Hotkey. key_down_up : Indicates the moment at which the function toRunFunc is executed. true : Key is released. false : Key is pressed. trigger_on_key_up : Controls the timing at which the function toRunFunc is executed. Optional, Default: trigger_on_key_up = false. true : Executes the function 2 times. At the moment the key is pressed and released. false : Executes the function 1 time. At the moment the key is pressed. Important The key binding does not overwrite the key binding under Setting. e.g. if \"R\" (default: shuffle) is assigned as Hotkey, the Hotkey function and the default shuffle is executed by pressing the key \"R\". The added Hotkeys are not persistent, therefore the function addHotkey(...) needs to called each time the game is loaded. The key assigned by the player remains, if the label is unchanged. function onLoad () addHotkey ( \"This is the first Hotkey for the game.\" , hotkey1 ) addHotkey ( \"This is the second Hotkey for the game.\" , hotkey2 ) end function hotkey1 ( player_color , hovered_object , world_position , key_down_up ) print ( player_color ) end function hotkey2 ( player_color , hovered_object , world_position , key_down_up ) print ( player_color ) end","title":"addHotkey(...)"},{"location":"base/#message-function-details","text":"","title":"Message Function Details"},{"location":"base/#broadcasttoall","text":"Print an on-screen message to all Players. broadcastToAll(message, message_tint) message : Message to display on-screen. message_tint : A Table containing the RGB color tint for the text. msg = \"Hello all.\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToAll ( msg , rgb )","title":"broadcastToAll(...)"},{"location":"base/#broadcasttocolor","text":"Print an on-screen message to a specified Player and their in-game chat. broadcastToColor(message, player_color, message_tint) message : Message to display on-screen. player_color : Player Color to receive the message. message_tint : RGB color tint for the text. msg = \"Hello White.\" color = \"White\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToColor ( msg , color , rgb )","title":"broadcastToColor(...)"},{"location":"base/#log","text":"Logs a message to the host's System Console (accessible from ~ pane of in-game chat window). log(value, label, tags) value : The value you want to log. label : Text to be logged before value . Optional, defaults to an empty String. Empty Strings are not displayed. tags : The log tag/style or a space separated list of log tags/styles. (See: logStyle(...) ) Optional, defaults to logging with the <default> log style. If value is not already a , then it will be converted to a human-readable representation. If value is a , then the table's contents (keys & values) will be displayed. The contents of nested tables will also be displayed up to a user-configurable depth. Tip Table contents max depth is configurable via the log_max_table_depth System Console command. As an advanced feature, multiple log tags may be provided by space-separating several tags (in the one String) provided as the tags parameter. The message style will be taken from the first tag that the user has not explicitly disabled. Example Log a simple message: log ( \"Something happened\" ) Example Log a table (of objects): log ( getObjects ()) Example Log a message with a label and using the \"error\" log style: log ( \"Something unexpected happened.\" , \"Oh no!\" , \"error\" )","title":"log(...)"},{"location":"base/#logstring","text":"Returns a String formatted similarly to the output of log(...) . logString(value, label, tags, concise, displayTag) value : The value you want to log. label : Text to be logged before value . Optional, defaults to an empty String. Empty Strings are not displayed. tags : The log tag/style or a space separated list of log tags/styles. Optional, defaults to logging without any tags. concise : Whether the resultant String should be generated in a more compact form (less newline characters). Optional, defaults to `false`. displayTag : Whether the specified tag(s) should be included as prefix of the resultant String. Optional, defaults to `false`. If value is not already a , then it will be converted to a human-readable representation. If value is a , then the table's contents (keys & values) will be included in the resultant String. The contents of nested tables will also be displayed up to a user-configurable depth. Tip Table contents max depth is configurable via the log_max_table_depth System Console command. In some circumstances log strings have newlines inserted e.g. between the label and the textual representation of value . Providing true as the value for concise will use space separators instead of newlines. Example Print , as opposed to log, the contents of a table (of objects): print ( logString ( getObjects ()))","title":"logString(...)"},{"location":"base/#logstyle","text":"Configures style options for a log(...) tag. Tip Tag log styles can also be set via the System Console with the log_style_tag command. logStyle(tag, tint, prefix, postfix) tag : A String of the log's tag. tint : RGB value to tint the log entry's text. String color will also work. Example: \"Red\" prefix : Text to place before this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. postfix : Text to place after this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. Example Sets the log style (grey text and a suffix) for the log tag \"seats\" . Then proceeds to log a table of available seat colors, using this tag/style. logStyle ( \"seats\" , { 0.5 , 0.5 , 0.5 }, \"\" , \"End List\" ) log ( Player . getAvailableColors (), nil , \"seats\" )","title":"logStyle(...)"},{"location":"base/#print","text":"Print a string into chat that only the host is able to see. Used for debugging scripts. print(message) message : Text to print into the chat log.","title":"print(...)"},{"location":"base/#printtoall","text":"Print a message into the in-game chat of all connected players. printToAll(message, message_tint) message : Message to place into players' in-game chats. message_tint : RGB values for the text's color tint. printToAll ( \"Hello World!\" , { r = 1 , g = 0 , b = 0 })","title":"printToAll(...)"},{"location":"base/#printtocolor","text":"Print a message to the in-game chat of a specific player. printToColor(message, player_color, message_tint) message : Message to place into the player's in-game chat. player_color : Player Color of the player that will receive the message. message_tint : RGB values for the text's color tint. printToColor ( \"Hello Red.\" , \"Red\" , { r = 1 , g = 0 , b = 0 })","title":"printToColor(...)"},{"location":"book/","text":"The Custom PDF is a type in-game Spawnable Object that renders a PDF from a URL. It has its own class, Book, with functions/members associated with it. This allows you to manipulate the special properties of a Custom PDF. Example Usage: obj.Book.setPage(1, false) Member Variables Like Object member variables , Books have their own member variables. Variable Description Type page_offset The page numbers displayed in the Custom PDF UI are offset by this amount. Info For example, if page_offset were set to 10, the first page in the UI would be 11, rather than 1. Negative numbers are accepted, and useful if a rule book contains a front cover, index etc. within the PDF file. Function Summary Object Functions Function Name Description Return getPage( offsetPageNumbering) Gets the current page of the PDF. setPage( page, offsetPageNumbering) Set current page. setHighlight( x1, y1, x2, y2) Set highlight box on current page. clearHighlight() Clears the current highlight. Function Details getPage(...) Gets the current page of the PDF. getPage(offsetPageNumbering) offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number returned. Optional, defaults to `false`. setPage(...) Sets the current page of the PDF. Returns true if the page was succesfully set, false if the page number was invalid. setPage(page, offsetPageNumbering) page : The new page number. offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number set. Optional, defaults to `false`. setHighlight(...) Draws a highlight rectangle on the popout mode of the PDF at the given coordinates. Coordinates (0,0) are the lower left corner of the PDF, while coordinates (1,1) are the upper right corner. setHighlight(x1, y1, x2, y2) x1 : x coordinate of the rectangle's left side. y1 : y coordinate of the rectangle's bottom side. x2 : x coordinate of the rectangle's right side. y2 : y coordinate of the rectangle's top side. -- Sets highlight of upper right quarter of the pdf self . Book . setHighlight ( 0.5 , 0.5 , 1 , 1 ) Bug setHighlight() will do nothing if you try to draw a highlight twice in a row at the same coordinates, even if you call clearHighlight() or reload() on the object in between calls to setHighlight().","title":"Book"},{"location":"book/#member-variables","text":"Like Object member variables , Books have their own member variables. Variable Description Type page_offset The page numbers displayed in the Custom PDF UI are offset by this amount. Info For example, if page_offset were set to 10, the first page in the UI would be 11, rather than 1. Negative numbers are accepted, and useful if a rule book contains a front cover, index etc. within the PDF file.","title":"Member Variables"},{"location":"book/#function-summary","text":"","title":"Function Summary"},{"location":"book/#object-functions","text":"Function Name Description Return getPage( offsetPageNumbering) Gets the current page of the PDF. setPage( page, offsetPageNumbering) Set current page. setHighlight( x1, y1, x2, y2) Set highlight box on current page. clearHighlight() Clears the current highlight.","title":"Object Functions"},{"location":"book/#function-details","text":"","title":"Function Details"},{"location":"book/#getpage","text":"Gets the current page of the PDF. getPage(offsetPageNumbering) offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number returned. Optional, defaults to `false`.","title":"getPage(...)"},{"location":"book/#setpage","text":"Sets the current page of the PDF. Returns true if the page was succesfully set, false if the page number was invalid. setPage(page, offsetPageNumbering) page : The new page number. offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number set. Optional, defaults to `false`.","title":"setPage(...)"},{"location":"book/#sethighlight","text":"Draws a highlight rectangle on the popout mode of the PDF at the given coordinates. Coordinates (0,0) are the lower left corner of the PDF, while coordinates (1,1) are the upper right corner. setHighlight(x1, y1, x2, y2) x1 : x coordinate of the rectangle's left side. y1 : y coordinate of the rectangle's bottom side. x2 : x coordinate of the rectangle's right side. y2 : y coordinate of the rectangle's top side. -- Sets highlight of upper right quarter of the pdf self . Book . setHighlight ( 0.5 , 0.5 , 1 , 1 ) Bug setHighlight() will do nothing if you try to draw a highlight twice in a row at the same coordinates, even if you call clearHighlight() or reload() on the object in between calls to setHighlight().","title":"setHighlight(...)"},{"location":"browser/","text":"The Tablet is an in-game Object that displays a web page. It has its own class, Browser, with member variables associated with it. This allows you to manipulate the special properties of a tablet. Example Usage: self.Browser.url = \"https://yahoo.com/\" Member Variables Like Object member variables , Tablets have their own member variables. Variable Description Type url URL which currently wants to display. pixel_width The pixel width the browser is virtually rendering to.","title":"Browser"},{"location":"browser/#member-variables","text":"Like Object member variables , Tablets have their own member variables. Variable Description Type url URL which currently wants to display. pixel_width The pixel width the browser is virtually rendering to.","title":"Member Variables"},{"location":"built-in-object/","text":"This page has information on each type of non-custom object, including the internal names used in the object's save data, which can be used in the json.Name , data.Name , and type fields of spawnObjectJSON() , spawnObjectData() , and spawnObject() respectively. For Custom Objects, see Custom Game Objects . Object Types Each item listed below is treated as a unique object type. (ie. A red checker tinted black will not stack on top of a regular black checker.) Blocks Name Type Description Notes BlockRectangle Block A blue rectangular prism. BlockSquare Block A red cube. BlockTriangle Block A green triangular prism. Boards All boards spawn locked by default. Name Type Description Notes backgammon_board Board The fold-open board of Backgammon. Includes snap-points along each triangle, totalling 120. CardBot_Board Board The main board and 4 player boards of CardBots, Build & Destroy. Includes snap-points on each card and deck location, totally 79. Checker_Board Board The 8x8 board of Checkers. Includes snap-points on each grid square, totalling 64. Chess_Board Board The 8x8 board of Chess. Includes snap-points on each grid square, totalling 64. Chinese_Checkers_Board Board The 6-pointed board of Sternhalma, or Chinese Checkers. Includes snap-points on each indent, totalling 121. Go_Board Board The 9-starred board of Go. Includes snap-points on each line intersection, totalling 361. Pachisi_board Board A 6-player Pachisi board. Includes snap-points on each indent, totall 133. reversi_board Board The 8x8 board of Reversi. Includes snap-points on each grid square, totalling 64. Cards Name Type Description Notes Card Card A blank card, standard playing card, or Cardbots card. Deck Deck A deck of the 52 standard playing cards. Shuffles immediately when spawned. Deck_CardBot_Head Deck A deck of the 10 head cards for CardBots, Build & Destroy. Shuffles immediately when spawned. Deck_CardBot_Main Deck A deck of the 152 main cards for CardBots, Build & Destroy. Shuffles immediately when spawned. Checkers Name Type Description Notes Checker_black Checker A black checker with a crown emblem on the top side. Checker_red Checker A red checker with a crown emblem on the top side. Checker_white Checker A white checker with a crown emblem on the top side. Chinese_Checkers_Piece Checker A marble for use in Sternhalma, or Chinese Checkers. Chess Pieces Name Type Description Notes Chess_Bishop Chess A chrome Chess bishop. Faces visually to the left. Chess_King Chess A chrome Chess king. Chess_Knight Chess A chrome Chess knight. Faces visually backward (a common chess practice). Chess_Pawn Chess A chrome Chess pawn. Chess_Queen Chess A chrome Chess queen. Chess_Rook Chess A chrome Chess rook. Chips Name Type Description Notes Chip_10 Chip A blue casino chip worth $10 Faces visually to the left. Chip_50 Chip A green casino chip worth $50 Faces visually to the left. Chip_100 Chip A red casino chip worth $100 Faces visually to the left. Chip_500 Chip A silver casino chip worth $500 Faces visually to the left. Chip_1000 Chip A gold casino chip worth $1000 Faces visually to the left. Dice Name Type Description Notes Die_4 Dice A 4-sided die. Die_6 Dice A 6-sided die with dots. Die_6_Rounded Dice A 6-sided die with dots and rounded corners. Die_8 Dice An 8-sided die. Die_10 Dice A 10-sided die. Die_12 Dice A 12-sided die. Die_20 Dice A 20-sided die. Die_Piecepack Dice A wooden 6-sided die. Dominos Name Type Description Notes Domino Domino A blank domino. Mahjong_Coin Domino A coin used in Mahjong. Mahjong_Stick Domino A stick used in Mahjong. Mahjong_Tile Domino A tile used in Mahjong. Figurines Name Type Description Notes Figurine_Card_Bot Figurine A rectangle-based figurine of a CardBot from CardBots, Build & Destroy. Faces visually to the side. Figurine_Kimi_Kat Figurine A rectangle-based figurine of two sitting cats. Figurine_Knil Figurine A baseless figurine of a sword-wielding knight in full-plate armor. Figurine_Mara Figurine A baseless figurine of a bearded man in slacks. Figurine_Sir_Loin Figurine A rectangle-based figurine of a sword-wielding warrior with a shield on his back. Faces visually backwards. Figurine_Zeke Figurine A baseless figurine of a cloaked character wielding a sword. Figurine_Zomblor Figurine A baseless figurine of a zombified riot-officer with knives for hands, wearing a skirt. Metal Ball Figurine A metallic marble. This object's internal name includes a space character and not an underline. PlayerPawn Figurine A small game piece representing a player. Go Pieces Name Type Description Notes go_game_piece_black GoPiece A black Go stone. Spawned from a black Go bowl . go_game_piece_white GoPiece A white Go stone. Spawned from a white Go bowl . go_game_bowl_black GoPiece A bowl that any number of Black Go Stones can be taken from and dropped back into. go_game_bowl_white GoPiece A bowl that any number of White Go Stones can be taken from and dropped back into. Piecepack Name Type Description Notes PiecePack_Arms Piecepack A wooden coin with a blue fleur-de-lis on the underside. PiecePack_Crowns Piecepack A wooden coin with a green crown on the underside. PiecePack_Moons Piecepack A wooden coin with a black moon on the underside. PiecePack_Suns Piecepack A wooden coin with a red sun on the underside. RPG Figurines Name Type Description Notes rpg_BARGHEST rpgFigurine An animated figurine of a mythical barghest. rpg_BASILISK rpgFigurine An animated figurine of a mythical basilisk (a.k.a. cockatrice). rpg_BEAR rpgFigurine An animated figurine of a bear. rpg_BLACK_DRAGON rpgFigurine An animated figurine of an eastern dragon. rpg_CENTAUR rpgFigurine An animated figurine of an armoured centaur. rpg_CERBERUS rpgFigurine An animated figurine of an infernal 3-headed dog. rpg_CHIMERA rpgFigurine An animated figurine of a mythical chimera. rpg_CRASC rpgFigurine An animated figurine of a one-eyed manta-like creature. rpg_CYCLOP rpgFigurine An animated figurine of a club-wielding cyclops. rpg_DARKNESS_WARLORD rpgFigurine An animated figurine of an armoured, morningstar-wielding orc. rpg_DRAGONIDE rpgFigurine An animated figurine of an armored humanoid lizard. rpg_EVIL_WATCHER rpgFigurine An animated figurine of a cycloptic scaled head with eye-stalks and bat-wings. rpg_GHOUL rpgFigurine An animated figurine of an undead humanoid rpg_GIANT_VIPER rpgFigurine An animated figurine of a large snake. rpg_GOBLIN rpgFigurine An animated figurine of a lightly-armored goblin with two knives. rpg_GOLEM rpgFigurine An animated figurine of a large earthen golem. rpg_GRIFFON rpgFigurine An animated figurine of a mythical griffon. rpg_HYDRA rpgFigurine An animated figurine of a large 3-headed lizard. rpg_KNIGHT rpgFigurine An animated figurine of a knight in full-plate armor wielding a sword and shield. rpg_KOBOLD rpgFigurine An animated figurine of a small helmeted humanoid. rpg_LIZARD_WARRIOR rpgFigurine An animated figurine of a sword-wielding lizard-like humanoid rpg_MAGE rpgFigurine An animated figurine of a staff-wielding mage. rpg_MANTICORA rpgFigurine An animated figurine of a mythical manticore. This type is spelled with an A. rpg_MUMMY rpgFigurine An animated figurine of a living mummy. rpg_OGRE rpgFigurine An animated figurine of a large boiled humanoid. rpg_ORC rpgFigurine An animated figurine of an axe-wielding orc. rpg_RANGER rpgFigurine An animated figurine of a bow-wielding ranger. rpg_RAT rpgFigurine An animated figurine of a giant rat. rpg_SKELETON_KNIGHT rpgFigurine An animated figurine of an armored living skeleton. rpg_TEMPLATE rpgFigurine The base of an RPG figurine. It has the same animatable triggers as any other RPG Figurine, but no associated animations. rpg_THIEF rpgFigurine An animated figurine of a cowled knife-wielding thief. rpg_TREE_ENT rpgFigurine An animated figurine of a large tree creature. rpg_TROLL rpgFigurine An animated figurine of a large green humanoid. rpg_VAMPIRE rpgFigurine An animated figurine of a large wingless bat. rpg_WARRIOR rpgFigurine An animated figurine of a stout, bearded, axe-wielding warrior in scale mail. rpg_WEREWOLF rpgFigurine An animated figurine of a mythical werewolf. rpg_WYVERN rpgFigurine An animated figurine of a mythical wyvern. Tileset Pieces Name Type Description Notes Tileset_Barrel Tileset A small barrel for use in RPG Tilesets. Tileset_Chair Tileset A small chair for use in RPG Tilesets. Tileset_Chest Tileset A small chest for use in RPG Tilesets. Tileset_Corner Tileset A floor tile with two walls for use in RPG Tilesets. Tileset_Floor Tileset A floor tile for use in RPG Tilesets. Tileset_Rock Tileset A small rock for use in RPG Tilesets. Tileset_Table Tileset A small table for use in RPG Tilesets. Tileset_Tree Tileset A small tree for use in RPG Tilesets. Tileset_Wall Tileset A floor tile with a wall for use in RPG Tilesets. Other Name Type Description Notes backgammon_piece_brown Backgammon Piece A brown Backgammon piece. backgammon_piece_white Backgammon Piece A white Backgammon piece. Bag Bag A pouch that objects can be stored in and taken from. Bowl Generic A wooden bowl that objects can be dropped in. The bowl does not have an inventory, objects merely rest within it visually. Calculator Calculator An interactive calculator. Faces visually backwards. Counter Counter An interactive digital counter. Digital_Clock Clock An interactive digital clock. Infinite_Bag A pouch that any number of copies of a single object can be taken from and dropped back into. An object must be put into the bag to become the source object. Notecard Notecard An editable notecard. Quarter Coin An american quarter minted in 1942. Spawns tails-up, facing to the right. reversi_chip Generic A dual-colored Reversi chip. Spawns white-side up. Tablet Tablet A tablet that displays a webpage. Scripting Name Description Notes ScriptingTrigger A Scripting Zone. FogOfWarTrigger A Hidden Zone FogOfWar A Fog of War Zone 3DText The text that the Text Tool spawns. Spawnable Names When using spawnObject() , the type parameter can be any of the above object types, or any of the below names, which spawns an object of a certain type, and with certain properties different from default. Alternate Name Object Differences Arms Dice Die_Piecepack MaterialIndex of 0 . Backgammon Board backgammon_board Snaps to table level immediately upon spawn. Barrel Tileset_Barrel (none) Bear rpg_BEAR (none) Bishop Cast Iron Chess_Bishop MaterialIndex of 1 . Bishop Chrome Chess_Bishop MaterialIndex of 0 . Bishop Dark Wood Chess_Bishop MaterialIndex of 3 . Bishop Light Wood Chess_Bishop MaterialIndex of 2 . Black Ball Chinese_Checkers_Piece MaterialIndex of 6 . Black Checker Checker_black (none) Black Pawn PlayerPawn MaterialIndex of 8 . Blue 10 Chip_10 (none) Blue Ball Chinese_Checkers_Piece MaterialIndex of 4 . Blue Pawn PlayerPawn MaterialIndex of 5 . Blue Rectangle BlockRectangle (none) Brown Backgammon backgammon_piece_brown (none) CardBot Figurine_Card_Bot (none) CardBots Head Deck Deck_CardBot_Head (none) CardBots Main Deck Deck_CardBot_Main (none) Chair Tileset_Chair (none) Checkers Board Checker_Board Snaps to table level immediately upon spawn. Chess Board Chess_Board Snaps to table level immediately upon spawn. Chest Tileset_Chest (none) Chimera rpg_CHIMERA (none) Chinese Checkers Board Chinese_Checkers_Board Snaps to table level immediately upon spawn. Corner Tileset_Corner (none) Crowns Dice Die_Piecepack MaterialIndex of 1 . Custom Board Custom_Board Snaps to table level immediately upon spawn. Custom Deck DeckCustom (none) Custom Figurine Figurine_Custom (none) Custom Model Custom_Model (none) Cyclops rpg_CYCLOP (none) D10 Die_10 MaterialIndex of 0 . D10 Chrome Die_10 MaterialIndex of 1 , AltSound of true . D12 Die_12 MaterialIndex of 0 . D12 Chrome Die_12 MaterialIndex of 1 , AltSound of true . D20 Die_20 MaterialIndex of 0 . D20 Chrome Die_20 MaterialIndex of 1 , AltSound of true . D4 Die_4 MaterialIndex of 0 . D4 Chrome Die_4 MaterialIndex of 1 , AltSound of true . D6 Die_6 MaterialIndex of 0 . D6 Black Die_6_Rounded MaterialIndex of 0 . D6 Blue Die_6_Rounded MaterialIndex of 3 . D6 Chrome Die_6 MaterialIndex of 1 , AltSound of true . D6 Green Die_6_Rounded MaterialIndex of 2 . D6 Red Die_6_Rounded MaterialIndex of 1 . D8 Die_8 MaterialIndex of 0 . D8 Chrome Die_8 MaterialIndex of 1 , AltSound of true . Digital Clock Digital_Clock (none) Dragonide rpg_DRAGONIDE (none) Evil Watcher rpg_EVIL_WATCHER (none) Floor Tileset_Floor (none) Ghoul rpg_GHOUL (none) Giant Rat rpg_RAT (none) Giant Viper rpg_GIANT_VIPER (none) Go Board Go_Board Snaps to table level immediately upon spawn. GO Bowl Black go_game_bowl_black (none) GO Bowl White go_game_bowl_white (none) GO Piece Black go_game_piece_black (none) GO Piece White go_game_piece_white (none) Goblin rpg_GOBLIN (none) Gold 1000 Chip_1000 (none) Golem rpg_GOLEM (none) Green 50 Chip_50 (none) Green Ball Chinese_Checkers_Piece MaterialIndex of 3 . Green Pawn PlayerPawn MaterialIndex of 4 . Green Triangle BlockTriangle (none) Griffon rpg_GRIFFON (none) Hydra rpg_HYDRA (none) Joker Card CardID of 52 . Kimi Kat Figurine_Kimi_Kat (none) King Cast Iron Chess_King MaterialIndex of 1 . King Chrome Chess_King MaterialIndex of 0 . King Dark Wood Chess_King MaterialIndex of 3 . King Light Wood Chess_King MaterialIndex of 2 . Knight Cast Iron Chess_Knight MaterialIndex of 1 . Knight Chrome Chess_Knight MaterialIndex of 0 . Knight Dark Wood Chess_Knight MaterialIndex of 3 . Knight Light Wood Chess_Knight MaterialIndex of 2 . Knight of Knil Figurine_Knil (none) Kobold rpg_KOBOLD (none) Lizard Warrior rpg_LIZARD_WARRIOR (none) Loot Bag Bag (none) Manticora rpg_MANTICORA (none) Mara Figurine_Mara (none) Moons Dice Die_Piecepack MaterialIndex of 2 . Mummy rpg_MUMMY (none) Ogre rpg_OGRE (none) Orange Pawn PlayerPawn MaterialIndex of 2 . Orc rpg_ORC (none) Pachisi Board Pachisi_board Snaps to table level immediately upon spawn. Pawn Cast Iron Chess_Pawn MaterialIndex of 1 . Pawn Chrome Chess_Pawn MaterialIndex of 0 . Pawn Dark Wood Chess_Pawn MaterialIndex of 3 . Pawn Light Wood Chess_Pawn MaterialIndex of 2 . Pink Ball Chinese_Checkers_Piece MaterialIndex of 5 . Pink Pawn PlayerPawn MaterialIndex of 7 . Purple Pawn PlayerPawn MaterialIndex of 6 . Quarter Quarter (none) Queen Cast Iron Chess_Queen MaterialIndex of 1 . Queen Chrome Chess_Queen MaterialIndex of 0 . Queen Dark Wood Chess_Queen MaterialIndex of 3 . Queen Light Wood Chess_Queen MaterialIndex of 2 . Random Card Card Random CardID between 0 and 51 (inclusive). Random Domino Domino Random MeshIndex between 0 and 27 (inclusive). Random Mahjong Mahjong_Tile Random MeshIndex between 0 and 35 (inclusive). Red 100 Chip_100 (none) Red Ball Chinese_Checkers_Piece MaterialIndex of 1 . Red Checker Checker_red (none) Red Pawn PlayerPawn MaterialIndex of 1 . Red Square BlockSquare (none) Reversi Board reversi_board Snaps to table level immediately upon spawn. Reversi Chip reversi_chip (none) Rock Tileset_Rock (none) Rook Cast Iron Chess_Rook MaterialIndex of 1 . Rook Chrome Chess_Rook MaterialIndex of 0 . Rook Dark Wood Chess_Rook MaterialIndex of 3 . Rook Light Wood Chess_Rook MaterialIndex of 2 . Silver 500 Chip_500 (none) Sir Loin Figurine_Sir_Loin (none) Skeleton Knight rpg_SKELETON_KNIGHT (none) Standard Deck Deck (none) Suns Dice Die_Piecepack MaterialIndex of 3 . Table Tileset_Table (none) Tree Tileset_Tree (none) Tree Ent rpg_TREE_ENT (none) Troll rpg_TROLL (none) Vampire rpg_VAMPIRE (none) Wall Tileset_Wall (none) Werewolf rpg_WEREWOLF (none) White Backgammon backgammon_piece_white (none) White Ball Chinese_Checkers_Piece MaterialIndex of 0 . White Checker Checker_white (none) White Pawn PlayerPawn MaterialIndex of 0 . Wolf rpg_WOLF (none) Wyvern rpg_WYVERN (none) Yellow Ball Chinese_Checkers_Piece MaterialIndex of 2 . Yellow Pawn PlayerPawn MaterialIndex of 3 . Zeke Kodoku Figurine_Zeke (none) Zomblor Figurine_Zomblor (none)","title":"Built-in"},{"location":"built-in-object/#object-types","text":"Each item listed below is treated as a unique object type. (ie. A red checker tinted black will not stack on top of a regular black checker.)","title":"Object Types"},{"location":"built-in-object/#blocks","text":"Name Type Description Notes BlockRectangle Block A blue rectangular prism. BlockSquare Block A red cube. BlockTriangle Block A green triangular prism.","title":"Blocks"},{"location":"built-in-object/#boards","text":"All boards spawn locked by default. Name Type Description Notes backgammon_board Board The fold-open board of Backgammon. Includes snap-points along each triangle, totalling 120. CardBot_Board Board The main board and 4 player boards of CardBots, Build & Destroy. Includes snap-points on each card and deck location, totally 79. Checker_Board Board The 8x8 board of Checkers. Includes snap-points on each grid square, totalling 64. Chess_Board Board The 8x8 board of Chess. Includes snap-points on each grid square, totalling 64. Chinese_Checkers_Board Board The 6-pointed board of Sternhalma, or Chinese Checkers. Includes snap-points on each indent, totalling 121. Go_Board Board The 9-starred board of Go. Includes snap-points on each line intersection, totalling 361. Pachisi_board Board A 6-player Pachisi board. Includes snap-points on each indent, totall 133. reversi_board Board The 8x8 board of Reversi. Includes snap-points on each grid square, totalling 64.","title":"Boards"},{"location":"built-in-object/#cards","text":"Name Type Description Notes Card Card A blank card, standard playing card, or Cardbots card. Deck Deck A deck of the 52 standard playing cards. Shuffles immediately when spawned. Deck_CardBot_Head Deck A deck of the 10 head cards for CardBots, Build & Destroy. Shuffles immediately when spawned. Deck_CardBot_Main Deck A deck of the 152 main cards for CardBots, Build & Destroy. Shuffles immediately when spawned.","title":"Cards"},{"location":"built-in-object/#checkers","text":"Name Type Description Notes Checker_black Checker A black checker with a crown emblem on the top side. Checker_red Checker A red checker with a crown emblem on the top side. Checker_white Checker A white checker with a crown emblem on the top side. Chinese_Checkers_Piece Checker A marble for use in Sternhalma, or Chinese Checkers.","title":"Checkers"},{"location":"built-in-object/#chess-pieces","text":"Name Type Description Notes Chess_Bishop Chess A chrome Chess bishop. Faces visually to the left. Chess_King Chess A chrome Chess king. Chess_Knight Chess A chrome Chess knight. Faces visually backward (a common chess practice). Chess_Pawn Chess A chrome Chess pawn. Chess_Queen Chess A chrome Chess queen. Chess_Rook Chess A chrome Chess rook.","title":"Chess Pieces"},{"location":"built-in-object/#chips","text":"Name Type Description Notes Chip_10 Chip A blue casino chip worth $10 Faces visually to the left. Chip_50 Chip A green casino chip worth $50 Faces visually to the left. Chip_100 Chip A red casino chip worth $100 Faces visually to the left. Chip_500 Chip A silver casino chip worth $500 Faces visually to the left. Chip_1000 Chip A gold casino chip worth $1000 Faces visually to the left.","title":"Chips"},{"location":"built-in-object/#dice","text":"Name Type Description Notes Die_4 Dice A 4-sided die. Die_6 Dice A 6-sided die with dots. Die_6_Rounded Dice A 6-sided die with dots and rounded corners. Die_8 Dice An 8-sided die. Die_10 Dice A 10-sided die. Die_12 Dice A 12-sided die. Die_20 Dice A 20-sided die. Die_Piecepack Dice A wooden 6-sided die.","title":"Dice"},{"location":"built-in-object/#dominos","text":"Name Type Description Notes Domino Domino A blank domino. Mahjong_Coin Domino A coin used in Mahjong. Mahjong_Stick Domino A stick used in Mahjong. Mahjong_Tile Domino A tile used in Mahjong.","title":"Dominos"},{"location":"built-in-object/#figurines","text":"Name Type Description Notes Figurine_Card_Bot Figurine A rectangle-based figurine of a CardBot from CardBots, Build & Destroy. Faces visually to the side. Figurine_Kimi_Kat Figurine A rectangle-based figurine of two sitting cats. Figurine_Knil Figurine A baseless figurine of a sword-wielding knight in full-plate armor. Figurine_Mara Figurine A baseless figurine of a bearded man in slacks. Figurine_Sir_Loin Figurine A rectangle-based figurine of a sword-wielding warrior with a shield on his back. Faces visually backwards. Figurine_Zeke Figurine A baseless figurine of a cloaked character wielding a sword. Figurine_Zomblor Figurine A baseless figurine of a zombified riot-officer with knives for hands, wearing a skirt. Metal Ball Figurine A metallic marble. This object's internal name includes a space character and not an underline. PlayerPawn Figurine A small game piece representing a player.","title":"Figurines"},{"location":"built-in-object/#go-pieces","text":"Name Type Description Notes go_game_piece_black GoPiece A black Go stone. Spawned from a black Go bowl . go_game_piece_white GoPiece A white Go stone. Spawned from a white Go bowl . go_game_bowl_black GoPiece A bowl that any number of Black Go Stones can be taken from and dropped back into. go_game_bowl_white GoPiece A bowl that any number of White Go Stones can be taken from and dropped back into.","title":"Go Pieces"},{"location":"built-in-object/#piecepack","text":"Name Type Description Notes PiecePack_Arms Piecepack A wooden coin with a blue fleur-de-lis on the underside. PiecePack_Crowns Piecepack A wooden coin with a green crown on the underside. PiecePack_Moons Piecepack A wooden coin with a black moon on the underside. PiecePack_Suns Piecepack A wooden coin with a red sun on the underside.","title":"Piecepack"},{"location":"built-in-object/#rpg-figurines","text":"Name Type Description Notes rpg_BARGHEST rpgFigurine An animated figurine of a mythical barghest. rpg_BASILISK rpgFigurine An animated figurine of a mythical basilisk (a.k.a. cockatrice). rpg_BEAR rpgFigurine An animated figurine of a bear. rpg_BLACK_DRAGON rpgFigurine An animated figurine of an eastern dragon. rpg_CENTAUR rpgFigurine An animated figurine of an armoured centaur. rpg_CERBERUS rpgFigurine An animated figurine of an infernal 3-headed dog. rpg_CHIMERA rpgFigurine An animated figurine of a mythical chimera. rpg_CRASC rpgFigurine An animated figurine of a one-eyed manta-like creature. rpg_CYCLOP rpgFigurine An animated figurine of a club-wielding cyclops. rpg_DARKNESS_WARLORD rpgFigurine An animated figurine of an armoured, morningstar-wielding orc. rpg_DRAGONIDE rpgFigurine An animated figurine of an armored humanoid lizard. rpg_EVIL_WATCHER rpgFigurine An animated figurine of a cycloptic scaled head with eye-stalks and bat-wings. rpg_GHOUL rpgFigurine An animated figurine of an undead humanoid rpg_GIANT_VIPER rpgFigurine An animated figurine of a large snake. rpg_GOBLIN rpgFigurine An animated figurine of a lightly-armored goblin with two knives. rpg_GOLEM rpgFigurine An animated figurine of a large earthen golem. rpg_GRIFFON rpgFigurine An animated figurine of a mythical griffon. rpg_HYDRA rpgFigurine An animated figurine of a large 3-headed lizard. rpg_KNIGHT rpgFigurine An animated figurine of a knight in full-plate armor wielding a sword and shield. rpg_KOBOLD rpgFigurine An animated figurine of a small helmeted humanoid. rpg_LIZARD_WARRIOR rpgFigurine An animated figurine of a sword-wielding lizard-like humanoid rpg_MAGE rpgFigurine An animated figurine of a staff-wielding mage. rpg_MANTICORA rpgFigurine An animated figurine of a mythical manticore. This type is spelled with an A. rpg_MUMMY rpgFigurine An animated figurine of a living mummy. rpg_OGRE rpgFigurine An animated figurine of a large boiled humanoid. rpg_ORC rpgFigurine An animated figurine of an axe-wielding orc. rpg_RANGER rpgFigurine An animated figurine of a bow-wielding ranger. rpg_RAT rpgFigurine An animated figurine of a giant rat. rpg_SKELETON_KNIGHT rpgFigurine An animated figurine of an armored living skeleton. rpg_TEMPLATE rpgFigurine The base of an RPG figurine. It has the same animatable triggers as any other RPG Figurine, but no associated animations. rpg_THIEF rpgFigurine An animated figurine of a cowled knife-wielding thief. rpg_TREE_ENT rpgFigurine An animated figurine of a large tree creature. rpg_TROLL rpgFigurine An animated figurine of a large green humanoid. rpg_VAMPIRE rpgFigurine An animated figurine of a large wingless bat. rpg_WARRIOR rpgFigurine An animated figurine of a stout, bearded, axe-wielding warrior in scale mail. rpg_WEREWOLF rpgFigurine An animated figurine of a mythical werewolf. rpg_WYVERN rpgFigurine An animated figurine of a mythical wyvern.","title":"RPG Figurines"},{"location":"built-in-object/#tileset-pieces","text":"Name Type Description Notes Tileset_Barrel Tileset A small barrel for use in RPG Tilesets. Tileset_Chair Tileset A small chair for use in RPG Tilesets. Tileset_Chest Tileset A small chest for use in RPG Tilesets. Tileset_Corner Tileset A floor tile with two walls for use in RPG Tilesets. Tileset_Floor Tileset A floor tile for use in RPG Tilesets. Tileset_Rock Tileset A small rock for use in RPG Tilesets. Tileset_Table Tileset A small table for use in RPG Tilesets. Tileset_Tree Tileset A small tree for use in RPG Tilesets. Tileset_Wall Tileset A floor tile with a wall for use in RPG Tilesets.","title":"Tileset Pieces"},{"location":"built-in-object/#other","text":"Name Type Description Notes backgammon_piece_brown Backgammon Piece A brown Backgammon piece. backgammon_piece_white Backgammon Piece A white Backgammon piece. Bag Bag A pouch that objects can be stored in and taken from. Bowl Generic A wooden bowl that objects can be dropped in. The bowl does not have an inventory, objects merely rest within it visually. Calculator Calculator An interactive calculator. Faces visually backwards. Counter Counter An interactive digital counter. Digital_Clock Clock An interactive digital clock. Infinite_Bag A pouch that any number of copies of a single object can be taken from and dropped back into. An object must be put into the bag to become the source object. Notecard Notecard An editable notecard. Quarter Coin An american quarter minted in 1942. Spawns tails-up, facing to the right. reversi_chip Generic A dual-colored Reversi chip. Spawns white-side up. Tablet Tablet A tablet that displays a webpage.","title":"Other"},{"location":"built-in-object/#scripting","text":"Name Description Notes ScriptingTrigger A Scripting Zone. FogOfWarTrigger A Hidden Zone FogOfWar A Fog of War Zone 3DText The text that the Text Tool spawns.","title":"Scripting"},{"location":"built-in-object/#spawnable-names","text":"When using spawnObject() , the type parameter can be any of the above object types, or any of the below names, which spawns an object of a certain type, and with certain properties different from default. Alternate Name Object Differences Arms Dice Die_Piecepack MaterialIndex of 0 . Backgammon Board backgammon_board Snaps to table level immediately upon spawn. Barrel Tileset_Barrel (none) Bear rpg_BEAR (none) Bishop Cast Iron Chess_Bishop MaterialIndex of 1 . Bishop Chrome Chess_Bishop MaterialIndex of 0 . Bishop Dark Wood Chess_Bishop MaterialIndex of 3 . Bishop Light Wood Chess_Bishop MaterialIndex of 2 . Black Ball Chinese_Checkers_Piece MaterialIndex of 6 . Black Checker Checker_black (none) Black Pawn PlayerPawn MaterialIndex of 8 . Blue 10 Chip_10 (none) Blue Ball Chinese_Checkers_Piece MaterialIndex of 4 . Blue Pawn PlayerPawn MaterialIndex of 5 . Blue Rectangle BlockRectangle (none) Brown Backgammon backgammon_piece_brown (none) CardBot Figurine_Card_Bot (none) CardBots Head Deck Deck_CardBot_Head (none) CardBots Main Deck Deck_CardBot_Main (none) Chair Tileset_Chair (none) Checkers Board Checker_Board Snaps to table level immediately upon spawn. Chess Board Chess_Board Snaps to table level immediately upon spawn. Chest Tileset_Chest (none) Chimera rpg_CHIMERA (none) Chinese Checkers Board Chinese_Checkers_Board Snaps to table level immediately upon spawn. Corner Tileset_Corner (none) Crowns Dice Die_Piecepack MaterialIndex of 1 . Custom Board Custom_Board Snaps to table level immediately upon spawn. Custom Deck DeckCustom (none) Custom Figurine Figurine_Custom (none) Custom Model Custom_Model (none) Cyclops rpg_CYCLOP (none) D10 Die_10 MaterialIndex of 0 . D10 Chrome Die_10 MaterialIndex of 1 , AltSound of true . D12 Die_12 MaterialIndex of 0 . D12 Chrome Die_12 MaterialIndex of 1 , AltSound of true . D20 Die_20 MaterialIndex of 0 . D20 Chrome Die_20 MaterialIndex of 1 , AltSound of true . D4 Die_4 MaterialIndex of 0 . D4 Chrome Die_4 MaterialIndex of 1 , AltSound of true . D6 Die_6 MaterialIndex of 0 . D6 Black Die_6_Rounded MaterialIndex of 0 . D6 Blue Die_6_Rounded MaterialIndex of 3 . D6 Chrome Die_6 MaterialIndex of 1 , AltSound of true . D6 Green Die_6_Rounded MaterialIndex of 2 . D6 Red Die_6_Rounded MaterialIndex of 1 . D8 Die_8 MaterialIndex of 0 . D8 Chrome Die_8 MaterialIndex of 1 , AltSound of true . Digital Clock Digital_Clock (none) Dragonide rpg_DRAGONIDE (none) Evil Watcher rpg_EVIL_WATCHER (none) Floor Tileset_Floor (none) Ghoul rpg_GHOUL (none) Giant Rat rpg_RAT (none) Giant Viper rpg_GIANT_VIPER (none) Go Board Go_Board Snaps to table level immediately upon spawn. GO Bowl Black go_game_bowl_black (none) GO Bowl White go_game_bowl_white (none) GO Piece Black go_game_piece_black (none) GO Piece White go_game_piece_white (none) Goblin rpg_GOBLIN (none) Gold 1000 Chip_1000 (none) Golem rpg_GOLEM (none) Green 50 Chip_50 (none) Green Ball Chinese_Checkers_Piece MaterialIndex of 3 . Green Pawn PlayerPawn MaterialIndex of 4 . Green Triangle BlockTriangle (none) Griffon rpg_GRIFFON (none) Hydra rpg_HYDRA (none) Joker Card CardID of 52 . Kimi Kat Figurine_Kimi_Kat (none) King Cast Iron Chess_King MaterialIndex of 1 . King Chrome Chess_King MaterialIndex of 0 . King Dark Wood Chess_King MaterialIndex of 3 . King Light Wood Chess_King MaterialIndex of 2 . Knight Cast Iron Chess_Knight MaterialIndex of 1 . Knight Chrome Chess_Knight MaterialIndex of 0 . Knight Dark Wood Chess_Knight MaterialIndex of 3 . Knight Light Wood Chess_Knight MaterialIndex of 2 . Knight of Knil Figurine_Knil (none) Kobold rpg_KOBOLD (none) Lizard Warrior rpg_LIZARD_WARRIOR (none) Loot Bag Bag (none) Manticora rpg_MANTICORA (none) Mara Figurine_Mara (none) Moons Dice Die_Piecepack MaterialIndex of 2 . Mummy rpg_MUMMY (none) Ogre rpg_OGRE (none) Orange Pawn PlayerPawn MaterialIndex of 2 . Orc rpg_ORC (none) Pachisi Board Pachisi_board Snaps to table level immediately upon spawn. Pawn Cast Iron Chess_Pawn MaterialIndex of 1 . Pawn Chrome Chess_Pawn MaterialIndex of 0 . Pawn Dark Wood Chess_Pawn MaterialIndex of 3 . Pawn Light Wood Chess_Pawn MaterialIndex of 2 . Pink Ball Chinese_Checkers_Piece MaterialIndex of 5 . Pink Pawn PlayerPawn MaterialIndex of 7 . Purple Pawn PlayerPawn MaterialIndex of 6 . Quarter Quarter (none) Queen Cast Iron Chess_Queen MaterialIndex of 1 . Queen Chrome Chess_Queen MaterialIndex of 0 . Queen Dark Wood Chess_Queen MaterialIndex of 3 . Queen Light Wood Chess_Queen MaterialIndex of 2 . Random Card Card Random CardID between 0 and 51 (inclusive). Random Domino Domino Random MeshIndex between 0 and 27 (inclusive). Random Mahjong Mahjong_Tile Random MeshIndex between 0 and 35 (inclusive). Red 100 Chip_100 (none) Red Ball Chinese_Checkers_Piece MaterialIndex of 1 . Red Checker Checker_red (none) Red Pawn PlayerPawn MaterialIndex of 1 . Red Square BlockSquare (none) Reversi Board reversi_board Snaps to table level immediately upon spawn. Reversi Chip reversi_chip (none) Rock Tileset_Rock (none) Rook Cast Iron Chess_Rook MaterialIndex of 1 . Rook Chrome Chess_Rook MaterialIndex of 0 . Rook Dark Wood Chess_Rook MaterialIndex of 3 . Rook Light Wood Chess_Rook MaterialIndex of 2 . Silver 500 Chip_500 (none) Sir Loin Figurine_Sir_Loin (none) Skeleton Knight rpg_SKELETON_KNIGHT (none) Standard Deck Deck (none) Suns Dice Die_Piecepack MaterialIndex of 3 . Table Tileset_Table (none) Tree Tileset_Tree (none) Tree Ent rpg_TREE_ENT (none) Troll rpg_TROLL (none) Vampire rpg_VAMPIRE (none) Wall Tileset_Wall (none) Werewolf rpg_WEREWOLF (none) White Backgammon backgammon_piece_white (none) White Ball Chinese_Checkers_Piece MaterialIndex of 0 . White Checker Checker_white (none) White Pawn PlayerPawn MaterialIndex of 0 . Wolf rpg_WOLF (none) Wyvern rpg_WYVERN (none) Yellow Ball Chinese_Checkers_Piece MaterialIndex of 2 . Yellow Pawn PlayerPawn MaterialIndex of 3 . Zeke Kodoku Figurine_Zeke (none) Zomblor Figurine_Zomblor (none)","title":"Spawnable Names"},{"location":"clock/","text":"The clock is an in-game Object which either tells time or acts as a timer. It has its own class, Clock, with functions/members associated with it. This allows you to manipulate the special properties of a clock. Example Usage: self.Clock.pauseStart() Clock Modes: Current Time : Displays the current time of the host. Stopwatch : Displays a running count up. Timer : Displays a countdown and beeps once complete. Member Variables Like Object member variables , Clocks have their own member variable. Variable Description Type paused If the clock timer is paused. Function Summary Object Functions Function Name Description Return getValue() Current time in stopwatch or timer mode. Clock mode returns 0. This function acts the same as Object's getValue() . pauseStart() Pauses/resumes a Clock in stopwatch or timer mode. setValue( seconds) Switches clock to timer and sets countdown time. This function acts the same as Object's setValue() . showCurrentTime() Switches clock to display current time. It will clear any stopwatch or timer. startStopwatch() Switches clock to stopwatch, setting time to 0. It will reset time if already in stopwatch mode. Function Details setValue(...) Set the timer to display a number of seconds. This function acts the same as Object's setValue() . If the Clock is not in timer mode, it will be switched. If it is in timer mode, it will be paused and the remaining time will be changed. This will not start the countdown on its own. setValue(seconds) seconds : How many seconds will be counted down. self . Clock . setValue ( 30 )","title":"Clock"},{"location":"clock/#member-variables","text":"Like Object member variables , Clocks have their own member variable. Variable Description Type paused If the clock timer is paused.","title":"Member Variables"},{"location":"clock/#function-summary","text":"","title":"Function Summary"},{"location":"clock/#object-functions","text":"Function Name Description Return getValue() Current time in stopwatch or timer mode. Clock mode returns 0. This function acts the same as Object's getValue() . pauseStart() Pauses/resumes a Clock in stopwatch or timer mode. setValue( seconds) Switches clock to timer and sets countdown time. This function acts the same as Object's setValue() . showCurrentTime() Switches clock to display current time. It will clear any stopwatch or timer. startStopwatch() Switches clock to stopwatch, setting time to 0. It will reset time if already in stopwatch mode.","title":"Object Functions"},{"location":"clock/#function-details","text":"","title":"Function Details"},{"location":"clock/#setvalue","text":"Set the timer to display a number of seconds. This function acts the same as Object's setValue() . If the Clock is not in timer mode, it will be switched. If it is in timer mode, it will be paused and the remaining time will be changed. This will not start the countdown on its own. setValue(seconds) seconds : How many seconds will be counted down. self . Clock . setValue ( 30 )","title":"setValue(...)"},{"location":"color/","text":"Color is a type of Table that is used to define RGBA values for tinting. R for red, G for green, B for blue and A for alpha (transparency) Besides the functions listed below, other classes can be used to manipulate colors as well. Example Usage: orange = Color ( 1 , 0 , 0 ): lerp ( Color ( 1 , 1 , 0 ), 0.5 ) Check Manipulation examples for more detailed usage. Tip Vector and Color are the first classes to be defined in pure Lua. This means you have to use colon operator (e.g. col:lerp() ) to call member functions, not the dot operator. Failing to do so will fail with cryptic error messages displayed. Constructors summary Tip Every place that returns a coordinate table, like obj . getColorTint () , serves a Color class instance already - you do not have to explicitly construct it. When constructing Color instances, the .new part can be omitted, making e.g. Color ( 1 , 0.5 , 0.75 ) equivalent to Color . new ( 1 , 0.5 , 0.75 ) . Function Name Description Return Color( r, g, b) Return a color with specified (r, g, b) components. Color( r, g, b, a) Return a color with specified (r, g, b, a) components. Color( t) Return a color with r/g/b/a components from source table . Color.new(...) Same as Color(...). Color.fromString( colorStr) Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.Blue Shorthand for Color.fromString('Blue'), works for all Player and added colors , capitalization ignored. Also return the color name. Constructors examples function onLoad () local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local orangePlayer = Color . fromString ( \"Orange\" ) local purplePlayer = Color . Purple end Element access summary In addition to accessing color components by their numeric indices (1, 2, 3, 4) and textual identifiers (r, g, b, a), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( r, g, b, a) Sets r , g , b , a components to given values and returns self, alpha is optional get() Returns r , g , b , a components as four separate values. copy() Returns a separate Color with identical component values. Tip Before Color was introduced, color tables contained separate values under 1, 2, 3, 4 and r, g, b, a keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Color components you have to use pairs and only letter keys will be read there. Element access examples function onLoad () local col = Color ( 0 , 0.5 , 0.75 ) col . r = 1 -- set the first component col [ 2 ] = 0.25 -- set the second component col : setAt ( 'b' , 1 ) -- set the third component print ( col : get ()) --> same as print(col.r, col.g, col.b, col.a) for colorCode , value in pairs ( col ) do print ( colorCode .. \"=\" .. value ) --> r=1 then g=0.25 then b=1 and finally a=1 end col : copy (): setAt ( 'a' , 0.5 ) print ( col . a ) --> 1, because we only changed 'a' on a copy end Arithmetics summary Color also allows you to use arithmetic operators to performs basic operations: Operator Description Return one == two Return true if both colors identical or within a small margin of each other, false otherwise. See also color:equals() . tostring( col) Return a string description of a color. Arithmetics examples function onLoad () local col = Color ({ r = 0.118 , g = 0.53 , b = 1 }) print ( col == Color . blue ) --> true -- Color : Blue { r = 0.118, g = 0.53, b = 1, a = 1} tostring ( Color ( 0.118 , 0.53 , 1 )) --> Color : { r = 0.3, g = 0.5, b = 1, a = 1} tostring ( Color ({ r = 0.3 , g = 0.5 , b = 1 })) end Methods summary Methods not modifying self Method Name Description Return col:toHex( includeAlpha) Returns a hex string for col , boolean parameter includeAlpha . col:toString( tolerance) Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. col:equals( otherCol, num) Returns true if otherCol same as col , false otherwise, optional numeric tolerance param. col:lerp( otherCol, num) Return a color some part of the way between col and otherCol , numeric arg [0, 1] is the fraction. col:dump( prefix) Return a string description of a color with an optional prefix . Other methods Method Name Description Return Color.list Returns a table of all color strings. Color.Add( name, yourColor) Add your own color definition to the class. Constructors details Color.new(...) Return a color with specified components. Color.new(r, g, b) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. Color.new(r, g, b, a) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. a : Alpha component between 0 and 1. Color.new(t) t : The table should use the r , g , b and a index. By default the value is 0 for color and 1 for alpha. local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local river = Color ( 52 / 255 , 152 / 255 , 219 / 255 , 160 / 255 ) local teal = Color ({ r = 0.129 , g = 0.694 , b = 0.607 }) Info If you want to use value between 0 and 255 you should divide them by 255 before construct the object. Color.fromString(...) Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.fromString(colorStr) colorStr : Any Player Color or color added with Color.Add . local col = Color . fromString ( \"Blue\" ) print ( col ) --> Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } Color.Blue Return a color from a color string ('Red', 'Green' etc). Any Player Color or color added with Color.Add . local color , name = Color . Blue print ( color ) -- Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( name ) -- Blue local color , name = Color . Red print ( color ) -- Color: Red { r = 0.856, g = 0.1, b = 0.094, a = 1 } print ( name ) -- Red Element access details setAt(...) Update one component of the color and returning self. setAt(key, num) key : Index of component (1, 2, 3 or 4 for r, g, b or a). num : New value. col = Color . Blue col : setAt ( 1 , 128 / 255 ): setAt ( 'a' , 0.5 ) print ( col ) --> Color: { r = 0.501961, g = 0.53, b = 1, a = 0.5 } set(...) Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(r, g, b) r : New value of Red component. g : New value of Green component. b : New value of Blue component. set(r, g, b, a) r : New value of Red component. g : New value of Green component. b : New value of Blue component. a : New value of Alpha component. col = Color . black col : set ( 41 / 255 , 128 / 255 , 185 / 255 ) print ( col ) --> Color: { r = 0.160784, g = 0.501961, b = 0.72549, a = 1 } get() Returns r , g , b , a components as four separate values. col = Color . Blue r , g , b , a = col : get () print ( r + g + b + a ) --> 2.648 copy() Copy self into a new Color and return it. col1 = Color ( 1 , 0.5 , 0.75 ) col2 = col1 : copy () col1 : set ( 0.75 , 1 , 0.25 ) print ( col1 ) --> Color: { r = 0.75, g = 1, b = 0.25, a = 1 } print ( col2 ) --> Color: { r = 1, g = 0.5, b = 0.75, a = 1 } Methods details Methods not modifying self toHex(...) Returns a hex string representation of self. toHex(includeAlpha) includeAlpha : Include or not the a value. (Default true) print ( Color . blue : toHex ()) -- 1e87ffff print ( Color . blue : toHex ( true )) -- 1e87ffff print ( Color . blue : toHex ( false )) -- 1e87ff toString(...) Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. toString(tolerance) tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): toString ()) -- Blue equals(...) Returns true if otherCol same as self, false otherwise, optional numeric tolerance param. equals(otherCol, tolerance) otherCol : The color to compare with. tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue : copy ())) -- true print ( Color ( 0.118 , 0.53 , 1 ) == Color . Blue ) -- true print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue )) -- Throw errors lerp(...) Return a color some part of the way between self and otherCol , numeric arg [0, 1] is the fraction. lerp(otherCol, fraction) otherCol : The color to compare with. fraction : Numeric fraction . local pink = Color . Red : lerp ( Color . White , 0.5 ) print ( pink ) -- Color: { r = 0.928, g = 0.55, b = 0.547, a = 1 } dump(...) Return string describing self, optional string prefix. dump(prefix) prefix : The prefix of return string. Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function. col = Color . Blue str = col : dump ( 'Prefix' ) print ( str ) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( col : dump ( 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2 print ( Color . dump ( col , 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2 Other methods Color.list Returns a table of all color strings. data = Color . list -- Same as data = { [ 1 ] => \"White\" , [ 2 ] => \"Brown\" , [ 3 ] => \"Red\" , [ 4 ] => \"Orange\" , [ 5 ] => \"Yellow\" , [ 6 ] => \"Green\" , [ 7 ] => \"Teal\" , [ 8 ] => \"Blue\" , [ 9 ] => \"Purple\" , [ 10 ] => \"Pink\" , [ 11 ] => \"Grey\" , [ 12 ] => \"Black\" } Color.Add(...) Add your own color definition to the class. dump(name, yourColor) name : The name of the color. yourColor : The color value. Color . Add ( \"River\" , Color ( 52 / 255 , 152 / 255 , 219 / 255 )) local color , name = Color . River print ( color ) -- Color: River { r = 0.203922, g = 0.596078, b = 0.858824, a = 1 } print ( name ) -- River Manipulation examples Tint all object in scene in orange. function onLoad () local red = Color . Red local green = Color . Green -- Get a color between red and green local yellow = red : lerp ( green , 0.5 ) -- Make the color brighter yellow : set ( yellow . r * 1.5 , yellow . g * 1.5 , yellow . b * 1.5 ) -- Get a color between yellow and red local orange = yellow : lerp ( Color . Red , 0.5 ) -- Iterate through all scene objects and set the color tint to orange for k , obj in pairs ( getObjects ()) do obj . setColorTint ( orange ) end end Tint all object in a random color. function onLoad () -- Iterate through all scene objects and generate a random color for k , obj in pairs ( getObjects ()) do local colorA = getRandomColor () local colorB = getRandomColor () color = colorA : lerp ( colorB , math.random ( 0 , 1 )) -- Make the color darker or brighter local factor = math.random ( 1 , 2 ) color : set ( color . r * factor , color . g * factor , color . b * factor ) -- Apply the color to object obj . setColorTint ( color ) end end function getRandomColor () local r = math.random ( 0 , 255 ) local g = math.random ( 0 , 255 ) local b = math.random ( 0 , 255 ) return Color ( r / 255 , g / 255 , b / 255 ) end","title":"Color"},{"location":"color/#constructors-summary","text":"Tip Every place that returns a coordinate table, like obj . getColorTint () , serves a Color class instance already - you do not have to explicitly construct it. When constructing Color instances, the .new part can be omitted, making e.g. Color ( 1 , 0.5 , 0.75 ) equivalent to Color . new ( 1 , 0.5 , 0.75 ) . Function Name Description Return Color( r, g, b) Return a color with specified (r, g, b) components. Color( r, g, b, a) Return a color with specified (r, g, b, a) components. Color( t) Return a color with r/g/b/a components from source table . Color.new(...) Same as Color(...). Color.fromString( colorStr) Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.Blue Shorthand for Color.fromString('Blue'), works for all Player and added colors , capitalization ignored. Also return the color name.","title":"Constructors summary"},{"location":"color/#constructors-examples","text":"function onLoad () local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local orangePlayer = Color . fromString ( \"Orange\" ) local purplePlayer = Color . Purple end","title":"Constructors examples"},{"location":"color/#element-access-summary","text":"In addition to accessing color components by their numeric indices (1, 2, 3, 4) and textual identifiers (r, g, b, a), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( r, g, b, a) Sets r , g , b , a components to given values and returns self, alpha is optional get() Returns r , g , b , a components as four separate values. copy() Returns a separate Color with identical component values. Tip Before Color was introduced, color tables contained separate values under 1, 2, 3, 4 and r, g, b, a keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Color components you have to use pairs and only letter keys will be read there.","title":"Element access summary"},{"location":"color/#element-access-examples","text":"function onLoad () local col = Color ( 0 , 0.5 , 0.75 ) col . r = 1 -- set the first component col [ 2 ] = 0.25 -- set the second component col : setAt ( 'b' , 1 ) -- set the third component print ( col : get ()) --> same as print(col.r, col.g, col.b, col.a) for colorCode , value in pairs ( col ) do print ( colorCode .. \"=\" .. value ) --> r=1 then g=0.25 then b=1 and finally a=1 end col : copy (): setAt ( 'a' , 0.5 ) print ( col . a ) --> 1, because we only changed 'a' on a copy end","title":"Element access examples"},{"location":"color/#arithmetics-summary","text":"Color also allows you to use arithmetic operators to performs basic operations: Operator Description Return one == two Return true if both colors identical or within a small margin of each other, false otherwise. See also color:equals() . tostring( col) Return a string description of a color.","title":"Arithmetics summary"},{"location":"color/#arithmetics-examples","text":"function onLoad () local col = Color ({ r = 0.118 , g = 0.53 , b = 1 }) print ( col == Color . blue ) --> true -- Color : Blue { r = 0.118, g = 0.53, b = 1, a = 1} tostring ( Color ( 0.118 , 0.53 , 1 )) --> Color : { r = 0.3, g = 0.5, b = 1, a = 1} tostring ( Color ({ r = 0.3 , g = 0.5 , b = 1 })) end","title":"Arithmetics examples"},{"location":"color/#methods-summary","text":"","title":"Methods summary"},{"location":"color/#methods-not-modifying-self","text":"Method Name Description Return col:toHex( includeAlpha) Returns a hex string for col , boolean parameter includeAlpha . col:toString( tolerance) Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. col:equals( otherCol, num) Returns true if otherCol same as col , false otherwise, optional numeric tolerance param. col:lerp( otherCol, num) Return a color some part of the way between col and otherCol , numeric arg [0, 1] is the fraction. col:dump( prefix) Return a string description of a color with an optional prefix .","title":"Methods not modifying self"},{"location":"color/#other-methods","text":"Method Name Description Return Color.list Returns a table of all color strings. Color.Add( name, yourColor) Add your own color definition to the class.","title":"Other methods"},{"location":"color/#constructors-details","text":"","title":"Constructors details"},{"location":"color/#colornew","text":"Return a color with specified components. Color.new(r, g, b) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. Color.new(r, g, b, a) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. a : Alpha component between 0 and 1. Color.new(t) t : The table should use the r , g , b and a index. By default the value is 0 for color and 1 for alpha. local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local river = Color ( 52 / 255 , 152 / 255 , 219 / 255 , 160 / 255 ) local teal = Color ({ r = 0.129 , g = 0.694 , b = 0.607 }) Info If you want to use value between 0 and 255 you should divide them by 255 before construct the object.","title":"Color.new(...)"},{"location":"color/#colorfromstring","text":"Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.fromString(colorStr) colorStr : Any Player Color or color added with Color.Add . local col = Color . fromString ( \"Blue\" ) print ( col ) --> Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 }","title":"Color.fromString(...)"},{"location":"color/#colorblue","text":"Return a color from a color string ('Red', 'Green' etc). Any Player Color or color added with Color.Add . local color , name = Color . Blue print ( color ) -- Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( name ) -- Blue local color , name = Color . Red print ( color ) -- Color: Red { r = 0.856, g = 0.1, b = 0.094, a = 1 } print ( name ) -- Red","title":"Color.Blue"},{"location":"color/#element-access-details","text":"","title":"Element access details"},{"location":"color/#setat","text":"Update one component of the color and returning self. setAt(key, num) key : Index of component (1, 2, 3 or 4 for r, g, b or a). num : New value. col = Color . Blue col : setAt ( 1 , 128 / 255 ): setAt ( 'a' , 0.5 ) print ( col ) --> Color: { r = 0.501961, g = 0.53, b = 1, a = 0.5 }","title":"setAt(...)"},{"location":"color/#set","text":"Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(r, g, b) r : New value of Red component. g : New value of Green component. b : New value of Blue component. set(r, g, b, a) r : New value of Red component. g : New value of Green component. b : New value of Blue component. a : New value of Alpha component. col = Color . black col : set ( 41 / 255 , 128 / 255 , 185 / 255 ) print ( col ) --> Color: { r = 0.160784, g = 0.501961, b = 0.72549, a = 1 }","title":"set(...)"},{"location":"color/#get","text":"Returns r , g , b , a components as four separate values. col = Color . Blue r , g , b , a = col : get () print ( r + g + b + a ) --> 2.648","title":"get()"},{"location":"color/#copy","text":"Copy self into a new Color and return it. col1 = Color ( 1 , 0.5 , 0.75 ) col2 = col1 : copy () col1 : set ( 0.75 , 1 , 0.25 ) print ( col1 ) --> Color: { r = 0.75, g = 1, b = 0.25, a = 1 } print ( col2 ) --> Color: { r = 1, g = 0.5, b = 0.75, a = 1 }","title":"copy()"},{"location":"color/#methods-details","text":"","title":"Methods details"},{"location":"color/#methods-not-modifying-self_1","text":"","title":"Methods not modifying self"},{"location":"color/#tohex","text":"Returns a hex string representation of self. toHex(includeAlpha) includeAlpha : Include or not the a value. (Default true) print ( Color . blue : toHex ()) -- 1e87ffff print ( Color . blue : toHex ( true )) -- 1e87ffff print ( Color . blue : toHex ( false )) -- 1e87ff","title":"toHex(...)"},{"location":"color/#tostring","text":"Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. toString(tolerance) tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): toString ()) -- Blue","title":"toString(...)"},{"location":"color/#equals","text":"Returns true if otherCol same as self, false otherwise, optional numeric tolerance param. equals(otherCol, tolerance) otherCol : The color to compare with. tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue : copy ())) -- true print ( Color ( 0.118 , 0.53 , 1 ) == Color . Blue ) -- true print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue )) -- Throw errors","title":"equals(...)"},{"location":"color/#lerp","text":"Return a color some part of the way between self and otherCol , numeric arg [0, 1] is the fraction. lerp(otherCol, fraction) otherCol : The color to compare with. fraction : Numeric fraction . local pink = Color . Red : lerp ( Color . White , 0.5 ) print ( pink ) -- Color: { r = 0.928, g = 0.55, b = 0.547, a = 1 }","title":"lerp(...)"},{"location":"color/#dump","text":"Return string describing self, optional string prefix. dump(prefix) prefix : The prefix of return string. Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function. col = Color . Blue str = col : dump ( 'Prefix' ) print ( str ) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( col : dump ( 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2 print ( Color . dump ( col , 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2","title":"dump(...)"},{"location":"color/#other-methods_1","text":"","title":"Other methods"},{"location":"color/#colorlist","text":"Returns a table of all color strings. data = Color . list -- Same as data = { [ 1 ] => \"White\" , [ 2 ] => \"Brown\" , [ 3 ] => \"Red\" , [ 4 ] => \"Orange\" , [ 5 ] => \"Yellow\" , [ 6 ] => \"Green\" , [ 7 ] => \"Teal\" , [ 8 ] => \"Blue\" , [ 9 ] => \"Purple\" , [ 10 ] => \"Pink\" , [ 11 ] => \"Grey\" , [ 12 ] => \"Black\" }","title":"Color.list"},{"location":"color/#coloradd","text":"Add your own color definition to the class. dump(name, yourColor) name : The name of the color. yourColor : The color value. Color . Add ( \"River\" , Color ( 52 / 255 , 152 / 255 , 219 / 255 )) local color , name = Color . River print ( color ) -- Color: River { r = 0.203922, g = 0.596078, b = 0.858824, a = 1 } print ( name ) -- River","title":"Color.Add(...)"},{"location":"color/#manipulation-examples","text":"Tint all object in scene in orange. function onLoad () local red = Color . Red local green = Color . Green -- Get a color between red and green local yellow = red : lerp ( green , 0.5 ) -- Make the color brighter yellow : set ( yellow . r * 1.5 , yellow . g * 1.5 , yellow . b * 1.5 ) -- Get a color between yellow and red local orange = yellow : lerp ( Color . Red , 0.5 ) -- Iterate through all scene objects and set the color tint to orange for k , obj in pairs ( getObjects ()) do obj . setColorTint ( orange ) end end Tint all object in a random color. function onLoad () -- Iterate through all scene objects and generate a random color for k , obj in pairs ( getObjects ()) do local colorA = getRandomColor () local colorB = getRandomColor () color = colorA : lerp ( colorB , math.random ( 0 , 1 )) -- Make the color darker or brighter local factor = math.random ( 1 , 2 ) color : set ( color . r * factor , color . g * factor , color . b * factor ) -- Apply the color to object obj . setColorTint ( color ) end end function getRandomColor () local r = math.random ( 0 , 255 ) local g = math.random ( 0 , 255 ) local b = math.random ( 0 , 255 ) return Color ( r / 255 , g / 255 , b / 255 ) end","title":"Manipulation examples"},{"location":"component/","text":"Component is a unique collection of functions and member variables. They interact directly with the Unity properties of the objects that Tabletop Simulator is composed of. This means that a level of understanding of how Unity works is required to utilize these commands. Warning In other words, this is a highly advanced feature and this API is only able to teach you the basic commands to utilize it. General Concepts Every object in a \"room\" of Tabletop Simulator is a GameObject . Some sort of entity which exists within the scene. When a room is created, the GameObjects are loaded and initiated into the Lua script system. This is why, if you spawn a block and then run print(self) on it, it will print BlockSquare(Clone) (LuaGameObjectScript) into the chat. BlockSquare(Clone) is the GameObject, while (LuaGameObjectScript) is the Lua scripting system. GameObjects themselves contain many variables called Components . These can be the Collider, Transform, Mesh, etc that compose a GameObject, telling Unity how to render it. The component functions allow you to directly access the GameObjects and Components that make up any object in Tabletop Simulator, including your own AssetBundles. This means you can attach all manner of components (lights, sounds, and a lot more) and then control them. Finally, each Component has Vars , variables which you can modify to change how that Component effects the GameObject. The best way to explain this more clearly is with a few examples. General Examples The specific functions will be covered further down this page. These examples are scripts placed on a regular red block. Disable Receiving Shadows function onLoad () -- Get the MeshRenderer of the block's GameObject local blockComp = self . getComponent ( \"MeshRenderer\" ) -- Disable its ability to have a shadow cast onto it by another Object blockComp . set ( \"receiveShadows\" , false ) end Modify Object's Collider function onLoad () -- Get the BoxCollider Component of the block's GameObject local blockComp = self . getComponent ( \"BoxCollider\" ) -- Now lets make its collider disappear blockComp . set ( \"enabled\" , false ) -- Watch the block fall through the world and vanish -- The system deletes it once it falls too far end Completly Silence an Object function onLoad () -- Get the AudioSource Component of the block's GameObject local blockComp = self . getComponent ( \"AudioSource\" ) -- Mute it blockComp . set ( \"mute\" , true ) -- Now it makes no sound when impacting anything. end And these examples are only scraping the surface of what these functions can do. It essentially gives you near-full access to anything an object in Unity is capable of. Commands Object and GameObject Commands These can be used on either a regular in-game Object or an in-game Objects GameObject . Command Name Description Return getComponent( name) Obtains a component reference from an Object, by name. Component getComponents( optional_name) Returns all components on a game object. The name is an optional component name to narrow results with. Component in name Returns the name of the given Object or GameObject. GameObject Children Commands When you access an in-game Object normally with Lua, it is always the \"parent\" object. Other objects can be \"attached\" to that parent object as a child object. You are able to access those children with these commands. Command Name Description Return getComponentInChildren( name) Obtains a component reference from a child GameObject, by name. Component getComponentsInChildren( optional_name) Returns all components of all child GameObjects attached to this parent Object. The name is an optional component name to narrow results with. Component in getChild( name) Obtains a reference to the GameObject of a child object. The name is the name of the GameObject. GameObject getChildren() Returns a list of all GameObjects attached under the parent GameObject. GameObject in Component Commands These commands are used on the Components of objects to find or modify the values of their variables. The values will depend on which variable is being changed. They are usually System.Int32 (an Integer), System.Boolean (a Bool) or UnityEngine.Vector3 (a Vector). These are all used on Components. Command Name Description Return game_object Returns the GameObject the component is on. GameObject get( varName) Obtains the value of a given Variable on a Component. getVars() Obtains a table containing Variable names along with the type of value they take. set( varName, value) Sets a value to a Variable on the Component name Returns the name of the given Object or GameObject.","title":"Component"},{"location":"component/#general-concepts","text":"Every object in a \"room\" of Tabletop Simulator is a GameObject . Some sort of entity which exists within the scene. When a room is created, the GameObjects are loaded and initiated into the Lua script system. This is why, if you spawn a block and then run print(self) on it, it will print BlockSquare(Clone) (LuaGameObjectScript) into the chat. BlockSquare(Clone) is the GameObject, while (LuaGameObjectScript) is the Lua scripting system. GameObjects themselves contain many variables called Components . These can be the Collider, Transform, Mesh, etc that compose a GameObject, telling Unity how to render it. The component functions allow you to directly access the GameObjects and Components that make up any object in Tabletop Simulator, including your own AssetBundles. This means you can attach all manner of components (lights, sounds, and a lot more) and then control them. Finally, each Component has Vars , variables which you can modify to change how that Component effects the GameObject. The best way to explain this more clearly is with a few examples.","title":"General Concepts"},{"location":"component/#general-examples","text":"The specific functions will be covered further down this page. These examples are scripts placed on a regular red block.","title":"General Examples"},{"location":"component/#disable-receiving-shadows","text":"function onLoad () -- Get the MeshRenderer of the block's GameObject local blockComp = self . getComponent ( \"MeshRenderer\" ) -- Disable its ability to have a shadow cast onto it by another Object blockComp . set ( \"receiveShadows\" , false ) end","title":"Disable Receiving Shadows"},{"location":"component/#modify-objects-collider","text":"function onLoad () -- Get the BoxCollider Component of the block's GameObject local blockComp = self . getComponent ( \"BoxCollider\" ) -- Now lets make its collider disappear blockComp . set ( \"enabled\" , false ) -- Watch the block fall through the world and vanish -- The system deletes it once it falls too far end","title":"Modify Object's Collider"},{"location":"component/#completly-silence-an-object","text":"function onLoad () -- Get the AudioSource Component of the block's GameObject local blockComp = self . getComponent ( \"AudioSource\" ) -- Mute it blockComp . set ( \"mute\" , true ) -- Now it makes no sound when impacting anything. end And these examples are only scraping the surface of what these functions can do. It essentially gives you near-full access to anything an object in Unity is capable of.","title":"Completly Silence an Object"},{"location":"component/#commands","text":"","title":"Commands"},{"location":"component/#object-and-gameobject-commands","text":"These can be used on either a regular in-game Object or an in-game Objects GameObject . Command Name Description Return getComponent( name) Obtains a component reference from an Object, by name. Component getComponents( optional_name) Returns all components on a game object. The name is an optional component name to narrow results with. Component in name Returns the name of the given Object or GameObject.","title":"Object and GameObject Commands"},{"location":"component/#gameobject-children-commands","text":"When you access an in-game Object normally with Lua, it is always the \"parent\" object. Other objects can be \"attached\" to that parent object as a child object. You are able to access those children with these commands. Command Name Description Return getComponentInChildren( name) Obtains a component reference from a child GameObject, by name. Component getComponentsInChildren( optional_name) Returns all components of all child GameObjects attached to this parent Object. The name is an optional component name to narrow results with. Component in getChild( name) Obtains a reference to the GameObject of a child object. The name is the name of the GameObject. GameObject getChildren() Returns a list of all GameObjects attached under the parent GameObject. GameObject in","title":"GameObject Children Commands"},{"location":"component/#component-commands","text":"These commands are used on the Components of objects to find or modify the values of their variables. The values will depend on which variable is being changed. They are usually System.Int32 (an Integer), System.Boolean (a Bool) or UnityEngine.Vector3 (a Vector). These are all used on Components. Command Name Description Return game_object Returns the GameObject the component is on. GameObject get( varName) Obtains the value of a given Variable on a Component. getVars() Obtains a table containing Variable names along with the type of value they take. set( varName, value) Sets a value to a Variable on the Component name Returns the name of the given Object or GameObject.","title":"Component Commands"},{"location":"counter/","text":"The Counter is an in-game Object of a digital counter. It has its own class, Counter, with functions/members associated with it. This allows you to manipulate the special properties of a Counter. You call these functions like this: self.Counter.increment() . Function Summary Object Functions Function Name Description Return clear() Resets Counter to 0. decrement() Reduces Counter's value by 1. getValue() Returns Int of the current value displayed by the Counter. This function acts the same as Object's getValue() . increment() Increases Counter's value by 1. setValue() Sets the current value of the Counter. This function acts the same as Object's setValue() .","title":"Counter"},{"location":"counter/#function-summary","text":"","title":"Function Summary"},{"location":"counter/#object-functions","text":"Function Name Description Return clear() Resets Counter to 0. decrement() Reduces Counter's value by 1. getValue() Returns Int of the current value displayed by the Counter. This function acts the same as Object's getValue() . increment() Increases Counter's value by 1. setValue() Sets the current value of the Counter. This function acts the same as Object's setValue() .","title":"Object Functions"},{"location":"custom-game-objects/","text":"You can spawn custom Objects and then provide the custom content for them after spawning them by calling setCustomObject() . See setCustomObject for usage You can also use setCustomObject along with reload() to modify an existing custom Object. Custom AssetBundle Custom_Assetbundle Custom Parameters parameters : A Table of parameters which determine the properties of the Object. assetbundle : The path/url for the AssetBundle. assetbundle_secondary : The path/url for the secondary AssetBundle property. Optional, is not used by default. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard Custom Board Custom_Board Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the board. Custom Deck DeckCustom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. face : The path/url of the face cardsheet. back : The path/url of the back cardsheet or card back. unique_back : If each card has a unique card back (via a cardsheet). Optional, defaults to false. width : The number of columns on the cardsheet. Optional, defaults to 10. height : The number of rows on the cardsheet. Optional, defaults to 7. number : The number of cards on the cardsheet. Optional, defaults to 52. sideways : If the cards are horizontal instead of vertical. Optional, defaults to false. back_is_hidden : If cards have a special face that shows up when hidden in a hand zone. Optional, defaults to false. Custom Dice Custom_Dice Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom die . type : The type of die, which determines its number of sides. Optional, defaults to 1. 0 : 4-sided 1 : 6-sided 2 : 8-sided 3 : 10-sided 4 : 12-sided 5 : 20-sided Custom Figurine Figurine_Custom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom figurine . image_secondary : The path/url for the custom figurine's back. Optional, defaults to \"image\". Custom Model Custom_Model Custom Parameters parameters : A Table of parameters which determine the properties of the Object. mesh : The path/url for the .obj mesh used on the custom model . diffuse : The path/url for the diffuse image. normal : The path/url for the normals image. Optional, is not used by default. collider : The path/url for the collider mesh. Optional, defaults to a generic box collider. convex : If the object model is convex. Optional, defaults to false. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard specular_intensity : The specular intensity. Optional, defaults to 0.1. specular_color : The specular Color . Optional, defaults to {r=1, g=1, b=1}. specular_sharpness : The specular sharpness. Optional, defaults to 3. freshnel_strength : The freshnel strength. Optional, defaults to 0.1. cast_shadows : If the Object casts shadows. Optional, defaults to true. Custom Tile Custom_Tile Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom tile image. type : Determines the shape of the tile. Optional, defaults to 0. 0 : Square/Rectangle 1 : Hex 2 : Circle image_bottom : The path/url for the bottom-side image. Optional, uses the top image by default. thickness : How thick the tile is. Optional, defaults to 0.5. stackable : If these tiles stack together into a pile. Optional, defaults to false. Custom Token Custom_Token Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom token image. thickness : How thick the tile is. Optional, defaults to 0.2. mege_distance : How accurate the edges are to the image. Optional, defaults to 15. stackable : If these tiles stack together into a pile. Optional, defaults to false.","title":"Custom"},{"location":"custom-game-objects/#custom-assetbundle","text":"Custom_Assetbundle Custom Parameters parameters : A Table of parameters which determine the properties of the Object. assetbundle : The path/url for the AssetBundle. assetbundle_secondary : The path/url for the secondary AssetBundle property. Optional, is not used by default. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard","title":"Custom AssetBundle"},{"location":"custom-game-objects/#custom-board","text":"Custom_Board Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the board.","title":"Custom Board"},{"location":"custom-game-objects/#custom-deck","text":"DeckCustom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. face : The path/url of the face cardsheet. back : The path/url of the back cardsheet or card back. unique_back : If each card has a unique card back (via a cardsheet). Optional, defaults to false. width : The number of columns on the cardsheet. Optional, defaults to 10. height : The number of rows on the cardsheet. Optional, defaults to 7. number : The number of cards on the cardsheet. Optional, defaults to 52. sideways : If the cards are horizontal instead of vertical. Optional, defaults to false. back_is_hidden : If cards have a special face that shows up when hidden in a hand zone. Optional, defaults to false.","title":"Custom Deck"},{"location":"custom-game-objects/#custom-dice","text":"Custom_Dice Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom die . type : The type of die, which determines its number of sides. Optional, defaults to 1. 0 : 4-sided 1 : 6-sided 2 : 8-sided 3 : 10-sided 4 : 12-sided 5 : 20-sided","title":"Custom Dice"},{"location":"custom-game-objects/#custom-figurine","text":"Figurine_Custom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom figurine . image_secondary : The path/url for the custom figurine's back. Optional, defaults to \"image\".","title":"Custom Figurine"},{"location":"custom-game-objects/#custom-model","text":"Custom_Model Custom Parameters parameters : A Table of parameters which determine the properties of the Object. mesh : The path/url for the .obj mesh used on the custom model . diffuse : The path/url for the diffuse image. normal : The path/url for the normals image. Optional, is not used by default. collider : The path/url for the collider mesh. Optional, defaults to a generic box collider. convex : If the object model is convex. Optional, defaults to false. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard specular_intensity : The specular intensity. Optional, defaults to 0.1. specular_color : The specular Color . Optional, defaults to {r=1, g=1, b=1}. specular_sharpness : The specular sharpness. Optional, defaults to 3. freshnel_strength : The freshnel strength. Optional, defaults to 0.1. cast_shadows : If the Object casts shadows. Optional, defaults to true.","title":"Custom Model"},{"location":"custom-game-objects/#custom-tile","text":"Custom_Tile Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom tile image. type : Determines the shape of the tile. Optional, defaults to 0. 0 : Square/Rectangle 1 : Hex 2 : Circle image_bottom : The path/url for the bottom-side image. Optional, uses the top image by default. thickness : How thick the tile is. Optional, defaults to 0.5. stackable : If these tiles stack together into a pile. Optional, defaults to false.","title":"Custom Tile"},{"location":"custom-game-objects/#custom-token","text":"Custom_Token Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom token image. thickness : How thick the tile is. Optional, defaults to 0.2. mege_distance : How accurate the edges are to the image. Optional, defaults to 15. stackable : If these tiles stack together into a pile. Optional, defaults to false.","title":"Custom Token"},{"location":"event/","text":"Events are functions which are activated by Tabletop Simulator when something takes place in-game. It is possible to use all of them within scripts on Objects, and most will also work in Global scripts. Many contain parameters which can be used to utilize additional information related to the event. Function Summary Default Events (Global & Object) These are functions which are triggered by an event taking place in-game. They work when within the script of an Object or the Global script. Function Name Description filterObjectEnterContainer( container, enter_object) Called when an object attempts to enter any container. The object is prevented from entering unless true is returned. onChat( message, sender) Called when a chat message is sent in game chat. onExternalMessage( data) Called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onFixedUpdate() Called every physics tick (90 times a second). This is a frame independent onUpdate(). onLoad( save_state) Called when a game save is finished loading every Object. It is where most setup code will go. onObjectCollisionEnter( registered_object, collision_info) Called when an Object starts colliding with a collision registered Object. onObjectCollisionExit( registered_object, collision_info) Called when an Object stops colliding with a collision registered Object. onObjectCollisionStay( registered_object, collision_info) Called every frame that an Object is colliding with a collision registered Object. onObjectDestroy( dying_object) Called whenever any object is destroyed. onObjectDrop( player_color, dropped_object) Called whenever any object is dropped by a player. onObjectEnterScriptingZone( zone, enter_object) Called when any object enters any scripting zone. onObjectEnterContainer( container, enter_object) Called when any object enters any container. Includes decks onObjectFlick( object, player_color, impulse) Called when a player flicks an object. onObjectHover( player_color, hovered_object) Called when a player moves their pointer (cursor) over an object. onObjectLeaveScriptingZone( zone, enter_object) Called when any object leaves any scripting zone. onObjectLeaveContainer( container, leave_object) Called when any object leaves any container. onObjectLoopingEffect( loop_object, index) Called whenever the looping effect of an AssetBundle is activated. onObjectNumberTyped( object, player_color, number) Called when a player types a number whilst hovering over an object. onObjectPageChange( object) Called when a Custom PDF object changes page. onObjectPeek( object, player) Called when a player using peek to look under an Object. onObjectPickUp( player_color, picked_up_object) Called whenever a Player picks up an Object. onObjectRandomize( randomize_object, player_color) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectSearchEnd( obj, player_color) Called when a search is finished on any container. onObjectSearchStart( obj, player_color) Called when a search is started on any container. onObjectSpawn( spawn_object) Called when any Object is spawned/created. onObjectTriggerEffect( trigger_object, index) Called whenever the trigger effect of an AssetBundle is activated. onPlayerChangeColor( player_color) Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerChangeTeam( player_color, team) Called when a player changes team. onPlayerConnect( person) Called when a Player connects to a game. onPlayerDisconnect( person) Called when a Player disconnects from a game. onPlayerTurn( person) Called at the start of a player's turn when using the in-game turn system. onSave() Called whenever your game is saved. onScriptingButtonDown( index, player_color) Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonUp( index, player_color) Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onUpdate() Called every frame . Default Events (Object Only) These are functions which are triggered by an event taking place in-game. They only work within scripts that are on Objects, never in Global. Function Name Description filterObjectEnter( obj) Called when an object attempts to enter this object. The object is prevented from entering unless true is returned. onCollisionEnter( collision_info) Called when an Object starts colliding with the Object the function is on. onCollisionExit( collision_info) Called when an Object stops colliding with the Object the function is on. onCollisionStay( collision_info) Called every frame that an Object is colliding with the Object this function is on. onDestroy() Called when an Object it is on is destroyed. onDrop( player_color) Called when a player releases an Object after picking it up. onFlick( player_color, impulse) Called when a player flicks the object. onHover( player_color) Called when a player moves their pointer (cursor) over the object. onNumberTyped( player_color, number) Called when a player types a number whilst hovering over the object. onPageChange() Called when a Custom PDF page is changed. onPeek( player_color) Called when a player using peek to look under this Object. onPickUp( player_color) Called when a player picks up an Object. onRandomize( player_color) Called when this Object is randomized. Like when shuffling a deck or shaking dice. onSearchEnd( player_color) Called when a player finishes searches this Object. onSearchStart( player_color) Called when a player starts searching this Object. Function Details (Global & Object) filterObjectEnterContainer(...) Called when an object attempts to enter a container. The object is prevented from entering unless true is returned. filterObjectEnter(container, enter_object) container : The container the Object is trying to enter. enter_object : The Object entering the container. function filterObjectEnterContainer ( container , enter_object ) print ( enter_object . getName ()) -- Print entering object's name return true -- Allows object to enter. end onChat(...) This function is called when a message is sent through the in-game chat. It does not trigger when global chat messages are sent. Using return false inside of this function prevents the chat message which triggered it to be suppressed. onChat(message, sender) message : Chat message which triggered the function. sender : Player which sent the chat message. function onChat ( message , player ) print ( message ) print ( player . color ) end onExternalMessage(...) This function is called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onExternalMessage(data) data : The data returned by the external editor into the game. function onExternalMessage ( data ) print ( \"External message received\" ) end onFixedUpdate() Called every physics tick (90 times a second). This is a frame independent onUpdate(). Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onFixedUpdate () self . addTorque ({ 0 , 100 , 0 }, 1 ) end onLoad(...) This function is called when a game save is finished loading every Object. This is where most setup code will go. The fast-forward and rewind feature will also cause this function to activate. If this function is in an Object's script and that Object is spawned, like by removing it from a container, it too will trigger onLoad(). onLoad(save_state) save_state : The encoded string containing any save_state (saved) data. If there is no data saved, this returns an empty String. function onLoad () print ( \"Loading complete\" ) end Example of onLoad and onSave being used to save/load data -- Runs whenever game is saved/autosaved function onSave () local data_to_save = { someData = 50 } saved_data = JSON . encode ( data_to_save ) --saved_data = \"\" --Remove -- at start & save to clear save data return saved_data end -- Runs when game is loaded function onLoad ( saved_data ) -- Loads the tracking for if the game has started yet if saved_data ~= \"\" then local loaded_data = JSON . decode ( saved_data ) someData = loaded_data . someData else someData = 50 end end onObjectCollisionEnter(...) This function is called when an Object starts colliding with a collision registered Object. onObjectCollisionEnter(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionEnter ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( registered_object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onObjectCollisionExit(...) This function is called when an Object stops colliding with a collision registered Object. onObjectCollisionExit(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onObjectCollisionExit ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( registered_object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onObjectCollisionStay(...) This function is called every frame that an Object is colliding with a collision registered Object. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onObjectCollisionStay(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionStay ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( registered_object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onObjectDestroy(...) Called whenever any object is destroyed. The dying Object has 1 frame left to live. This event fires immediately before the dying Object\u2019s onDestroy() but their lifetime is the same final frame. onObjectDestroy(dying_object) dying_object : The object that was destroyed. function onObjectDestroy ( destroyedObj ) print ( destroyedObj . getName ()) end onObjectDrop(...) Called whenever any object is dropped by a player. onObjectDrop(player_color, dropped_object) player_color : Player Color of the Player who dropped the Object. dropped_object : The Object in game which was dropped. function onObjectDrop ( colorName , obj ) print ( colorName .. \" dropped \" .. obj . getName ()) end onObjectEnterScriptingZone(...) Called when any object enters any scripting zone. onObjectEnterScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectEnterScriptingZone ( zone , obj ) print ( obj . getGUID ()) end onObjectEnterContainer(...) Called when any object enters any container. Includes Objects entering decks. onObjectEnterContainer(container, enter_object) container : Container the Object entered. enter_object : Object that entered the container. function onObjectEnterContainer ( bag , obj ) print ( bag ) print ( obj ) end onObjectFlick(...) Called whenever a player flicks flicks an object. onFlick(object, player_color, impulse) object : The object that was flicked. player_color : Player Color of the player who flicked an object. impulse : The impulse applied to the object. Example Print the player color, type of the flicked object, and magnitude of the flick: function onObjectFlick ( object , player_color , impulse ) print ( player_color .. \" flicked a \" .. object . type .. \" with impulse \" .. impulse : magnitude ()) end onObjectHover(...) Called when a player moves their pointer (cursor) over an object. onObjectHover(player_color, hovered_object) player_color : Player Color of the player who moved the pointer over an object. hovered_object : Object on which the pointer was moved. Important hovered_object can be nil in some cases. For example if you move the pointer from the object to the table. function onObjectHover ( player_color , hovered_object ) if ( hovered_object ~= nil ) then print ( player_color ) print ( hovered_object ) end end onObjectLeaveScriptingZone(...) Called when any object leaves any scripting zone. onObjectLeaveScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectLeaveScriptingZone ( zone , obj ) print ( obj . getGUID ()) end onObjectLeaveContainer(...) Called when any object leaves any container. onObjectLeaveContainer(container, leave_object) container : Container the object left. leave_object : Object that left the container. function onObjectLeaveContainer ( bag , obj ) print ( bag ) print ( obj ) end onObjectLoopingEffect(...) Called whenever the looping effect of an AssetBundle is activated. onObjectLoopingEffect(loop_object, index) loop_object : AssetBundle which had its loop activated. index : Index number for the loop activated. function onObjectLoopingEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end onObjectNumberTyped(...) Called when a player types a number whilst hovering over an object. If you wish to prevent the default behavior (e.g. drawing a card) then you may return true to indicate you've handled the event yourself. onObjectNumberTyped(object, player_color, number) object : The object the player was hovering over whilst typing a number. player_color : Player Color of the player that typed the number. number : The number typed. Example Print the player color, the number they entered and the type of object being hovered over: function onObjectNumberTyped ( object , player_color , number ) print ( player_color .. \" typed \" .. number .. \" whilst hovering over a \" .. object . type ) end Example Prevent players drawing more than 2 cards at a time: function onObjectNumberTyped ( object , player_color , number ) if object . type == 'Deck' and number > 2 then print ( \"Sorry. You can only draw a maximum of 2 cards.\" ) return true end end onObjectPageChange(...) Called when an object's Custom PDF page is changed. onObjectPageChange(object) object : The object that's page changed. Example Print the name of the object and what page it changed to: function onObjectPageChange ( object ) print ( object . getName () .. \" changed page to \" .. object . Book . getPage ()) end onObjectPeek(...) Called when a player using peek to look under an Object. onObjectPeek(object, player) object : A reference to the Object which was peeked at. player : Name of the Player Color that peeked. function onObjectPeek ( object , color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end onObjectPickUp(...) Called whenever a Player picks up an Object. onObjectPickUp(player_color, picked_up_object) player_color : Player Color of the Player who picked up the object. picked_up_object : The Object in game which was picked up. function onObjectPickUp ( colorName , obj ) print ( colorName .. \" picked up \" .. obj . getName ()) end onObjectRandomize(...) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectRandomize(randomize_object, player_color) spawn_object : The Object which triggered this function. player_color : Player Color of the player who triggered the function. function onObjectRandomize ( obj , color ) print ( obj . getName () .. \" was randomized by \" .. color ) end onObjectSearchEnd(...) Called when a search is finished on any container. onObjectSearchEnd(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function. onObjectSearchStart(...) Called when a search is started on any container. onObjectSearchStart(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function. onObjectSpawn(...) Called when any Object is spawned/created. onObjectSpawn(spawn_object) spawn_object : The Object which triggered this function. function onObjectSpawn ( obj ) print ( obj ) end onObjectTriggerEffect(...) Called whenever the trigger effect of an AssetBundle is activated. onObjectTriggerEffect(loop_object, index) loop_object : AssetBundle which had its trigger activated. index : Index number for the trigger activated. function onObjectTriggerEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end onPlayerChangeColor(...) Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerChangeColor(player_color) player_color : Player Color of the player who triggered the function. function onPlayerChangeColor ( color ) print ( color ) end onPlayerChangeTeam(...) Called when a player changes team. onPlayerChangeTeam(player_color, team) player_color : Player Color of the player who triggered the function. team : Team to which the player has changed. Options below. \"\" (empty string, if changed to None) Diamonds Hearts Jokers Clubs Spades function onPlayerChangeTeam ( player_color , team ) print ( player_color ) print ( team ) end onPlayerConnect(...) Called when a Player connects to a game. onPlayerConnect(person) person : Player reference to who connected. onPlayerDisconnect(...) Called when a Player disconnects from a game. onPlayerDisconnect(person) person : Player reference to who disconnected. onPlayerTurn(...) Called at the start of a player's turn when using the in-game turn system. onPlayerTurn(person) person : Player who's turn is starting. function onPlayerTurn ( person ) print ( person . color .. \"'s turn starts now.\" ) end onSave() This is called whenever the game saves, either manually or by auto-save. This will work in both a Global script, and an Object script. It is used to allow information to persist through saving/loading, for example, to let your script remember its data previously after hitting the Undo or Redo button. By placing script information into a Lua table, then encoding that data into JSON , you are able to save information about the script's current state onto the script's parent, in the form of a string. You can also return a string value in this function to stash it. Important When using onSave() , information is saved into the save file you are using. Using Save & Apply does NOT cause it to record data, only overwriting your save will update what information onSave() is trying to record. Warning You can save almost any data in a table using this function, but Object references DO NOT persist. If you need to record an Object using onSave() , record its GUID instead. data_table = { answer = 42 } function onSave () saved_data = JSON . encode ( data_table ) return saved_data end Check the onLoad() section for how to load that stored JSON information into your script. onScriptingButtonDown(...) Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonDown(index, player_color) index : Index number, representing which key was pressed. player_color : Player Color of the player who triggered the function. function onScriptingButtonDown ( index , color ) print ( index ) end onScriptingButtonUp(...) Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onScriptingButtonUp(index, player_color) index : Index number, representing which key was released. player_color : Player Color of the player who triggered the function. function onScriptingButtonUp ( index , color ) print ( index ) end onUpdate() Called every frame . Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onUpdate () print ( \"This will probably slow your game down.\" ) end Function Details (Object only) filterObjectEnter(...) Called when an object attempts to enter this object. The object is prevented from entering unless true is returned. filterObjectEnter(obj) obj : The object that has tried to enter the object this script is attached to. function filterObjectEnter ( obj ) print ( obj . getName ()) -- Print entering object's name return true -- Allows object to enter. end onCollisionEnter(...) This function is called when an Object starts colliding with the Object the function is on. Does not work in Global. onCollisionEnter(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionEnter ( info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onCollisionExit(...) This function is called when an Object stops colliding with the Object the function is on. Does not work in Global. onCollisionExit(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onCollisionExit ( info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onCollisionStay(...) This function is called every frame that an Object is colliding with the Object this function is on. Does not work in Global. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onCollisionStay(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionStay ( info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onDestroy() This function is called when an Object it is on is destroyed. When onDestroy() is called, the Object has one frame left to live but its recommended to avoid using it as a reference here. This event fires immediately after onObjectDestroy() but their lifetime is the same final frame. Does not work in Global. function onDestroy () print ( \"This object was destroyed!\" ) end onDrop(...) This function is called when this Object is dropped. Does not work in Global. onDrop(player_color) player_color : Player Color of the Player. function onDrop ( color ) print ( color ) end onFlick(...) Called when a player flicks this Object . onFlick(player_color, impulse) player_color : Player Color of the player who flicked this object. impulse : The impulse applied to the object. Example Print the player color and magnitude of the flick: function onFlick ( player_color , impulse ) print ( player_color .. \" flicked with impulse \" .. impulse : magnitude ()) end onHover(...) Called when a player moves their pointer (cursor) over this Object . onHover(player_color) player_color : Player Color of the player who moved the pointer over an object. function onHover ( player_color ) print ( player_color ) end onNumberTyped(...) Called when a player types a number whilst hovering over this Object . If you wish to prevent the default behavior (e.g. drawing a card, if this object were a deck) then you may return true to indicate you've handled the event yourself. onNumberTyped(player_color, number) player_color : Player Color of the player that typed the number. number : The number typed. Example Print the player color and the number they typed: function onNumberTyped ( player_color , number ) print ( player_color .. \" typed \" .. number ) end Example Prevent players drawing more than 2 cards at a time (from this object): function onNumberTyped ( player_color , number ) if self . type == 'Deck' and number > 2 then print ( \"Sorry. You can only draw a maximum of 2 cards.\" ) return true end end onPageChange() Called when this Object 's Custom PDF page is changed. Example Print this object's name and what page it changed to: function onPageChange () print ( self . getName () .. \" changed page to \" .. self . Book . getPage ()) end onPeek(...) Called when a player using peek to look under an Object. onPeek(player_color) player_color : Name of the Player Color that peeked. function onPeek ( color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end onPickUp(...) Called when a player picks up an Object. onPickUp(player_color) player_color : Player Color of the Player. function onPickUp ( color ) print ( color ) end onRandomize(...) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onRandomize(player_color) player_color : Player Color of the player who triggered the function. function onRandomize ( color ) print ( self . getName () .. \" was randomized by \" .. color ) end onSearchEnd(...) Called when a player first searches this Object. onSearchEnd( player_color) player_color : Player Color of the Player. onSearchStart(...) Called when a player finishes searching this Object. onSearchStart( player_color) player_color : Player Color of the Player.","title":"Event"},{"location":"event/#function-summary","text":"","title":"Function Summary"},{"location":"event/#default-events-global-object","text":"These are functions which are triggered by an event taking place in-game. They work when within the script of an Object or the Global script. Function Name Description filterObjectEnterContainer( container, enter_object) Called when an object attempts to enter any container. The object is prevented from entering unless true is returned. onChat( message, sender) Called when a chat message is sent in game chat. onExternalMessage( data) Called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onFixedUpdate() Called every physics tick (90 times a second). This is a frame independent onUpdate(). onLoad( save_state) Called when a game save is finished loading every Object. It is where most setup code will go. onObjectCollisionEnter( registered_object, collision_info) Called when an Object starts colliding with a collision registered Object. onObjectCollisionExit( registered_object, collision_info) Called when an Object stops colliding with a collision registered Object. onObjectCollisionStay( registered_object, collision_info) Called every frame that an Object is colliding with a collision registered Object. onObjectDestroy( dying_object) Called whenever any object is destroyed. onObjectDrop( player_color, dropped_object) Called whenever any object is dropped by a player. onObjectEnterScriptingZone( zone, enter_object) Called when any object enters any scripting zone. onObjectEnterContainer( container, enter_object) Called when any object enters any container. Includes decks onObjectFlick( object, player_color, impulse) Called when a player flicks an object. onObjectHover( player_color, hovered_object) Called when a player moves their pointer (cursor) over an object. onObjectLeaveScriptingZone( zone, enter_object) Called when any object leaves any scripting zone. onObjectLeaveContainer( container, leave_object) Called when any object leaves any container. onObjectLoopingEffect( loop_object, index) Called whenever the looping effect of an AssetBundle is activated. onObjectNumberTyped( object, player_color, number) Called when a player types a number whilst hovering over an object. onObjectPageChange( object) Called when a Custom PDF object changes page. onObjectPeek( object, player) Called when a player using peek to look under an Object. onObjectPickUp( player_color, picked_up_object) Called whenever a Player picks up an Object. onObjectRandomize( randomize_object, player_color) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectSearchEnd( obj, player_color) Called when a search is finished on any container. onObjectSearchStart( obj, player_color) Called when a search is started on any container. onObjectSpawn( spawn_object) Called when any Object is spawned/created. onObjectTriggerEffect( trigger_object, index) Called whenever the trigger effect of an AssetBundle is activated. onPlayerChangeColor( player_color) Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerChangeTeam( player_color, team) Called when a player changes team. onPlayerConnect( person) Called when a Player connects to a game. onPlayerDisconnect( person) Called when a Player disconnects from a game. onPlayerTurn( person) Called at the start of a player's turn when using the in-game turn system. onSave() Called whenever your game is saved. onScriptingButtonDown( index, player_color) Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonUp( index, player_color) Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onUpdate() Called every frame .","title":"Default Events (Global &amp; Object)"},{"location":"event/#default-events-object-only","text":"These are functions which are triggered by an event taking place in-game. They only work within scripts that are on Objects, never in Global. Function Name Description filterObjectEnter( obj) Called when an object attempts to enter this object. The object is prevented from entering unless true is returned. onCollisionEnter( collision_info) Called when an Object starts colliding with the Object the function is on. onCollisionExit( collision_info) Called when an Object stops colliding with the Object the function is on. onCollisionStay( collision_info) Called every frame that an Object is colliding with the Object this function is on. onDestroy() Called when an Object it is on is destroyed. onDrop( player_color) Called when a player releases an Object after picking it up. onFlick( player_color, impulse) Called when a player flicks the object. onHover( player_color) Called when a player moves their pointer (cursor) over the object. onNumberTyped( player_color, number) Called when a player types a number whilst hovering over the object. onPageChange() Called when a Custom PDF page is changed. onPeek( player_color) Called when a player using peek to look under this Object. onPickUp( player_color) Called when a player picks up an Object. onRandomize( player_color) Called when this Object is randomized. Like when shuffling a deck or shaking dice. onSearchEnd( player_color) Called when a player finishes searches this Object. onSearchStart( player_color) Called when a player starts searching this Object.","title":"Default Events (Object Only)"},{"location":"event/#function-details-global-object","text":"","title":"Function Details (Global &amp; Object)"},{"location":"event/#filterobjectentercontainer","text":"Called when an object attempts to enter a container. The object is prevented from entering unless true is returned. filterObjectEnter(container, enter_object) container : The container the Object is trying to enter. enter_object : The Object entering the container. function filterObjectEnterContainer ( container , enter_object ) print ( enter_object . getName ()) -- Print entering object's name return true -- Allows object to enter. end","title":"filterObjectEnterContainer(...)"},{"location":"event/#onchat","text":"This function is called when a message is sent through the in-game chat. It does not trigger when global chat messages are sent. Using return false inside of this function prevents the chat message which triggered it to be suppressed. onChat(message, sender) message : Chat message which triggered the function. sender : Player which sent the chat message. function onChat ( message , player ) print ( message ) print ( player . color ) end","title":"onChat(...)"},{"location":"event/#onexternalmessage","text":"This function is called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onExternalMessage(data) data : The data returned by the external editor into the game. function onExternalMessage ( data ) print ( \"External message received\" ) end","title":"onExternalMessage(...)"},{"location":"event/#onfixedupdate","text":"Called every physics tick (90 times a second). This is a frame independent onUpdate(). Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onFixedUpdate () self . addTorque ({ 0 , 100 , 0 }, 1 ) end","title":"onFixedUpdate()"},{"location":"event/#onload","text":"This function is called when a game save is finished loading every Object. This is where most setup code will go. The fast-forward and rewind feature will also cause this function to activate. If this function is in an Object's script and that Object is spawned, like by removing it from a container, it too will trigger onLoad(). onLoad(save_state) save_state : The encoded string containing any save_state (saved) data. If there is no data saved, this returns an empty String. function onLoad () print ( \"Loading complete\" ) end Example of onLoad and onSave being used to save/load data -- Runs whenever game is saved/autosaved function onSave () local data_to_save = { someData = 50 } saved_data = JSON . encode ( data_to_save ) --saved_data = \"\" --Remove -- at start & save to clear save data return saved_data end -- Runs when game is loaded function onLoad ( saved_data ) -- Loads the tracking for if the game has started yet if saved_data ~= \"\" then local loaded_data = JSON . decode ( saved_data ) someData = loaded_data . someData else someData = 50 end end","title":"onLoad(...)"},{"location":"event/#onobjectcollisionenter","text":"This function is called when an Object starts colliding with a collision registered Object. onObjectCollisionEnter(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionEnter ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( registered_object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onObjectCollisionEnter(...)"},{"location":"event/#onobjectcollisionexit","text":"This function is called when an Object stops colliding with a collision registered Object. onObjectCollisionExit(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onObjectCollisionExit ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( registered_object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onObjectCollisionExit(...)"},{"location":"event/#onobjectcollisionstay","text":"This function is called every frame that an Object is colliding with a collision registered Object. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onObjectCollisionStay(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionStay ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( registered_object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onObjectCollisionStay(...)"},{"location":"event/#onobjectdestroy","text":"Called whenever any object is destroyed. The dying Object has 1 frame left to live. This event fires immediately before the dying Object\u2019s onDestroy() but their lifetime is the same final frame. onObjectDestroy(dying_object) dying_object : The object that was destroyed. function onObjectDestroy ( destroyedObj ) print ( destroyedObj . getName ()) end","title":"onObjectDestroy(...)"},{"location":"event/#onobjectdrop","text":"Called whenever any object is dropped by a player. onObjectDrop(player_color, dropped_object) player_color : Player Color of the Player who dropped the Object. dropped_object : The Object in game which was dropped. function onObjectDrop ( colorName , obj ) print ( colorName .. \" dropped \" .. obj . getName ()) end","title":"onObjectDrop(...)"},{"location":"event/#onobjectenterscriptingzone","text":"Called when any object enters any scripting zone. onObjectEnterScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectEnterScriptingZone ( zone , obj ) print ( obj . getGUID ()) end","title":"onObjectEnterScriptingZone(...)"},{"location":"event/#onobjectentercontainer","text":"Called when any object enters any container. Includes Objects entering decks. onObjectEnterContainer(container, enter_object) container : Container the Object entered. enter_object : Object that entered the container. function onObjectEnterContainer ( bag , obj ) print ( bag ) print ( obj ) end","title":"onObjectEnterContainer(...)"},{"location":"event/#onobjectflick","text":"Called whenever a player flicks flicks an object. onFlick(object, player_color, impulse) object : The object that was flicked. player_color : Player Color of the player who flicked an object. impulse : The impulse applied to the object. Example Print the player color, type of the flicked object, and magnitude of the flick: function onObjectFlick ( object , player_color , impulse ) print ( player_color .. \" flicked a \" .. object . type .. \" with impulse \" .. impulse : magnitude ()) end","title":"onObjectFlick(...)"},{"location":"event/#onobjecthover","text":"Called when a player moves their pointer (cursor) over an object. onObjectHover(player_color, hovered_object) player_color : Player Color of the player who moved the pointer over an object. hovered_object : Object on which the pointer was moved. Important hovered_object can be nil in some cases. For example if you move the pointer from the object to the table. function onObjectHover ( player_color , hovered_object ) if ( hovered_object ~= nil ) then print ( player_color ) print ( hovered_object ) end end","title":"onObjectHover(...)"},{"location":"event/#onobjectleavescriptingzone","text":"Called when any object leaves any scripting zone. onObjectLeaveScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectLeaveScriptingZone ( zone , obj ) print ( obj . getGUID ()) end","title":"onObjectLeaveScriptingZone(...)"},{"location":"event/#onobjectleavecontainer","text":"Called when any object leaves any container. onObjectLeaveContainer(container, leave_object) container : Container the object left. leave_object : Object that left the container. function onObjectLeaveContainer ( bag , obj ) print ( bag ) print ( obj ) end","title":"onObjectLeaveContainer(...)"},{"location":"event/#onobjectloopingeffect","text":"Called whenever the looping effect of an AssetBundle is activated. onObjectLoopingEffect(loop_object, index) loop_object : AssetBundle which had its loop activated. index : Index number for the loop activated. function onObjectLoopingEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end","title":"onObjectLoopingEffect(...)"},{"location":"event/#onobjectnumbertyped","text":"Called when a player types a number whilst hovering over an object. If you wish to prevent the default behavior (e.g. drawing a card) then you may return true to indicate you've handled the event yourself. onObjectNumberTyped(object, player_color, number) object : The object the player was hovering over whilst typing a number. player_color : Player Color of the player that typed the number. number : The number typed. Example Print the player color, the number they entered and the type of object being hovered over: function onObjectNumberTyped ( object , player_color , number ) print ( player_color .. \" typed \" .. number .. \" whilst hovering over a \" .. object . type ) end Example Prevent players drawing more than 2 cards at a time: function onObjectNumberTyped ( object , player_color , number ) if object . type == 'Deck' and number > 2 then print ( \"Sorry. You can only draw a maximum of 2 cards.\" ) return true end end","title":"onObjectNumberTyped(...)"},{"location":"event/#onobjectpagechange","text":"Called when an object's Custom PDF page is changed. onObjectPageChange(object) object : The object that's page changed. Example Print the name of the object and what page it changed to: function onObjectPageChange ( object ) print ( object . getName () .. \" changed page to \" .. object . Book . getPage ()) end","title":"onObjectPageChange(...)"},{"location":"event/#onobjectpeek","text":"Called when a player using peek to look under an Object. onObjectPeek(object, player) object : A reference to the Object which was peeked at. player : Name of the Player Color that peeked. function onObjectPeek ( object , color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end","title":"onObjectPeek(...)"},{"location":"event/#onobjectpickup","text":"Called whenever a Player picks up an Object. onObjectPickUp(player_color, picked_up_object) player_color : Player Color of the Player who picked up the object. picked_up_object : The Object in game which was picked up. function onObjectPickUp ( colorName , obj ) print ( colorName .. \" picked up \" .. obj . getName ()) end","title":"onObjectPickUp(...)"},{"location":"event/#onobjectrandomize","text":"Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectRandomize(randomize_object, player_color) spawn_object : The Object which triggered this function. player_color : Player Color of the player who triggered the function. function onObjectRandomize ( obj , color ) print ( obj . getName () .. \" was randomized by \" .. color ) end","title":"onObjectRandomize(...)"},{"location":"event/#onobjectsearchend","text":"Called when a search is finished on any container. onObjectSearchEnd(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function.","title":"onObjectSearchEnd(...)"},{"location":"event/#onobjectsearchstart","text":"Called when a search is started on any container. onObjectSearchStart(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function.","title":"onObjectSearchStart(...)"},{"location":"event/#onobjectspawn","text":"Called when any Object is spawned/created. onObjectSpawn(spawn_object) spawn_object : The Object which triggered this function. function onObjectSpawn ( obj ) print ( obj ) end","title":"onObjectSpawn(...)"},{"location":"event/#onobjecttriggereffect","text":"Called whenever the trigger effect of an AssetBundle is activated. onObjectTriggerEffect(loop_object, index) loop_object : AssetBundle which had its trigger activated. index : Index number for the trigger activated. function onObjectTriggerEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end","title":"onObjectTriggerEffect(...)"},{"location":"event/#onplayerchangecolor","text":"Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerChangeColor(player_color) player_color : Player Color of the player who triggered the function. function onPlayerChangeColor ( color ) print ( color ) end","title":"onPlayerChangeColor(...)"},{"location":"event/#onplayerchangeteam","text":"Called when a player changes team. onPlayerChangeTeam(player_color, team) player_color : Player Color of the player who triggered the function. team : Team to which the player has changed. Options below. \"\" (empty string, if changed to None) Diamonds Hearts Jokers Clubs Spades function onPlayerChangeTeam ( player_color , team ) print ( player_color ) print ( team ) end","title":"onPlayerChangeTeam(...)"},{"location":"event/#onplayerconnect","text":"Called when a Player connects to a game. onPlayerConnect(person) person : Player reference to who connected.","title":"onPlayerConnect(...)"},{"location":"event/#onplayerdisconnect","text":"Called when a Player disconnects from a game. onPlayerDisconnect(person) person : Player reference to who disconnected.","title":"onPlayerDisconnect(...)"},{"location":"event/#onplayerturn","text":"Called at the start of a player's turn when using the in-game turn system. onPlayerTurn(person) person : Player who's turn is starting. function onPlayerTurn ( person ) print ( person . color .. \"'s turn starts now.\" ) end","title":"onPlayerTurn(...)"},{"location":"event/#onsave","text":"This is called whenever the game saves, either manually or by auto-save. This will work in both a Global script, and an Object script. It is used to allow information to persist through saving/loading, for example, to let your script remember its data previously after hitting the Undo or Redo button. By placing script information into a Lua table, then encoding that data into JSON , you are able to save information about the script's current state onto the script's parent, in the form of a string. You can also return a string value in this function to stash it. Important When using onSave() , information is saved into the save file you are using. Using Save & Apply does NOT cause it to record data, only overwriting your save will update what information onSave() is trying to record. Warning You can save almost any data in a table using this function, but Object references DO NOT persist. If you need to record an Object using onSave() , record its GUID instead. data_table = { answer = 42 } function onSave () saved_data = JSON . encode ( data_table ) return saved_data end Check the onLoad() section for how to load that stored JSON information into your script.","title":"onSave()"},{"location":"event/#onscriptingbuttondown","text":"Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonDown(index, player_color) index : Index number, representing which key was pressed. player_color : Player Color of the player who triggered the function. function onScriptingButtonDown ( index , color ) print ( index ) end","title":"onScriptingButtonDown(...)"},{"location":"event/#onscriptingbuttonup","text":"Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onScriptingButtonUp(index, player_color) index : Index number, representing which key was released. player_color : Player Color of the player who triggered the function. function onScriptingButtonUp ( index , color ) print ( index ) end","title":"onScriptingButtonUp(...)"},{"location":"event/#onupdate","text":"Called every frame . Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onUpdate () print ( \"This will probably slow your game down.\" ) end","title":"onUpdate()"},{"location":"event/#function-details-object-only","text":"","title":"Function Details (Object only)"},{"location":"event/#filterobjectenter","text":"Called when an object attempts to enter this object. The object is prevented from entering unless true is returned. filterObjectEnter(obj) obj : The object that has tried to enter the object this script is attached to. function filterObjectEnter ( obj ) print ( obj . getName ()) -- Print entering object's name return true -- Allows object to enter. end","title":"filterObjectEnter(...)"},{"location":"event/#oncollisionenter","text":"This function is called when an Object starts colliding with the Object the function is on. Does not work in Global. onCollisionEnter(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionEnter ( info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onCollisionEnter(...)"},{"location":"event/#oncollisionexit","text":"This function is called when an Object stops colliding with the Object the function is on. Does not work in Global. onCollisionExit(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onCollisionExit ( info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onCollisionExit(...)"},{"location":"event/#oncollisionstay","text":"This function is called every frame that an Object is colliding with the Object this function is on. Does not work in Global. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onCollisionStay(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionStay ( info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onCollisionStay(...)"},{"location":"event/#ondestroy","text":"This function is called when an Object it is on is destroyed. When onDestroy() is called, the Object has one frame left to live but its recommended to avoid using it as a reference here. This event fires immediately after onObjectDestroy() but their lifetime is the same final frame. Does not work in Global. function onDestroy () print ( \"This object was destroyed!\" ) end","title":"onDestroy()"},{"location":"event/#ondrop","text":"This function is called when this Object is dropped. Does not work in Global. onDrop(player_color) player_color : Player Color of the Player. function onDrop ( color ) print ( color ) end","title":"onDrop(...)"},{"location":"event/#onflick","text":"Called when a player flicks this Object . onFlick(player_color, impulse) player_color : Player Color of the player who flicked this object. impulse : The impulse applied to the object. Example Print the player color and magnitude of the flick: function onFlick ( player_color , impulse ) print ( player_color .. \" flicked with impulse \" .. impulse : magnitude ()) end","title":"onFlick(...)"},{"location":"event/#onhover","text":"Called when a player moves their pointer (cursor) over this Object . onHover(player_color) player_color : Player Color of the player who moved the pointer over an object. function onHover ( player_color ) print ( player_color ) end","title":"onHover(...)"},{"location":"event/#onnumbertyped","text":"Called when a player types a number whilst hovering over this Object . If you wish to prevent the default behavior (e.g. drawing a card, if this object were a deck) then you may return true to indicate you've handled the event yourself. onNumberTyped(player_color, number) player_color : Player Color of the player that typed the number. number : The number typed. Example Print the player color and the number they typed: function onNumberTyped ( player_color , number ) print ( player_color .. \" typed \" .. number ) end Example Prevent players drawing more than 2 cards at a time (from this object): function onNumberTyped ( player_color , number ) if self . type == 'Deck' and number > 2 then print ( \"Sorry. You can only draw a maximum of 2 cards.\" ) return true end end","title":"onNumberTyped(...)"},{"location":"event/#onpagechange","text":"Called when this Object 's Custom PDF page is changed. Example Print this object's name and what page it changed to: function onPageChange () print ( self . getName () .. \" changed page to \" .. self . Book . getPage ()) end","title":"onPageChange()"},{"location":"event/#onpeek","text":"Called when a player using peek to look under an Object. onPeek(player_color) player_color : Name of the Player Color that peeked. function onPeek ( color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end","title":"onPeek(...)"},{"location":"event/#onpickup","text":"Called when a player picks up an Object. onPickUp(player_color) player_color : Player Color of the Player. function onPickUp ( color ) print ( color ) end","title":"onPickUp(...)"},{"location":"event/#onrandomize","text":"Called when an Object is randomized. Like when shuffling a deck or shaking dice. onRandomize(player_color) player_color : Player Color of the player who triggered the function. function onRandomize ( color ) print ( self . getName () .. \" was randomized by \" .. color ) end","title":"onRandomize(...)"},{"location":"event/#onsearchend","text":"Called when a player first searches this Object. onSearchEnd( player_color) player_color : Player Color of the Player.","title":"onSearchEnd(...)"},{"location":"event/#onsearchstart","text":"Called when a player finishes searching this Object. onSearchStart( player_color) player_color : Player Color of the Player.","title":"onSearchStart(...)"},{"location":"externaleditorapi/","text":"This page describes how our Official Atom Plugin API works so that you can write your own plugin for your text editor of choice if Atom does not suit your needs. Communication between the editor and TTS occurs via two localhost TCP connections: one where TTS listens for messages and one where the editor listens for messages. All communication messages are JSON. Atom as the Server The following are messages the editor plugin listens for and handles. Atom listens for incoming localhost TCP connections on port 39998. Pushing New Object When clicking on \"Scripting Editor\" in the right click contextual menu in TTS for an object that doesn't have a Lua Script yet, TTS will send a JSON message with an ID of 0 and data for the object. The Atom plugin will open a new tab for this Object. If TTS is unable to connect to an external editor, e.g. if Atom is not running, then TTS falls back to the in-game editor. { \"messageID\" : 0 , \"scriptStates\" : [ { \"name\" : \"Chess Pawn\" , \"guid\" : \"db3f06\" , \"script\" : \"\" } ] } Loading a New Game After loading a new game in TTS, TTS will send all the Lua scripts and UI XML from the new game to Atom. TTS sends a JSON message with an ID of 1 and an array of the Lua Scripts and UI XMLs. TTS also sends this message as a response to requests made by the editor, as described later under messages TTS listens for and handles. { \"messageID\" : 1 , \"scriptStates\" : [ { \"name\" : \"Global\" , \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"name\" : \"BlackJack Dealer's Deck\" , \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } Note that this message contains all objects in the TTS session that have Lua scripts or UI XML data. Any object not mentioned by this message does not have a Lua script or UI XML in TTS. Print/Debug Messages TTS sends all print() messages to Atom to be displayed in Atom's console (ctrl + alt + i). TTS sends a JSON message with an ID of 2 and the message. { \"messageID\" : 2 , \"message\" : \"Hit player! White\" } Error Messages TTS sends all Lua error messages to Atom to be displayed in Atom's console (ctrl + alt + i) . TTS sends a JSON message with an ID of 3 and the error message. { \"messageID\" : 3 , \"error\" : \"chunk_0:(36,4-8): unexpected symbol near 'deck'\" , \"guid\" : \"-1\" , \"errorMessagePrefix\" : \"Error in Global Script: \" } Custom messages A messageID of 4 is used to send a custom message from TTS to the attached editor. This is done in Lua by calling sendExternalMessage with the table of data you wish to send. It is up to the editor how it uses this information (usually this message is used when the editor itself has sent code to be executed by TTS, which will send something back. i.e. this is mainly of use for people developing editor plugins). { \"messageID\" : 4 , \"customMessage\" : { \"foo\" : \"Hello\" , \"bar\" : \"World\" } } Return messages When the editor sends Lua code to TTS using the Execute Lua Code message (detailed below), if that code returns a value it will be sent back to the editor using message ID 5 . { \"messageID\" : 5 , \"returnValue\" : true } Game Saved Whenever the player saves the game in TTS, a save game notification is sent to any attached editor using message ID 6 . Object Created Whenever the player creates an object in TTS a notification is sent to any attached editor using message ID 7 . { \"messageID\" : 7 , \"guid\" : \"abcdef\" } Tabletop Simulator as the Server The following describes messages that TTS listens for and handles. TTS listens for incoming localhost TCP connections on port 39999. Get Lua Scripts TTS listens for a JSON message with an ID of 0, and responds by sending a JSON message containing scripts and UI XML. { \"messageID\" : 0 } The response is not sent over the same connection as the original request, but rather is sent to a server listening on the localhost on port 39998. The response is a message sent by TTS with an ID of 1, and is the same as the message TTS sends when loading a new game. Save & Play TTS listens for a JSON message with an ID of 1 containing an array of the Lua Scripts and UI XML. { \"messageID\" : 1 , \"scriptStates\" : [ { \"name\" : \"Global\" , \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"name\" : \"Block Rectangle\" , \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } TTS updates the Lua scripts and UI XML for any objects listed in the message, and then reloads the save file, the same way it does when pressing \"Save & Play\" within the in-game editor. Objects not mentioned in the scriptStates array are not updated. Any objects mentioned have both their Lua script and their UI XML updated. If no value is set for either the \"script\" or \"ui\" key then the corresponding Lua script or UI XML is deleted. That means if you want to update a Lua script for an object without changing its UI XML, then the message must contain both the updated Lua script and the unchanged UI XML. After TTS reloads the game, it then also sends a message with an ID of 1 back to the editor, with content the same as the message TTS sends when loading a new game. Custom Message TTS listens for a JSON message with an ID of 2 containing a custom message to be forwarded to the onExternalMessage event handler in the currently loaded game. { \"messageID\" : 2 , \"customMessage\" : { ... } } The value of customMessage must be a table, and is passed as a parameter to the event handler. If this value is not a table then the event is not triggered. Execute Lua Code TTS listens for a JSON message with an ID of 3 containing an object guid and lua script to run. { \"messageID\" : 3 , \"guid\" : \"-1\" , \"script\" : \"print(\\\"Hello, World\\\")\" } To execute Lua code for an object in the game that object must have an associated script in TTS. Otherwise the TTS scripting engine will fail with an error \"function \\<executeScript>: Object reference not set to an instance of an object\". Once the in-game editor shows a script associated with an object then TTS will be able to execute Lua code sent via JSON message for that object. { \"messageID\" : 3 , \"guid\" : \"e8e104\" , \"script\" : \"self.setPosition({0,10,0}\" }","title":"External Editor API"},{"location":"externaleditorapi/#atom-as-the-server","text":"The following are messages the editor plugin listens for and handles. Atom listens for incoming localhost TCP connections on port 39998.","title":"Atom as the Server"},{"location":"externaleditorapi/#pushing-new-object","text":"When clicking on \"Scripting Editor\" in the right click contextual menu in TTS for an object that doesn't have a Lua Script yet, TTS will send a JSON message with an ID of 0 and data for the object. The Atom plugin will open a new tab for this Object. If TTS is unable to connect to an external editor, e.g. if Atom is not running, then TTS falls back to the in-game editor. { \"messageID\" : 0 , \"scriptStates\" : [ { \"name\" : \"Chess Pawn\" , \"guid\" : \"db3f06\" , \"script\" : \"\" } ] }","title":"Pushing New Object"},{"location":"externaleditorapi/#loading-a-new-game","text":"After loading a new game in TTS, TTS will send all the Lua scripts and UI XML from the new game to Atom. TTS sends a JSON message with an ID of 1 and an array of the Lua Scripts and UI XMLs. TTS also sends this message as a response to requests made by the editor, as described later under messages TTS listens for and handles. { \"messageID\" : 1 , \"scriptStates\" : [ { \"name\" : \"Global\" , \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"name\" : \"BlackJack Dealer's Deck\" , \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } Note that this message contains all objects in the TTS session that have Lua scripts or UI XML data. Any object not mentioned by this message does not have a Lua script or UI XML in TTS.","title":"Loading a New Game"},{"location":"externaleditorapi/#printdebug-messages","text":"TTS sends all print() messages to Atom to be displayed in Atom's console (ctrl + alt + i). TTS sends a JSON message with an ID of 2 and the message. { \"messageID\" : 2 , \"message\" : \"Hit player! White\" }","title":"Print/Debug Messages"},{"location":"externaleditorapi/#error-messages","text":"TTS sends all Lua error messages to Atom to be displayed in Atom's console (ctrl + alt + i) . TTS sends a JSON message with an ID of 3 and the error message. { \"messageID\" : 3 , \"error\" : \"chunk_0:(36,4-8): unexpected symbol near 'deck'\" , \"guid\" : \"-1\" , \"errorMessagePrefix\" : \"Error in Global Script: \" }","title":"Error Messages"},{"location":"externaleditorapi/#custom-messages","text":"A messageID of 4 is used to send a custom message from TTS to the attached editor. This is done in Lua by calling sendExternalMessage with the table of data you wish to send. It is up to the editor how it uses this information (usually this message is used when the editor itself has sent code to be executed by TTS, which will send something back. i.e. this is mainly of use for people developing editor plugins). { \"messageID\" : 4 , \"customMessage\" : { \"foo\" : \"Hello\" , \"bar\" : \"World\" } }","title":"Custom messages"},{"location":"externaleditorapi/#return-messages","text":"When the editor sends Lua code to TTS using the Execute Lua Code message (detailed below), if that code returns a value it will be sent back to the editor using message ID 5 . { \"messageID\" : 5 , \"returnValue\" : true }","title":"Return messages"},{"location":"externaleditorapi/#game-saved","text":"Whenever the player saves the game in TTS, a save game notification is sent to any attached editor using message ID 6 .","title":"Game Saved"},{"location":"externaleditorapi/#object-created","text":"Whenever the player creates an object in TTS a notification is sent to any attached editor using message ID 7 . { \"messageID\" : 7 , \"guid\" : \"abcdef\" }","title":"Object Created"},{"location":"externaleditorapi/#tabletop-simulator-as-the-server","text":"The following describes messages that TTS listens for and handles. TTS listens for incoming localhost TCP connections on port 39999.","title":"Tabletop Simulator as the Server"},{"location":"externaleditorapi/#get-lua-scripts","text":"TTS listens for a JSON message with an ID of 0, and responds by sending a JSON message containing scripts and UI XML. { \"messageID\" : 0 } The response is not sent over the same connection as the original request, but rather is sent to a server listening on the localhost on port 39998. The response is a message sent by TTS with an ID of 1, and is the same as the message TTS sends when loading a new game.","title":"Get Lua Scripts"},{"location":"externaleditorapi/#save-play","text":"TTS listens for a JSON message with an ID of 1 containing an array of the Lua Scripts and UI XML. { \"messageID\" : 1 , \"scriptStates\" : [ { \"name\" : \"Global\" , \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"name\" : \"Block Rectangle\" , \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } TTS updates the Lua scripts and UI XML for any objects listed in the message, and then reloads the save file, the same way it does when pressing \"Save & Play\" within the in-game editor. Objects not mentioned in the scriptStates array are not updated. Any objects mentioned have both their Lua script and their UI XML updated. If no value is set for either the \"script\" or \"ui\" key then the corresponding Lua script or UI XML is deleted. That means if you want to update a Lua script for an object without changing its UI XML, then the message must contain both the updated Lua script and the unchanged UI XML. After TTS reloads the game, it then also sends a message with an ID of 1 back to the editor, with content the same as the message TTS sends when loading a new game.","title":"Save &amp; Play"},{"location":"externaleditorapi/#custom-message","text":"TTS listens for a JSON message with an ID of 2 containing a custom message to be forwarded to the onExternalMessage event handler in the currently loaded game. { \"messageID\" : 2 , \"customMessage\" : { ... } } The value of customMessage must be a table, and is passed as a parameter to the event handler. If this value is not a table then the event is not triggered.","title":"Custom Message"},{"location":"externaleditorapi/#execute-lua-code","text":"TTS listens for a JSON message with an ID of 3 containing an object guid and lua script to run. { \"messageID\" : 3 , \"guid\" : \"-1\" , \"script\" : \"print(\\\"Hello, World\\\")\" } To execute Lua code for an object in the game that object must have an associated script in TTS. Otherwise the TTS scripting engine will fail with an error \"function \\<executeScript>: Object reference not set to an instance of an object\". Once the in-game editor shows a script associated with an object then TTS will be able to execute Lua code sent via JSON message for that object. { \"messageID\" : 3 , \"guid\" : \"e8e104\" , \"script\" : \"self.setPosition({0,10,0}\" }","title":"Execute Lua Code"},{"location":"grid/","text":"Grid, a static global class, controls the in-game grid. It allows you to manipulate the placement and appearance of the grid in the same way as the in-game interface. Example usage: Grid.show_lines = true . Member Variables Like Object member variables , Grid has its own member variables. They allow for direct access to the Grid's properties. Variable Description Type type The type of the grid. 1 = Rectangles, 2 = Horizontal hexes, 3 = Vertical hexes. show_lines Visibility of the grid lines. color Color of the grid lines. opacity Opacity of the grid lines. thick_lines Thickness of the grid lines. false = Thin, true = Thick. snapping Method of snapping objects to the grid. 1 = Off, 2 = Lines, 3 = Center, 4 = Both. offsetX X offset of the grid origin. offsetY Y offset of the grid origin. sizeX Width of the grid cells. sizeY Height of the grid cells.","title":"Grid"},{"location":"grid/#member-variables","text":"Like Object member variables , Grid has its own member variables. They allow for direct access to the Grid's properties. Variable Description Type type The type of the grid. 1 = Rectangles, 2 = Horizontal hexes, 3 = Vertical hexes. show_lines Visibility of the grid lines. color Color of the grid lines. opacity Opacity of the grid lines. thick_lines Thickness of the grid lines. false = Thin, true = Thick. snapping Method of snapping objects to the grid. 1 = Off, 2 = Lines, 3 = Center, 4 = Both. offsetX X offset of the grid origin. offsetY Y offset of the grid origin. sizeX Width of the grid cells. sizeY Height of the grid cells.","title":"Member Variables"},{"location":"hands/","text":"The static global Hands class allows you to interact with Hand Objects. This allows you to manipulate the properties of Hand Zones in the same way as the in-game interface. Example Usage: Hands . enable = true . Member Variables Like Object member variables , Hands has its own member variables. They allow for direct access to the Hand's properties. Variable Description Type enable Should player Hands hold objects. disable_unused Hands not used by a player will not be enabled. hiding How objects are hidden in Hands. 1 = Default, 2 = Reverse, 3 = Disable Function Summary Class Functions Function Name Description Return getValue() Returns the color of a Hand Zone. setValue( color) Sets the color of a Hand Zone. Direct Class Functions Function Name Description Return getHands() Returns a Table of all Hand Zone Objects in the game.","title":"Hands"},{"location":"hands/#member-variables","text":"Like Object member variables , Hands has its own member variables. They allow for direct access to the Hand's properties. Variable Description Type enable Should player Hands hold objects. disable_unused Hands not used by a player will not be enabled. hiding How objects are hidden in Hands. 1 = Default, 2 = Reverse, 3 = Disable","title":"Member Variables"},{"location":"hands/#function-summary","text":"","title":"Function Summary"},{"location":"hands/#class-functions","text":"Function Name Description Return getValue() Returns the color of a Hand Zone. setValue( color) Sets the color of a Hand Zone.","title":"Class Functions"},{"location":"hands/#direct-class-functions","text":"Function Name Description Return getHands() Returns a Table of all Hand Zone Objects in the game.","title":"Direct Class Functions"},{"location":"info/","text":"The static global Info class allows you to interact with Hand Objects. This allows you to manipulate the Info properties in the same way as the in-game interface. Example Usage: Info . name = \"My Game\" . Member Variables Like Object member variables , Info has its own member variables. They allow for direct access to the Info's properties. Variable Description Type name Current name of the game you are playing. type The type of the game you are playing. complexity The complexity of the game you are playing. playing_time The amount of time the current game takes. number_of_players The number of players the current game allows. tags The tags are used to filter your games.","title":"Info"},{"location":"info/#member-variables","text":"Like Object member variables , Info has its own member variables. They allow for direct access to the Info's properties. Variable Description Type name Current name of the game you are playing. type The type of the game you are playing. complexity The complexity of the game you are playing. playing_time The amount of time the current game takes. number_of_players The number of players the current game allows. tags The tags are used to filter your games.","title":"Member Variables"},{"location":"intro/","text":"In this section, you will find details on all events/classes/functions specific to Tabletop Simulator's Lua scripting. For more general information on how the scripting language of Lua works and what it does on its own, you can review the Official Lua Documentation . Using TTS Documentation Left Column This is the top-level list of classes and other information needed when scripting with Lua in Tabletop Simulator. Event, Base and Object are the three pages you will use the most, with the rest referring to niche information you can access as you go. It is a good idea to familiarize yourself with the contents of those three pages in order to have a good high-level understanding of what scripting is capable of doing. Right Column The Table of Contents will lay out the contents of the page you are on. It always starts with high-level summary information first and, if needed, detailed information towards the bottom. The next to a summary element will take you directly down to the relevant detailed explanation below. Growing TTS Documentation This documentation is written via Markdown language and some custom CSS. The relevant files you can modify, as well as some detailed editing instructions, are listed on GitHub. You can make a pull request in order to submit modifications/improvements that can be incorporated into this documentation. Just click the link in the pencil icon in the top-right of an article, or visit the GitHub page for more information by clicking GitHub Source in the far upper right. TTS Terms Object An in-game physical Object that currently exists in the scene. If an Object is placed inside of a bag/deck/etc, it stops existing and is no longer in the scene until it is pulled back out. Player A person in the game. Each Player is assigned a color, with spectators being \"Grey\". If you are attempting to identify a Player, you would use the color of the seat they are in to do so. Global Script The Global script, which is a script that is not attached to any particular Object. It is always present during a game. Object Script A script that is attached to an in-game Object, and is saved as part of it. This is similar to any other property like its scale or tint. Some functions ask for an Object reference in order to attempt to run a function on it. In these cases, Global (exactly as written here) is also a valid Object reference. GUID In Tabletop Simulator, a GUID is a unique 6-character string which can be used to identify in-game Objects . GUIDs are automatically assigned when objects exist within the scene. If an object is duplicated, it will sometimes have the same GUID for 1 frame before the engine assigns a new GUID to the newer Object. Objects in containers (bags/decks/etc) do not automatically get new GUIDs assigned to them in this way. Only once their contents are moved out into the scene. Custom Deck Card GUIDs When you first create a custom deck, all cards within the deck share the same GUID. If you need to reference individual GUIDs of cards, then the way to solve this is to lay out all cards from the deck at the same time to allow new GUIDs to be assigned by the game. This tool can be used to simplify the process. Deprecated APIs Through-out this documentation you may come across Lua APIs that are labelled as . It is advised that you no longer use deprecated APIs. Typically, this is because newer/improved APIs have been introduced that better serve the same purpose. Deprecated APIs will not be removed or stop working. Existing mods may continue to use deprecated functionality without issue. It is however strongly recommended, that for the best experience you avoid use of deprecated APIs in new code. Classes Defining classes requires further knowledge of object-oriented programming to really understand. However for the purposes of Tabletop Simulator Lua scripting, you can think of a class as a standard or collection that handles categories of objects. Object Classes Associated with in-game Objects. Clock Counter Object AssetBundle RPGFigurine TextTool Static Classes Associated with in-game properties and systems. JSON Player WebRequest Physics Lighting Turns Notes UI Wait Web Request For more information on what a class is, you can refer to the relevant Lua Documentation .","title":"Introduction"},{"location":"intro/#using-tts-documentation","text":"","title":"Using TTS Documentation"},{"location":"intro/#left-column","text":"This is the top-level list of classes and other information needed when scripting with Lua in Tabletop Simulator. Event, Base and Object are the three pages you will use the most, with the rest referring to niche information you can access as you go. It is a good idea to familiarize yourself with the contents of those three pages in order to have a good high-level understanding of what scripting is capable of doing.","title":"Left Column"},{"location":"intro/#right-column","text":"The Table of Contents will lay out the contents of the page you are on. It always starts with high-level summary information first and, if needed, detailed information towards the bottom. The next to a summary element will take you directly down to the relevant detailed explanation below.","title":"Right Column"},{"location":"intro/#growing-tts-documentation","text":"This documentation is written via Markdown language and some custom CSS. The relevant files you can modify, as well as some detailed editing instructions, are listed on GitHub. You can make a pull request in order to submit modifications/improvements that can be incorporated into this documentation. Just click the link in the pencil icon in the top-right of an article, or visit the GitHub page for more information by clicking GitHub Source in the far upper right.","title":"Growing TTS Documentation"},{"location":"intro/#tts-terms","text":"","title":"TTS Terms"},{"location":"intro/#object","text":"An in-game physical Object that currently exists in the scene. If an Object is placed inside of a bag/deck/etc, it stops existing and is no longer in the scene until it is pulled back out.","title":"Object"},{"location":"intro/#player","text":"A person in the game. Each Player is assigned a color, with spectators being \"Grey\". If you are attempting to identify a Player, you would use the color of the seat they are in to do so.","title":"Player"},{"location":"intro/#global-script","text":"The Global script, which is a script that is not attached to any particular Object. It is always present during a game.","title":"Global Script"},{"location":"intro/#object-script","text":"A script that is attached to an in-game Object, and is saved as part of it. This is similar to any other property like its scale or tint. Some functions ask for an Object reference in order to attempt to run a function on it. In these cases, Global (exactly as written here) is also a valid Object reference.","title":"Object Script"},{"location":"intro/#guid","text":"In Tabletop Simulator, a GUID is a unique 6-character string which can be used to identify in-game Objects . GUIDs are automatically assigned when objects exist within the scene. If an object is duplicated, it will sometimes have the same GUID for 1 frame before the engine assigns a new GUID to the newer Object. Objects in containers (bags/decks/etc) do not automatically get new GUIDs assigned to them in this way. Only once their contents are moved out into the scene. Custom Deck Card GUIDs When you first create a custom deck, all cards within the deck share the same GUID. If you need to reference individual GUIDs of cards, then the way to solve this is to lay out all cards from the deck at the same time to allow new GUIDs to be assigned by the game. This tool can be used to simplify the process.","title":"GUID"},{"location":"intro/#deprecated","text":"Through-out this documentation you may come across Lua APIs that are labelled as . It is advised that you no longer use deprecated APIs. Typically, this is because newer/improved APIs have been introduced that better serve the same purpose. Deprecated APIs will not be removed or stop working. Existing mods may continue to use deprecated functionality without issue. It is however strongly recommended, that for the best experience you avoid use of deprecated APIs in new code.","title":"Deprecated APIs"},{"location":"intro/#classes","text":"Defining classes requires further knowledge of object-oriented programming to really understand. However for the purposes of Tabletop Simulator Lua scripting, you can think of a class as a standard or collection that handles categories of objects.","title":"Classes"},{"location":"intro/#object-classes","text":"Associated with in-game Objects. Clock Counter Object AssetBundle RPGFigurine TextTool","title":"Object Classes"},{"location":"intro/#static-classes","text":"Associated with in-game properties and systems. JSON Player WebRequest Physics Lighting Turns Notes UI Wait Web Request For more information on what a class is, you can refer to the relevant Lua Documentation .","title":"Static Classes"},{"location":"json/","text":"The static global JSON class provides the ability to encode/decode data into JSON strings. This is largely used by the onSave() event function, but has other potential applications as well. The JSON class can be used on any String, Int, Float or Table. You call these functions like this: JSON.encode(...) . Warning This class does not work with Object references. Use the Object's GUID instead. Function Summary Object Functions Function Name Description Return decode( json_string) Value obtained from the encoded string. Can return a number, string or Table. encode( data) Encodes data from a number, string or Table into a JSON string. encode_pretty( data) Same as encode(...) but this version is slightly less efficient but is easier to read. Function Details decode(...) Value obtained from the encoded string. Can return a number, string or Table. decode(json_string) json_string : A String that is decoded, generally created by encode(...) or encode_pretty(...). coded = JSON . encode ( \"Test\" ) print ( coded ) --Prints \"Test\" decoded = JSON . decode ( coded ) print ( decoded ) --Prints Test encode(...) Encodes data from a number, string or Table into a JSON string. encode(data) data : A Var, either String, Int, Float or Table, to encode as a string. encode_pretty(...) Encodes data from a number, string or Table into a JSON string. This version is slightly less efficient but is easier to read. encode_pretty(data) data : A Var, either String, Int, Float or Table, to encode as a string.","title":"JSON"},{"location":"json/#function-summary","text":"","title":"Function Summary"},{"location":"json/#object-functions","text":"Function Name Description Return decode( json_string) Value obtained from the encoded string. Can return a number, string or Table. encode( data) Encodes data from a number, string or Table into a JSON string. encode_pretty( data) Same as encode(...) but this version is slightly less efficient but is easier to read.","title":"Object Functions"},{"location":"json/#function-details","text":"","title":"Function Details"},{"location":"json/#decode","text":"Value obtained from the encoded string. Can return a number, string or Table. decode(json_string) json_string : A String that is decoded, generally created by encode(...) or encode_pretty(...). coded = JSON . encode ( \"Test\" ) print ( coded ) --Prints \"Test\" decoded = JSON . decode ( coded ) print ( decoded ) --Prints Test","title":"decode(...)"},{"location":"json/#encode","text":"Encodes data from a number, string or Table into a JSON string. encode(data) data : A Var, either String, Int, Float or Table, to encode as a string.","title":"encode(...)"},{"location":"json/#encode_pretty","text":"Encodes data from a number, string or Table into a JSON string. This version is slightly less efficient but is easier to read. encode_pretty(data) data : A Var, either String, Int, Float or Table, to encode as a string.","title":"encode_pretty(...)"},{"location":"learninglua/","text":"In the future, there will be a \"Getting Started\" style Lua tutorial here, to help people just picking up the language or programming in general. For now, please refer to these user guides for the same purpose: Learning Lua First steps, and introduction to programming. Learning MORE Lua More complicated concepts and many coding examples to demonstrate commonly used functions. Learning Lua Functions A collection of utility functions to help in performing actions as well as demonstrate some better coding practices.","title":"Learning Lua"},{"location":"lighting/","text":"Lighting, a static global class, is the in-game light of the map. It allows you to modify the lighting of the instance in the same way that the in-game lighting menu does. You call these functions like this: Lighting.apply() . For more information on lighting in Unity, refer to the Unity documentation . Member Variables Like Object member variables , Lighting has its own member variables. They are all numbers, and have specific valid ranges. Variable Description Type ambient_type The source of ambient light. 1 = background, 2 = gradient. ambient_intensity The strength of the ambient light. Range = 0 to 4. light_intensity The strength of the directional light shining down in the scene. Range = 0 to 4. reflection_intensity The strength of the reflections from the background. Range = 0 to 1. Function Summary Functions Function Name Description Return apply() Applies changes made to the lighting Class using these functions or member variables. getAmbientEquatorColor() Returns Color Table of the gradient equator. Not used if ambient_type = 1 . getAmbientGroundColor() Returns Color Table of the gradient ground. Not used if ambient_type = 1 . getAmbientSkyColor() Returns Color Table of the gradient sky. Not used if ambient_type = 1 . getLightColor() Returns Color Table of the directional light, which shines straight down on the table. setAmbientEquatorColor( tint) Sets the color of the gradient equator. Not used if ambient_type = 1 . setAmbientGroundColor( tint) Sets the color of the gradient ground. Not used if ambient_type = 1 . setAmbientSkyColor( tint) Sets the color of the gradient sky. Not used if ambient_type = 1 . setLightColor( tint) Sets the color of the directional light, which shines straight down on the table. Function Details Example of making light red and bright function onLoad () red = { r = 1 , g = 0.6 , b = 0.6 } Lighting . light_intensity = 2 Lighting . setLightColor ( red ) Lighting . apply () end","title":"Lighting"},{"location":"lighting/#member-variables","text":"Like Object member variables , Lighting has its own member variables. They are all numbers, and have specific valid ranges. Variable Description Type ambient_type The source of ambient light. 1 = background, 2 = gradient. ambient_intensity The strength of the ambient light. Range = 0 to 4. light_intensity The strength of the directional light shining down in the scene. Range = 0 to 4. reflection_intensity The strength of the reflections from the background. Range = 0 to 1.","title":"Member Variables"},{"location":"lighting/#function-summary","text":"","title":"Function Summary"},{"location":"lighting/#functions","text":"Function Name Description Return apply() Applies changes made to the lighting Class using these functions or member variables. getAmbientEquatorColor() Returns Color Table of the gradient equator. Not used if ambient_type = 1 . getAmbientGroundColor() Returns Color Table of the gradient ground. Not used if ambient_type = 1 . getAmbientSkyColor() Returns Color Table of the gradient sky. Not used if ambient_type = 1 . getLightColor() Returns Color Table of the directional light, which shines straight down on the table. setAmbientEquatorColor( tint) Sets the color of the gradient equator. Not used if ambient_type = 1 . setAmbientGroundColor( tint) Sets the color of the gradient ground. Not used if ambient_type = 1 . setAmbientSkyColor( tint) Sets the color of the gradient sky. Not used if ambient_type = 1 . setLightColor( tint) Sets the color of the directional light, which shines straight down on the table.","title":"Functions"},{"location":"lighting/#function-details","text":"","title":"Function Details"},{"location":"lighting/#example-of-making-light-red-and-bright","text":"function onLoad () red = { r = 1 , g = 0.6 , b = 0.6 } Lighting . light_intensity = 2 Lighting . setLightColor ( red ) Lighting . apply () end","title":"Example of making light red and bright"},{"location":"musicplayer/","text":"MusicPlayer is a static global class which allows you to control the in-game music playback i.e. the in-game \"Music\" menu. Member Variables Like Object member variables , MusicPlayer has its own member variables. They allow for direct access to the MusicPlayer's property information without a helping function. Some are read-only. Variable Description Type loaded If all players loaded the current audioclip. Read only. player_status The current state of the music player. Read only. Options: \"Stop\", \"Play\", \"Loading\", \"Ready\". playlistIndex Use playlist_index . Current index of the playlist. -1 if no playlist audioclip is playing. playlist_index Current index of the playlist. -1 if no playlist audioclip is playing. repeat_track If the current audioclip should be repeated. shuffle If the playlist should play shuffled. Function Summary Functions that interact with the in-game music player. Function Name Description Return getCurrentAudioclip() Gets the currently loaded audioclip. getPlaylist() Gets the current playlist. pause() Pauses currently playing audioclip. Returns true if the music player is paused, otherwise returns false. play() Plays currently loaded audioclip. Returns true if the music player is playing, otherwise returns false. setCurrentAudioclip() Sets the audioclip to be loaded. setPlaylist() Sets the current playlis skipBack() Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. skipForward() Skips to the next audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. Function Details getCurrentAudioclip() Gets the currently loaded audioclip. Returned table Table describing the current audioclip. url : The URL of the current audioclip. title : The title of the current audioclip. Example Print the title of the current audioclip. local clip = MusicPlayer . getCurrentAudioclip () print ( \"Currently playing '\" .. clip . title .. \"'\" ) getPlaylist() Gets the current playlist. Returned table Playlist table, consisting of zero or more audioclip sub-tables. Sub-table describing each audioclip. url : The URL of the current audioclip. title : The title of the current audioclip. Example Print the track number and title of each audioclip making up the playlist. local playlist = MusicPlayer . getPlaylist () for i , clip in ipairs ( playlist ) do print ( i .. \" - \" .. clip . title ) end pause() Pause the current audioclip. Returns true if the music player is/was paused, otherwise false . Example Pause the current track. MusicPlayer . pause () play() Plays the current audioclip. Returns true if the music player is/was playing, otherwise false . Example Play the current track. MusicPlayer . play () setCurrentAudioclip(...) .Sets/loads the specified audioclip. setCurrentAudioclip(parameters) parameters : A table describing an audioclip. url : The URL of the audioclip. title : The title of the audioclip. Example Set the current track. MusicPlayer . setCurrentAudioclip ({ url = \"https://domain.example/path/to/clip.mp3\" , title = \"Example\" }) setPlaylist(...) Sets the current playlist. setPlaylist(parameters) parameters : A table containing zero or more audioclip sub-tables. Sub-table describing each audioclip. parameters.url : The URL of an audioclip. parameters.title : The title of an audioclip. Example Set the current playlist to include three pieces of music. MusicPlayer . setCurrentAudioclip ({ { url = \"https://domain.example/path/to/clip.mp3\" , title = \"Example\" }, { url = \"https://domain.example/path/to/clip2.mp3\" , title = \"Example #2\" }, { url = \"https://domain.example/path/to/clip3.mp3\" , title = \"Example #3\" } }) skipBack() Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false . Example Skip backwards to either the beginning of the audioclip, or the prior audioclip in the playlist. MusicPlayer . skipBack () skipForward() Skips to the next audioclip in the current playlist. If the current audioclip is the last of the playlist, loops around to the first audioclip in the playlist. Returns true if skip was successful, otherwise returns false . Example Skip to the next audioclip. MusicPlayer . skipForward ()","title":"Music Player"},{"location":"musicplayer/#member-variables","text":"Like Object member variables , MusicPlayer has its own member variables. They allow for direct access to the MusicPlayer's property information without a helping function. Some are read-only. Variable Description Type loaded If all players loaded the current audioclip. Read only. player_status The current state of the music player. Read only. Options: \"Stop\", \"Play\", \"Loading\", \"Ready\". playlistIndex Use playlist_index . Current index of the playlist. -1 if no playlist audioclip is playing. playlist_index Current index of the playlist. -1 if no playlist audioclip is playing. repeat_track If the current audioclip should be repeated. shuffle If the playlist should play shuffled.","title":"Member Variables"},{"location":"musicplayer/#function-summary","text":"Functions that interact with the in-game music player. Function Name Description Return getCurrentAudioclip() Gets the currently loaded audioclip. getPlaylist() Gets the current playlist. pause() Pauses currently playing audioclip. Returns true if the music player is paused, otherwise returns false. play() Plays currently loaded audioclip. Returns true if the music player is playing, otherwise returns false. setCurrentAudioclip() Sets the audioclip to be loaded. setPlaylist() Sets the current playlis skipBack() Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. skipForward() Skips to the next audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false.","title":"Function Summary"},{"location":"musicplayer/#function-details","text":"","title":"Function Details"},{"location":"musicplayer/#getcurrentaudioclip","text":"Gets the currently loaded audioclip. Returned table Table describing the current audioclip. url : The URL of the current audioclip. title : The title of the current audioclip. Example Print the title of the current audioclip. local clip = MusicPlayer . getCurrentAudioclip () print ( \"Currently playing '\" .. clip . title .. \"'\" )","title":"getCurrentAudioclip()"},{"location":"musicplayer/#getplaylist","text":"Gets the current playlist. Returned table Playlist table, consisting of zero or more audioclip sub-tables. Sub-table describing each audioclip. url : The URL of the current audioclip. title : The title of the current audioclip. Example Print the track number and title of each audioclip making up the playlist. local playlist = MusicPlayer . getPlaylist () for i , clip in ipairs ( playlist ) do print ( i .. \" - \" .. clip . title ) end","title":"getPlaylist()"},{"location":"musicplayer/#pause","text":"Pause the current audioclip. Returns true if the music player is/was paused, otherwise false . Example Pause the current track. MusicPlayer . pause ()","title":"pause()"},{"location":"musicplayer/#play","text":"Plays the current audioclip. Returns true if the music player is/was playing, otherwise false . Example Play the current track. MusicPlayer . play ()","title":"play()"},{"location":"musicplayer/#setcurrentaudioclip","text":".Sets/loads the specified audioclip. setCurrentAudioclip(parameters) parameters : A table describing an audioclip. url : The URL of the audioclip. title : The title of the audioclip. Example Set the current track. MusicPlayer . setCurrentAudioclip ({ url = \"https://domain.example/path/to/clip.mp3\" , title = \"Example\" })","title":"setCurrentAudioclip(...)"},{"location":"musicplayer/#setplaylist","text":"Sets the current playlist. setPlaylist(parameters) parameters : A table containing zero or more audioclip sub-tables. Sub-table describing each audioclip. parameters.url : The URL of an audioclip. parameters.title : The title of an audioclip. Example Set the current playlist to include three pieces of music. MusicPlayer . setCurrentAudioclip ({ { url = \"https://domain.example/path/to/clip.mp3\" , title = \"Example\" }, { url = \"https://domain.example/path/to/clip2.mp3\" , title = \"Example #2\" }, { url = \"https://domain.example/path/to/clip3.mp3\" , title = \"Example #3\" } })","title":"setPlaylist(...)"},{"location":"musicplayer/#skipback","text":"Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false . Example Skip backwards to either the beginning of the audioclip, or the prior audioclip in the playlist. MusicPlayer . skipBack ()","title":"skipBack()"},{"location":"musicplayer/#skipforward","text":"Skips to the next audioclip in the current playlist. If the current audioclip is the last of the playlist, loops around to the first audioclip in the playlist. Returns true if skip was successful, otherwise returns false . Example Skip to the next audioclip. MusicPlayer . skipForward ()","title":"skipForward()"},{"location":"notes/","text":"Notes, a static global class, allows access to the on-screen notes and the notebook. Example function call: Notes.setNotes() Function Summary Notebook Functions Functions that interact with the in-game notebook tabs. Function Name Description Return addNotebookTab( parameters) Adds a notebook tab, returning its index. editNotebookTab( parameters) Edit an existing Tab in the notebook. getNotebookTabs() Returns Table containing data on all tabs in the notebook. removeNotebookTab( index) Remove a notebook tab. Notes Functions Functions that interact with the on-screen notes (lower right corner of screen). Function Name Description Return getNotes() Returns the contents of the on-screen notes section. setNotes( notes) Replace the text in the notes window with the string. Function Details Notebook Function Details addNotebookTab(...) Add a new notebook tab. If it failed to create a new tab, a -1 is returned instead. Indexes for notebook tabs begin at 0. addNotebookTab(parameters) parameters : A Table containing spawning parameters. parameters.title : Title for the new tab. parameters.body : Text to place into the body of the new tab. Optional, defaults to an empty string parameters.color : Player Color for the new tab's color. Optional, defaults to \"Grey\" parameters = { title = \"New Tab\" , body = \"Body text example.\" , color = \"Grey\" } Notes . addNotebookTab ( parameters ) editNotebookTab(...) Edit an existing Tab in the notebook. Indexes for notebook tabs begin at 0. editNotebookTab(parameters) parameters : A Table containing instructions for the notebook edit. parameters.index : Index number for the tab. parameters.title : Title for the tab. Optional, defaults to the current title of the tab begin edited. parameters.body : Text for the body for the tab. Optional, defaults to the current body of the tab begin edited. parameters.color : Player Color for who the tab belongs to. Optional, defaults to the current color of the tab begin edited. params = { index = 5 , title = \"Edited Title\" , body = \"This tab was edited via script.\" , color = \"Grey\" } Notes . editNotebookTab ( params ) getNotebookTabs() Returns a Table containing data on all tabs in the notebook. Indexes for notebook tabs begin at 0. --Example Usage tabInfo = Notes . getNotebookTabs () --Example Returned Table { { index = 0 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 1 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 2 , title = \"\" , body = \"\" , color = \"Grey\" }, } removeNotebookTab(...) Remove a notebook tab. Notebook tab indexes begin at 0. removeNotebookTab(index) index : Index for the tab to remove. Notes . removeNotebookTab ( 0 ) Notes Function Details setNotes(...) Replace the text in the notes window with the string. The notes is an area which displays text in the lower-right corner of the screen. setNotes(notes) notes : What to place into the notes area. Notes . setNotes ( \"This appears in the notes section\" )","title":"Notes"},{"location":"notes/#function-summary","text":"","title":"Function Summary"},{"location":"notes/#notebook-functions","text":"Functions that interact with the in-game notebook tabs. Function Name Description Return addNotebookTab( parameters) Adds a notebook tab, returning its index. editNotebookTab( parameters) Edit an existing Tab in the notebook. getNotebookTabs() Returns Table containing data on all tabs in the notebook. removeNotebookTab( index) Remove a notebook tab.","title":"Notebook Functions"},{"location":"notes/#notes-functions","text":"Functions that interact with the on-screen notes (lower right corner of screen). Function Name Description Return getNotes() Returns the contents of the on-screen notes section. setNotes( notes) Replace the text in the notes window with the string.","title":"Notes Functions"},{"location":"notes/#function-details","text":"","title":"Function Details"},{"location":"notes/#notebook-function-details","text":"","title":"Notebook Function Details"},{"location":"notes/#addnotebooktab","text":"Add a new notebook tab. If it failed to create a new tab, a -1 is returned instead. Indexes for notebook tabs begin at 0. addNotebookTab(parameters) parameters : A Table containing spawning parameters. parameters.title : Title for the new tab. parameters.body : Text to place into the body of the new tab. Optional, defaults to an empty string parameters.color : Player Color for the new tab's color. Optional, defaults to \"Grey\" parameters = { title = \"New Tab\" , body = \"Body text example.\" , color = \"Grey\" } Notes . addNotebookTab ( parameters )","title":"addNotebookTab(...)"},{"location":"notes/#editnotebooktab","text":"Edit an existing Tab in the notebook. Indexes for notebook tabs begin at 0. editNotebookTab(parameters) parameters : A Table containing instructions for the notebook edit. parameters.index : Index number for the tab. parameters.title : Title for the tab. Optional, defaults to the current title of the tab begin edited. parameters.body : Text for the body for the tab. Optional, defaults to the current body of the tab begin edited. parameters.color : Player Color for who the tab belongs to. Optional, defaults to the current color of the tab begin edited. params = { index = 5 , title = \"Edited Title\" , body = \"This tab was edited via script.\" , color = \"Grey\" } Notes . editNotebookTab ( params )","title":"editNotebookTab(...)"},{"location":"notes/#getnotebooktabs","text":"Returns a Table containing data on all tabs in the notebook. Indexes for notebook tabs begin at 0. --Example Usage tabInfo = Notes . getNotebookTabs () --Example Returned Table { { index = 0 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 1 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 2 , title = \"\" , body = \"\" , color = \"Grey\" }, }","title":"getNotebookTabs()"},{"location":"notes/#removenotebooktab","text":"Remove a notebook tab. Notebook tab indexes begin at 0. removeNotebookTab(index) index : Index for the tab to remove. Notes . removeNotebookTab ( 0 )","title":"removeNotebookTab(...)"},{"location":"notes/#notes-function-details","text":"","title":"Notes Function Details"},{"location":"notes/#setnotes","text":"Replace the text in the notes window with the string. The notes is an area which displays text in the lower-right corner of the screen. setNotes(notes) notes : What to place into the notes area. Notes . setNotes ( \"This appears in the notes section\" )","title":"setNotes(...)"},{"location":"object/","text":"The Object class represents any entity within tabletop simulator. Once you have a reference to an object in you're script you can call functions on it directly. Example: obj.getPosition(...) . You can get a reference to an object multiple ways; Using the self property if your script is on an Object and referring to that Object. Using getObjectFromGUID(...) with the object's GUID (found by right clicking it with the pointer). Getting it as a return from another function, like with spawnObject(...) . Member Variable Summary Member Variables These are variables that objects share. They allow for direct access to an Object's property information without a helping function. Some are read-only. Read Example = isResting = self.resting Write Example = self.resting = true Variable Description Type alt_view_angle When non-zero, the Alt view will use the specified Euler angle to look at the object. angular_drag Angular drag. Unity rigidbody property . auto_raise If an object should be lifted above other objects to avoid collision when held by a player. bounciness Bounciness, value of 0-1. Unity physics material . drag Drag. Unity rigidbody property . drag_selectable When false , the object will not be selected by regular (click and drag) selection boxes that are drawn around the object. Players may proceed to override this behavior by holding the \"Shift\" modifier whilst drag selecting. dynamic_friction Dynamic friction, value of 0-1. Unity physics material . grid_projection If grid lines can appear on the Object if visible grids are turned on. guid The 6 character unique Object identifier within Tabletop Simulator. It is assigned correctly once the spawning member variable becomes false. held_by_color The Color of the Player that is holding the object. held_flip_index 0-23 value. Changes when a Player hits flip or alt + rotate. held_position_offset Position offset from pointer. held_reduce_force When the Object collides with something while moving this is automatically enabled and reduces the movement force. held_rotation_offset Rotation offset from pointer. held_spin_index 0-23 value. Changes when a Player rotates the Object. hide_when_face_down Hide the Object when face-down as if it were in a hand zone. The face is the \"top\" of the Object, the direction of its positive Y coordinate. Cards/decks default to true . ignore_fog_of_war Makes the object not be hidden by Fog of War . interactable If an object can be interacted with by Players. Other object will still be able to interact with it. is_face_down If an Object is roughly face-down (like with cards). The face is the \"top\" of the Object, the direction of its positive Y coordinate. Read only. loading_custom If the Object's custom elements (images/models/etc) are loading. Read only. locked If the object is frozen in place (preventing physics interactions). mass Mass. Unity rigidbody property . max_typed_number Determines the maximum number of digits which a user may type whilst hovering over an object. As soon as a player types the maximum number of digits, the corresponding behavior (e.g. onObjectNumberTyped / onNumberTyped ) is triggered immediately, improving responsiveness. measure_movement Measure Tool will automatically be used when moving the Object. memo A string you can store info in for an object. name Internal resource name for this Object. Read only, and only useful for spawnObjectJSON() . Generally, you want getName() . pick_up_position The position the Object was picked up at. Read only. pick_up_rotation The rotation the Object was picked up at. Read only. remainder If this object is a container that cannot exist with less than two contained objects (e.g. a deck), taking out the second last contained object will result in the container being destroyed. In its place the last remaining object in the container will be spawned. This variable provides a reference to the remaining object when it is being spawned. Otherwise, it's nil . Read only. resting If an Object is at rest. Unity rigidbody property . script_code The Lua Script on the Object. script_state The saved data on the object. See onSave() . spawning If the Object is finished spawning. Read only. static_friction Static friction, value of 0-1. Unity physics material . sticky If other Objects on top of this one are also picked up when this Object is. tag Use type . This object's type. Read only. tooltip If the tooltip opens when a pointer hovers over the object. Tooltips display name and description. type This object's type. Read only. use_gravity If gravity affects this object. use_grid If snapping to grid is enabled or not. use_hands If this object can be held in a hand zone. use_rotation_value_flip Switches the axis an Object rotates around when flipped. use_snap_points If snap points are used or ignored. value The value of the object for summing up selected objects. Only works if the apropriate bits are set in obj.value_flags value_flags A bit field, objects with overlapping value_flag bits are counted together when selected. Bug The value_flags and value member variables do not persist when the object is reloaded (such as loading a save and entering/exiting containers). These member variables are classes of their own, and have their own member variables. Each one is for a special type of Object. Variable Name Description AssetBundle An AssetBundle , which is a type of custom object made in Unity. Book A Book , which is the in-game Custom PDF object. Browser A Browser , which is the in-game Tablet object. Clock A Clock , which is the in-game digital clock. Counter A Counter , which is the in-game digital counter. RPGFigurine An RPGFigurine , which is an in-game animated figurine. TextTool A TextTool , which is an in-game text display system. Function Summary Transform Functions These functions handle the physical attributes of an Object: Position, Rotation, Scale, Bounds, Velocity. In other words, moving objects around as well as getting information on how they are moving. Function Name Description Return addForce( vector, force_type) Adds force to an object in a directional Vector. addTorque( vector, force_type) Adds torque to an object in a rotational Vector. getAngularVelocity() Returns a Vector of the current angular velocity. getBounds() Returns a Vector describing the size of an object in Global terms. getBoundsNormalized() Returns a Vector describing the size of an object in Global terms, as if it was rotated to {0,0,0}. getPosition() Returns a Vector of the current World Position . getPositionSmooth() Returns a Vector of the current smooth move target if the object is moving, otherwise returns nil. getRotation() Returns a Vector of the current rotation. getRotationSmooth() Returns a Vector of the current smooth rotation target if the object is moving, otherwise returns nil. getScale() Returns a Vector of the current scale. getTransformForward() Returns a Vector of the forward direction of this object. getTransformRight() Returns a Vector of the right direction of this object. getTransformUp() Returns a Vector of the up direction of this object. getVelocity() Returns a Vector of the current velocity. isSmoothMoving() Indicates if an object is traveling as part of a Smooth move. Smooth moving is performed by setPositionSmooth and setRotationSmooth. positionToLocal( vector) Returns a Vector after converting a world Vector (World Position) to a local Vector ( Local Position ). positionToWorld( vector) Returns a Vector after converting a local Vector (Local Position) to a world Vector ( World Position ). rotate( vector) Rotates Object smoothly in the direction of the given Vector. scale( vector or ) Scales Object by a multiple. setAngularVelocity( vector) Sets a Vector as the current angular velocity. setPosition( vector) Instantly moves an Object to the given Vector. The Vector is interpreted as World Position . setPositionSmooth( vector, collide, fast) Moves the Object smoothly to the given Vector. The Vector is interpreted as World Position . setRotation( vector) Instantly rotates an Object to the given Vector. setRotationSmooth( vector, collide, fast) Rotates the Object smoothly to the given Vector. setScale( vector) Sets a Vector as the current scale. setVelocity( vector) Sets a Vector as the current velocity. translate( vector) Smoothly moves Object by the given Vector offset. Tag Functions These functions deal with the Tags attached to the object. An individual tag is reprented by a , and is functionally case-insensitive. Function Name Description Return addTag( tag) Attaches the given tag to the object. getTags() Returns a Table of the tags attached to the object. hasAnyTag() Returns whether the object has any attached tags. hasMatchingTag( other) Returns whether the other object shares at least one attached tag with this object. hasTag( ) Returns whether the given tag is attached to the object. setTags( table) Sets the tags attached to the object. removeTag( ) Removes the given tag from the object. If you want to create your own system in which object tags govern the interactions, the canonical logic is that if the system has no tags it interacts with everything, but if it has any tags then it only interacts with objects which share one of them. i.e. (assuming the system is represented by an in-game object): allow_interaction = not system . hasAnyTag () or system . hasMatchingTag ( object ) UI Functions A new UI system was added to Tabletop Simulator which allows for more flexibility in the creation of UI elements on Objects. The old system (Classic UI) and new system (Custom UI) both work, and each has its own strengths. Classic UI These functions allow for the creation/editing/removal of functional buttons and text inputs which themselves trigger code within your scripts. These buttons/inputs are attached to the object they are created on. Function Name Description Return clearButtons() Removes all scripted buttons. clearInputs() Removes all scripted inputs. createButton( parameters) Creates a scripted button attached to the Object. createInput( parameters) Creates a scripted input attached to the Object. editButton( parameters) Modify an existing button. editInput( parameters) Modify an existing input. getButtons() Returns a Table of all buttons on this Object. getInputs() Returns a Table of all inputs on this Object. removeButton( index) Removes a specific button. removeInput( index) Removes a specific button. Custom UI Custom UI gives you a wide variety of element types, not just buttons and inputs, to place onto an Object. It is an extension of the UI class, and details on its use can be found on the UI page . Get Functions These functions obtain information from an object. Function Name Description Return getAttachments() Returns a table in the same format as getObjects() for containers. getColorTint() Color tint. getCustomObject() Returns a Table with the Custom Object information of a Custom Object. getData() Returns a table representation of the object, as in getJSON() , but before being serialized. Works with spawnObjectData() . getDescription() Description, also shows as part of Object's tooltip. getFogOfWarReveal() Settings impacting Fog of War being revealed. getGMNotes() Game Master Notes only visible for Player Color Black. getGUID() String of the Object's unique identifier. getJSON() Returns a serialization of the JSON string which represents this item. Works with spawnObjectJSON() . getJoints() Returns information on any joints attached to this object. getLock() If the Object is locked. getName() Name, also shows as part of Object's tooltip. getObjects() Returns a Table of Objects in the script zone/bag/deck. getQuantity() How many objects are in the stack. Returns -1 if the Object is not a stack. getRotationValue() Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice). getRotationValues() Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice). getSelectingPlayers() Returns a table of the player colors currently selecting the object. getStateId() Current state ID (index) an object is in. Returns -1 if there are no other states. State ids (indexes) start at 1. getStates() Returns a Table of information on the states of an Object. getValue() Object value. What the value represents depends on what type of Object this function is used on. isDestroyed() Returns true if an Object is (or will be) destroyed. Set Functions These functions apply action to an object. They take some property in order to work. Function Name Description Return setColorTint( Color) Sets the Color tint. setCustomObject( parameters) Sets a custom Object's properties. setDescription( description) Sets a description for an Object. Shows in tooltip after delay. setFogOfWarReveal( fog_settings) Establish the settings and enable/disable an Object's revealing of Fog of War . setGMNotes( notes) Sets Game Master Notes only visible for Player Color Black. setLock( lock) Sets if an object is locked in place. setName( name) Sets a name for an Object. Shows in tooltip. setRotationValues( rotation_values) Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). setState( state_id) Sets state of an Object. State ids (indexes) start at 1. setValue( value) Sets an Int as the value. What the value represents depends on what type of Object it is. Action Function These functions perform general actions on objects. Function Name Description Return addAttachment( Object) The Object supplied as param is destroyed and becomes a dummy Object child. addContextMenuItem( label, toRunFunc, keep_open) Adds a menu item to the objects right-click context menu. clearContextMenu() Clears all menu items added by function addContextMenuItem . removeAttachment( index) Removes a child with the given index. Use getAttachments() to find out the index property. removeAttachments() Detaches the children of this Object. Returns a table of object references destroyAttachment( index) Destroys an attachment with the given index. destroyAttachments() Destroys all attachments. addToPlayerSelection( player_color) Adds object to player's selection. removeFromPlayerSelection( player_color) Removes object from player's selection. flip() Flips Object over. clone( parameters) Copy/Paste this Object, returning a reference to the new Object. cut( count) Cuts (splits) a deck at the given card count. deal( number, player_color, index) Deals Objects. Will deal from decks/bags/stacks/individual items. dealToColorWithOffset( offset, flip, player_color) Deals from a deck to a position relative to the hand zone. destruct() Destroys Object. Allows for self.destruct() . drop() Forces an Object, if held by a player, to be dropped. highlightOn( color, duration) Creates a highlight around an Object. highlightOff( color) Removes a highlight from around an Object. jointTo( object, parameters) Joints objects together, in the same way the Joint tool does. putObject( put_object) Places an object into a container (chip stacks/bags/decks). randomize( color) Shuffles deck/bag, rolls dice/coin, lifts other objects into the air. Same as pressing R by default. If the optional parameter color is used, this function will trigger onObjectRandomized() , passing that player color. registerCollisions( stay) Registers this object for Global collision events. reload() Returns Object reference of itself after it respawns itself. reset() Resets this Object. Resetting a Deck brings all the Cards back into it. Resetting a Bag clears its contents (works for both Loot and Infinite Bags). roll() Rolls dice/coins. shuffle() Shuffles/shakes up contents of a deck or bag. shuffleStates() Returns an Object reference to a new state after randomly selecting and changing to one. split( piles) Splits a deck, as evenly as possible, into a number of piles. spread( distance) Uses the spread action on a deck. takeObject( parameters) Takes an object out of a container (bag/deck/chip stack), returning a reference to the object that was taken out. unregisterCollisions() Unregisters this object for Global collision events. Hide Functions These functions can hide Objects, similar to how hand zones or hidden zones do. Function Name Description Return setHiddenFrom( players) Hides the Object from the specified players, as if it were in a hand zone. setInvisibleTo( players) Hides the Object from the specified players, as if it were in a hidden zone. attachHider( id, hidden, players) A more advanced version of setHiddenFrom(...) . attachInvisibleHider( id, hidden, players) A more advanced version of setInvisibleTo(...) . Global Function The functions can be used on Objects, but can also be used on the game world using Global . Examples of Using Global and Object self.getSnapPoints() gets snap points attached to that Object. Global.getSnapPoints() gets snap points not attached to any specific Object but instead are attached to the game world. Function Name Description Return addDecal( parameters) Add a Decal onto an object or the game world. call( func_name, func_params) Used to call a Lua function on another entity. getDecals() Returns information on all decals attached to this object or the world. getLuaScript() Get a Lua script as a string from the entity. getSnapPoints() Returns a table of sub-tables, each sub-table representing one snap point. getTable( table_name) Data value of a variable in another Object's script. Can only return a table. getVar( var_name) Data value of a variable in another entity's script. Cannot return a table. getVectorLines() Returns Table of data representing the current Vector Lines on this entity. See setVectorLines for table format. setDecals( parameters) Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. setLuaScript( script) Input a string as an entity's Lua script. Generally only used after spawning a new Object. setSnapPoints( parameters) Spawns snap points from a list of parameters. setTable( func_name, data) Creates/updates a variable in another entity's script. Only used for tables. setVar( func_name, data) Creates/updates a variable in another entity's script. Cannot set a table. setVectorLines( parameters) Spawns Vector Lines from a list of parameters on this entity. Function Details Transform Function Details addForce(...) Adds force to an object in a directional Vector. addForce(vector, force_type) vector : A Vector of the direction and magnitude of force. force_type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change) addTorque(...) Adds torque to an object in a rotational Vector. addTorque(vector, force_type) vector : A Vector of the direction and magnitude of rotational force. force_type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change) getBounds() Returns a Table of Vector information describing the size of an object in Global terms. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } } getBoundsNormalized() Returns a Table of Vector information describing the size of an object in Global terms, as if it was rotated to {0,0,0}. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } } getScale() Returns a Vector of the current scale. Scale is not an absolute measurement, it is a multiple of the Object's default model size. So {x=2, y=2, z=2} would be a model twice its default size, not 2 units large. getTransformForward() Returns a Vector of the forward direction of this Object. The direction is relative to how the object is facing. -- Example of moving forward 5 units function onLoad () distance = 5 pos_target = self . getTransformForward () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end getTransformRight() Returns a Vector of the forward direction of this object. The direction is relative to how the object is facing. -- Example of moving right 5 units function onLoad () distance = 5 pos_target = self . getTransformRight () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end getTransformUp() Returns a Vector of the up direction of this Object. The direction is relative to how the object is facing. -- Example of moving up 5 units function onLoad () distance = 5 pos_target = self . getTransformUp () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end positionToLocal(...) Returns a Vector after converting a world vector to a local Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The world position to convert into a local position. positionToWorld(...) Returns a Vector after converting a local Vector to a world Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The local position to convert into a world position. rotate(...) Rotates Object smoothly in the direction of the given Vector. This does not set the Object to face a specific rotation, it rotates the Object around by the number of degrees given for x/y/z. rotate(vector) vector : The amount of x/y/z to rotate by. --Rotates object 90 degrees around its Y axis self . rotate ({ x = 0 , y = 90 , z = 0 }) scale(...) Scales Object by a multiple. This does not set the Object to a specific scale, it scales the Object by the given multiple. scale(scale) scale : Multiplier for scale. {x=1, y=1, z=1} would not change the scale. scale(scale) scale : Multiplier for scale which is applied to the X/Y/Z. 1 would not change the scale. -- Both examples work to scale an object to be twice its current scale self . scale ({ x = 2 , y = 2 , z = 2 }) self . scale ( 2 ) setPositionSmooth(...) Moves the Object smoothly to the given Vector. setPositionSmooth(vector, collide, fast) vector : A positional Vector. collide : If the Object will collide with other Objects while moving. fast : If the Object is moved quickly. setRotationSmooth(...) Rotates the Object smoothly to the given Vector. setRotationSmooth(vector, collide, fast) vector : A rotational Vector. collide : If the Object will collide with other Objects while rotating. fast : If the Object is rotated quickly. UI Function Details createButton(...) Creates a scripted button attached to the Object. Scripted buttons are buttons that can be clicked while in-game that trigger a function in a script. Button Tips Buttons can not be clicked from their back side. Buttons can not be clicked if there is another object between the pointer and the button. This does not include the Object the button is attached to. Buttons are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. A button width/height of 0 will cause the button not to be drawn, but its label will be. This can be a way to attach text to an Object. You cannot assign an index to a button. It is given one automatically. createButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.click_function : A String of the function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. Optional, Defaults to Global. parameters.label : Text that appears on the button. Optional, defaults to an empty string. parameters.position : Where the button appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the button is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the button, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the button will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the button will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the clickable button. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the label text. Optional, defaults to {r=0, g=0, b=0}. parameters.hover_color : A Color for the background during mouse-over. Optional. parameters.press_color : A Color for the background when clicked. Optional. parameters.tooltip : Popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. click_function(obj, player_clicker_color, alt_click) The click function which is activated by clicking this button has its own parameters it is passed automatically. obj : The Object the button is attached to. player_clicker_color : Player Color of the player that pressed the button. alt_click : True if a button other than left-click was used to click the button. function onLoad () params = { click_function = \"click_func\" , function_owner = self , label = \"Test\" , position = { 0 , 1 , 0 }, rotation = { 0 , 180 , 0 }, width = 800 , height = 400 , font_size = 340 , color = { 0.5 , 0.5 , 0.5 }, font_color = { 1 , 1 , 1 }, tooltip = \"This text appears on mouseover.\" , } self . createButton ( params ) end function click_func ( obj , color , alt_click ) print ( obj ) print ( color ) print ( alt_click ) end Bug Button scale currently distorts button height and width if the button is rotated at anything besides {0,0,0} . createInput(...) Creates a scripted input attached to the Object. Scripted inputs are boxes you can click inside of in-game to input/edit text. Every letter typed triggers the function. The bool that is returned as part of the input_function allows you to determine when a player has finished editing the input. Input Tips Inputs can not be clicked from their back side. Inputs can not be clicked if there is another object between the pointer and the inputs. This does not include the Object the input is attached to. Inputs are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. Font that does not fit in the input window's width/height does NOT display. To know how much height you need for each line, the formula is (font_size * # of lines) + 23 . In other words, multiply how many lines of text you want to display by your font_size and add 23. That is your height value. You cannot assign an index to an input. It is given one automatically. createInput(parameters) parameters : A Table containing the information used to spawn the input. parameters.input_function : A String of the function's name that will be run when a key is used or when it is deselected. parameters.function_owner : The Object which contains the input_function function. Optional, Defaults to Global. parameters.label : Text that appears as greyed out text when there is no value in the input. Optional, defaults to an empty string. parameters.position : Where the input appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the input is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the input, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the input will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the input will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label/value font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the input's background. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the value text. Optional, defaults to {r=0, g=0, b=0}. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. parameters.alignment : How text is aligned in the input box. Optional, defaults to 1. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : Text entered into the input. Optional, defaults to an empty string. parameters.validation : What characters can be input into the input value field. Optional, defaults to 1. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : How the pressing of \"tab\" is handled when inputting. Optional, defaults to 1. 1 : None 2 : Select Next Input 3 : Indent input_function(obj, player_clicker_color, input_value, selected) The click function which is activated by editing the text in this input has its own parameters it is passed automatically. obj : The Object the input is attached to. player_clicker_color : Player Color of the player that has selected/edited the input. input_value : Text currently in the input. selected : If the value box is still being edited or not. function onLoad () self . createInput ({ input_function = \"input_func\" , function_owner = self , label = \"Gold\" , alignment = 4 , position = { x = 0 , y = 1 , z = 0 }, width = 800 , height = 300 , font_size = 323 , validation = 2 , }) end function input_func ( obj , color , input , stillEditing ) print ( input ) if not stillEditing then print ( \"Finished editing.\" ) end end editButton(...) Modify an existing button. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited button's element to remain. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. editButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.index : Index of the button you want to edit. parameters.click_function : Function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. parameters.label : Text that appears on the button. parameters.position : Where the button appears, relative to the Object's center. parameters.rotation : How the button is rotated, relative to the Object's rotation. parameters.scale : Scale of the button, relative to the Object's scale. parameters.width : How wide the button will be, relative to the Object. parameters.height : How tall the button will be, relative to the Object. parameters.font_size : Size the label font will be, relative to the Object. parameters.color : A Color for the clickable button. parameters.font_color : A Color for the label text. parameters.hover_color : A Color for the background during mouse-over. parameters.press_color : A Color for the background when clicked. parameters.tooltip : Text of a popup of text, similar to how an Object's name is displayed on mouseover. self . editButton ({ index = 0 , label = \"New Label\" }) editInput(...) Modify an existing input. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited input's element to remain. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. editInput(parameters) All fields besides index are optional. If not used, the element will default to the element's current setting. parameters : A Table containing the information used to spawn the input. parameters.index : Index of the input you want to edit. parameters.input_function : The function's name that will be run when the input is selected. parameters.function_owner : The Object which contains the input_function function. parameters.label : Text that appears as greyed out text when there is no value in the input. parameters.position : Where the input appears, relative to the Object's center. parameters.rotation : How the input is rotated, relative to the Object's rotation. parameters.scale : Scale of the input, relative to the Object's scale. parameters.width : How wide the input will be, relative to the Object. parameters.height : How tall the input will be, relative to the Object. parameters.font_size : Size the label/value font will be, relative to the Object. parameters.color : A Color for the input's background. parameters.font_color : A Color for the value text. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. parameters.alignment : How text is aligned in the input box. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : A String of the text entered into the input. parameters.validation : An Int which determines what characters can be input into the value. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : An Int which determines how pressing tab is handled when inputting. 1 : None 2 : Select Next Input 3 : Indent self . editInput ({ index = 0 , value = \"New Value\" }) getButtons() Returns a Table of all buttons on this Object. The Table contains parameters tables with the same keys as seen in the createButton section, except each Table of parameters also contains an index entry. This is used to identify each button, used by editButton and removeButton . Indexes start at 0. getInputs() Returns a Table of all inputs on this Object. The Table contains parameters tables with the same keys as seen in the createInput section, except each Table of parameters also contains an index entry. This is used to identify each input, used by editInput and removeInput . Indexes start at 0. removeButton(...) Removes a specific button. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeButton(index) index : Button index to remove. removeInput(...) Removes a specific input. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeInput(index) index : Input index to remove. Get Function Details getCustomObject() Returns a Table with the Custom Object information of a Custom Object. See the Custom Game Objects page for the kind of information returned. -- Example returned Table for a custom token { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } Jigsaw Puzzles If you use getCustomObject() on a puzzle piece, it will also return desired_position , which is its position if the puzzle is \"solved\". You can use this to determine where to put the piece. getFogOfWarReveal() Settings impacting Fog of War being revealed. In the example returned table, these are the default values of any object. Color Selection \"Black\" and \"All\" are synonymous for Fog of War. Either means that all players can see the revealed area when reveal = true . -- Example returned Table for a custom token { reveal = false , color = 'All' , range = 5 } getJoints() Returns information on any joints attached to this object. This information included the GUID of the other objects attached via the joints. This function returns a table of sub-tables, each sub-table representing one joint. Example of a return table of an object with 2 joints: { { type = \"Spring\" , joint_object_guid = \"555555\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, { type = \"Spring\" , joint_object_guid = \"888888\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, } Example of printing the first sub-table's information: local jointsInfo = self . getJoints () for k , v in pairs ( jointsInfo [ 1 ]) do print ( k , \": \" , v ) end getObjects() Returns a Table of objects in the script zone/bag/deck. What it returns varies depending on the type of Object it is used on. If an Object is inside of a container, it does not exist in-game. As a result, you only get data on each Object, not an Object reference. Return Table by Object Type Scripting Zone Returns a Table of Object references to every object in the scripting zone. { object_1 , object_2 , } Bag or Deck Returns a Table of sub-Tables, each sub-Table containing data on 1 bagged item. Indexes start at 0. index : Index of the item, represents the item's order in the container. name : Name of the item. description : Description of the item. guid : GUID of the item. gm_notes : GM Notes on the item. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. { { name = \"Object Name\" , description = \"Object Description\" , guid = \"AAA111\" , index = 0 , lua_script = \"Any Lua Script On This Object\" , lua_script_state = \"Any JSON Save Data On This Object\" }, } This function is often used with takeObject(...) to remove objects from containers. getRotationValue() Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice) and are set using scripting or the Gizmo tool. The value returned is for the rotation that is closest to being pointed \"up\". The returned value will either be a number or a string, depending on the value that was given to that rotation. local value = self . getRotationValue () print ( value ) getRotationValues() Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice) based on which side is pointed \"up\". It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. You can manually assign rotation values to objects using the Rotation Value Gizmo tool (in the left side Gizmo menu) or using setRotationValues(...) . Return Table The returned Table contains sub-Tables, each sub-Table containing these 2 key/value pairs. value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation : Rotation of the Object that best represents the given value pointing up. -- Example returned Table for a coin { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, } getStates() Returns a Table of information on the states of an Object. Stated Objects have ids (indexes) starting with 1. The returned table will NOT include data on the current state. Return Table Returns a table of sub-tables. Each sub-table represents one other state. name : Name of the item. description : Description of the item. guid : GUID of the item. id : Index of the item, represents the item's order in the states. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. -- Example returned Table { { name = \"First State\" , description = \"\" , guid = \"AAA111\" , id = 1 , lua_script = \"\" , lua_script_state = \"\" , }, { name = \"Second State\" , description = \"\" , guid = \"BBB222\" , id = 2 , lua_script = \"\" , lua_script_state = \"\" , }, } getValue() Gets a value. What the value represents depends on what type of Object this function is used on. Object Value Clock Returns Int of stopwatch/timer current time (in seconds) . Counter Returns Int of counter value. Rotation Value Returns Int of the face-up value. For objects with rotation values set using setRotationValues this is an index into the table of rotation values. Hidden Zone Returns String of the Player Color of the zone. Poker Chip Returns Int of the face value. Does not work on custom chips. Tablet Returns String of the current URL. Set Function Details setCustomObject(...) Sets a custom Object's properties. It can be used after spawnObject or on an already existing custom Object. If used on an already existing custom Object, you must use reload on the object after setCustomObject for the changes to be displayed. setCustomObject(parameters) The Table of parameters varies, depending on which type of custom Object it is. See the Custom Game Objects page for the parameters needed. -- Example of a custom token params = { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } obj . setCustomObject ( params ) setFogOfWarReveal(...) Establish the settings and enable/disable an Object's revealing of Fog of War . setFogOfWarReveal(fog_settings) fog_settings : A Table containing information on if/how this Object should reveal Fog of War. reveal : Can the Object currently If this is not used, the current setting for this Object is kept. color : The rotation Vector of the Object that best represents the given value pointing up. If this is not used, the current setting for this Object is kept. \"Black\" means \"visible to all players.\" \"All\" means \"visible to all players.\" range : How far from the Object the reveal effect reaches (radius, inches). If this is not used, the current setting for this Object is kept. -- Example of enabling reveal for all players at 3 units of radius. params = { reveal = true , color = \"Black\" , range = 3 , } self . setFogOfWarReveal ( params ) setRotationValues(...) Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. setRotationValues(rotation_values) rotation_values : A Table containing Tables with the following values. 1 sub-Table per \"face\". rotation_values.value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation_values.rotation : The rotation Vector of the Object that best represents the given value pointing up. -- Example setting of rotation values for a coin rotation_values = { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, } self . setRotationValues ( rotation_values ) setValue(...) Sets a value on an Object. What the value represents depends on what type of Object it is. Object Value Clock Set Int for stopwatch/timer current time (in seconds) . Counter Set Int for counter value. Rotation Value Set Int for the face-up value. For objects with rotation values set with setRotationValues this is an index into the table of rotation values. Hidden Zone Set String for the Player Color of the zone. Tablet Set String for the current URL. Action Function Details addContextMenuItem(...) Adds a menu item to the objects right-click context menu. addContextMenuItem(label, toRunFunc, keep_open) label : Label for the menu item. toRunFunc : Execute if menu item is selected. player_color Player Color who selected the menu item. keep_open : Keep context menu open after menu item was selected. Optional, Default: keep_open = false. Close context menu after selection. function onLoad () self . addContextMenuItem ( \"doStuff\" , itemAction ) end function itemAction ( player_color ) print ( player_color ) end clone(...) Copy/Paste this Object. clone(parameters) parameters : A Table with information used when pasting. parameters.position : Where the Object is placed. Optional, defaults to {x=0, y=3, z=0}. parameters.snap_to_grid : If the Object snaps to grid. Optional, defaults to false. cut(...) Cuts (splits) a deck down to a given card. In other words, it counts down from the top of the deck and makes a new deck of that size and puts the remaining cards in the other pile. After the cut, the resulting decks much each have at least 2 cards. This means the parameter used must be between 2 and totalNumberOfCards - 2 . Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. cut(count) count : How many cards down to cut the deck. Optional, if no value is provided the deck is cut in half. Returned table The table that is returned 1 : The lower deck, containing the remaining cards in the deck. 2 : The upper deck, containing count number of cards. newDecks = deck . cut ( 5 ) --A delay would be required here for these next two lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 ) deal(...) Deals Objects to hand zones. Will deal from decks/bags/stacks as well as individual items. If dealing an individual item to a hand zone, it is a good idea to make sure that its Member Variable for use_hands is true . deal(number, player_color, index) number : How many to deal. player_color : The Player Color to deal to. Optional, defaults to an empty string. If not supplied, it will attempt to deal to all seated players. index : Index of hand zone to deal to. Optional, defaults to the first created hand zone. dealToColorWithOffset(...) Deals from a deck to a position relative to the hand zone. dealToColorWithOffset(offset, flip, player_color) offset : The x/y/z offset to deal to around the given hand zone. flip : If the card is flipped over when dealt. player_color : Hand zone Player Color to offset dealing to. -- Example of dealing 2 cards in front of the White player, face up. self . dealToColorWithOffset ({ - 2 , 0 , 5 }, true , \"White\" ) self . dealToColorWithOffset ({ 2 , 0 , 5 }, true , \"White\" ) jointTo(...) Joints objects together, in the same way the Joint tool does. Using obj.jointTo(), with no object or parameter used as arguments, will remove all joints from that Object. jointTo(object, parameters) object : The Object that the selected object will be jointed to. parameters : A table of parameters. Which parameters depends on the joint type. See below for more. All parameters have defaults, the same as the Joint Tool. Example of Fixed: self . jointTo ( obj , { [ \"type\" ] = \"Fixed\" , [ \"collision\" ] = true , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , }) Example of Spring: self . jointTo ( obj , { [ \"type\" ] = \"Spring\" , [ \"collision\" ] = false , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"spring\" ] = 50 , [ \"damper\" ] = 0.1 , [ \"max_distance\" ] = 10 , [ \"min_distance\" ] = 1 }) Example of Hinge: self . jointTo ( obj , { [ \"type\" ] = \"Hinge\" , [ \"collision\" ] = true , [ \"axis\" ] = { 1 , 1 , 1 }, [ \"anchor\" ] = { 1 , 1 , 1 }, [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"motor_force\" ] = 100.0 , [ \"motor_velocity\" ] = 10.0 , [ \"motor_free_spin\" ] = true }) putObject(...) Places an object into a container (chip stacks/bags/decks). If neither Object is a container, but they are able to be combined (like with 2 cards), then they form a deck/stack. putObject(put_object) put_object : An Object to place into the container. Returned Object The container is returned as the Object reference. Either this is the container/deck/stack the other Object was placed into, or the deck/stack that was formed by the putObject action. Putting Cards into Decks When you call this putObject() to put a card into a deck, the card goes into the end of the deck which is closest to it in Y elevation. So, if both the card and the deck are resting on the table, the card will be put at the bottom of the deck. if the card is hovering above the deck, it will be put at the top.\" -- Example of a script on a bag that places Object into itself local obj = getObjectFromGUID ( \"AAA111\" ) self . putObject ( obj ) registerCollisions(...) Registers this object for Global collision events, such as onObjectCollisionEnter . Always returns true . registerCollision(stay) stay : Whether we should register for onObjectCollisionStay . Stay events may negatively impact performance, only set this to true if absolutely necessary. Optional, defaults to `false`. reload() Returns Object reference of itself after it respawns itself. This function causes the Object to be deleted and respawned instantly to refresh it, so its old Object reference will no longer be valid. Most often this is used after using setCustomObject(...) to modify a custom object. split(...) Splits a deck, as evenly as possible, into a number of piles. Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. split(piles) piles : How many piles to split the deck into. Optional, if no value is provided, it is split into two piles. Minimum Value: 2 Maximum Value: Number-Of-Cards-In-Deck / 2 Returned table The number of Objects in the table is equal to the number of decks created by the split. They are ordered so any larger decks come first. The table that is returned 1 : The first deck created 2 : The second deck created 3 : The third deck created (etc) newDecks = deck . split ( 4 ) --A delay would be required here for these next four lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 ) newDecks [ 3 ]. deal ( 1 ) newDecks [ 4 ]. deal ( 1 ) spread(...) Spreads the cards of a deck out on the table. Important Cards take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. spread(distance) distance : How far apart should the cards be. Optional, if no value is provided, they will be 0.6 inches apart. Negative values will spread to the left instead of the right. Returned table The number of Objects in the table is equal to the number of cards in the deck. They are returned in the order they were in the deck. The table that is returned 1 : The first card in the deck 2 : The second card in the deck 3 : The third card in the deck (etc) takeObject(...) Takes an object out of a container (bag/deck/chip stack), returning a reference to the object that was taken. Objects that are taken out of a container will take one or more frames to spawn. Certain interactions (e.g. physics) will not be able to take place until the object has finished spawning. takeObject(parameters) parameters : A Table of parameters used to determine how takeObject will act. parameters.position : A Vector of the position to place Object. Optional, defaults to container's position + 2 on the x axis. parameters.rotation : A Vector of the rotation of the Object. Optional, defaults to the container's rotation. parameters.flip : If the Object is flipped over. Optional, defaults to false. Only used with decks, not bags/stacks. If rotation is used, flip's Bool will be ignored. parameters.guid : GUID of the Object to take. Optional, no default. Only use index or guid, never both. parameters.index : Index of the Object to take. Optional, no default. Only use index or guid, never both. parameters.top : If an object is taken from the top (vs bottom). Optional, defaults to true. parameters.smooth : If the taken Object moves smoothly or instantly. Optional, defaults to true. parameters.callback_function : Callback which will be called when the taken object has finished spawnning. Optional, no default. This function takes a single parameter: the object that was taken. Caution Certain containers only exist whilst they have more than one object contained within them (e.g. decks). Once you remove the second last object from a container, the container will be destroyed and the remaining contained object will spawn in its place. After calling takeObject(...) you can check for a remainder . Example Take an object out of a container. As we take it out we'll instruct the object to smooth move (default positioning behavior) to coordinates (0, 5, 0). Additionally, we're going to add a blue highlight on the object we've taken out. local takenObject = container . takeObject ({ position = { x = 0 , y = 5 , z = 0 }, }) takenObject . highlightOn ( 'Blue' ) Advanced example Take an object out of a container, and then apply an upward force (impulse) shooting it into the air. We can only apply an impulse to an object once its (underlying rigid body) has finished spawning Additionally, freshly spawned objects are frozen in place for a single frame. So we need to wait for the taken object to finish spawning (i.e. callback_function ) then wait one more frame before applying the impulse. container . takeObject ({ callback_function = function ( spawnedObject ) Wait . frames ( function () -- We've just waited a frame, which has given the object time to unfreeze. -- However, it's also given the object time to enter another container, if -- it spawned on one. Thus, we must confirm the object is not destroyed. if not spawnedObject . isDestroyed () then spawnedObject . addForce ({ 0 , 30 , 0 }) end end ) end , smooth = false , -- Smooth moving objects cannot have forces applied to them. }) unregisterCollisions(...) Unregisters this object for Global collision events. Returns true if the object was previously registered, false otherwise. unregisterCollision() Hide Function Details setHiddenFrom(...) Hides the Object from the specified players, as if it were in a hand zone. Using an empty table will cause the Object to remove the hiding effect. setHiddenFrom(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setHiddenFrom ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card. setInvisibleTo(...) Hides the Object from the specified players, as if it were in a hidden zone. Using an empty table will cause the Object to remove the hiding effect. setInvisibleTo(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setInvisibleTo ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so. attachHider(...) A more advanced version of setHiddenFrom(...) , this function is also used to hide objects as if they were in a hand zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card. attachInvisibleHider(...) A more advanced version of setInvisibleTo(...) , this function is also used to hide objects as if they were in a hidden zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachInvisibleHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachInvisibleHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachInvisibleHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so. Global Function Details addDecal(...) Add a Decal onto an object or the game world. Relative Vectors When using this function, the vector parameters (position, rotation) are relative to what the decal is being placed on. For example, if you put a decal at {0,0,0} on Global, it will attach to the center of the game room. If you do the same to an object, it will place the decal on the origin point of the object. addDecal(parameters) parameters : A Table of parameters used to determine how the function will act. parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local params = { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 0 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = { 1 , 1 , 1 }, } Global . addDecal ( params ) end call(...) Used to call a Lua function on another entity. Var is only returned if the function called has a return . Otherwise return is nil . See example. This function can also be used directly on the game world using Global. call(func_name, func_params) func_name : Function name you want to activate. func_params : A Table containing any data you want to pass to that function. Optional, will not be sent by default. -- Call, used from an entity's script params = { msg = \"Hello world!\" , color = { r = 0.2 , g = 1 , b = 0.2 }, } -- Success would be set to true by the return value in the function success = Global . call ( \"testFunc\" , params ) -- Function in Global function testFunc ( params ) broadcastToAll ( params . msg , params . color ) return true end getDecals() Returns a table of sub-tables, each sub-table representing one decal. Sub-table elements parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. Example returned table: -- If this object had 2 of the same decal on it decalTable = self . getDecals () --[[ This is what the table would look like { { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, } ]] -- -- Accessing the name of of the second entry would look like this print ( decalTable [ 2 ]. name ) getSnapPoints() Returns a table of sub-tables, each sub-table representing one snap point. This function can also be used directly on the game world (game table) using Global. Format of the returned table A table containing numerically indexed sub-tables. Sub-table(s), each representing a snap point: position : Local Position of the snap point. The position is relative to the entity's center. rotation : Local Rotation of the snap point. The rotation is relative to the entity's rotation. rotation_snap : If the snap point is a \"rotation\" snap point. Example: function onLoad () snapPointList = Global . getSnapPoints () log ( snapPointsList ) end Returned table: { { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, } setDecals(...) Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. Removing decals Using this function with an empty table will remove all decals from Global or the object it is used on. Global.setDecals({}) setDecals(parameters) parameters : The main table, which will contain all of the sub-tables. subtable : The sub-table containing each individual decal's information. The sub-tables are unnamed. parameters.subtable.name : The name of the decal being placed. parameters.subtable.url : The file path or URL for the image to be displayed. parameters.subtable.position : A Vector of the position to place Object. parameters.subtable.rotation : A Vector of the rotation of the Object. parameters.subtable.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local parameters = { { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { - 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, } Global . setDecals ( parameters ) end setSnapPoints(...) Spawns snap points from a list of parameters. This function can also be used on the game world (game table) itself using Global. setSnapPoints(parameters) parameters : A table containing numerically indexed sub-tables. sub-table : position : Local Position of the snap point. This is relative to the entity's position. Optional, defaults to {0,0,0}. rotation : Local Rotation of the snap point. This is relative to the entity's rotation. Optional, defaults to {0,0,0}. rotation_snap : If the snap point is a \"rotation\" snap point. Optional, defaults to false. self . setSnapPoints ({ { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, }) setVectorLines(...) Spawns Vector Lines from a list of parameters. This function can also be used on the game world itself using Global. setVectorLines(parameters) parameters : The table containing each \"line's\" data. Each contiguous line has its own sub-table. points : Table containing Vector positions for each \"point\" on the line. color : Color the line will be. Optional, defaults to {1,1,1}. thickness : How thick the line is (in Unity units). Optional, defaults to default line size (0.1). rotation : Rotation Vector for the line to be angled. Optional, defaults to {0,0,0}. function onLoad () --Make an X above the middle of the table Global . setVectorLines ({ { points = { { 5 , 1 , 5 }, { - 5 , 1 , - 5 } }, color = { 1 , 1 , 1 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, { points = { { - 5 , 1 , 5 }, { 5 , 1 , - 5 } }, color = { 0 , 0 , 0 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, }) end","title":"Object"},{"location":"object/#member-variable-summary","text":"","title":"Member Variable Summary"},{"location":"object/#member-variables","text":"These are variables that objects share. They allow for direct access to an Object's property information without a helping function. Some are read-only. Read Example = isResting = self.resting Write Example = self.resting = true Variable Description Type alt_view_angle When non-zero, the Alt view will use the specified Euler angle to look at the object. angular_drag Angular drag. Unity rigidbody property . auto_raise If an object should be lifted above other objects to avoid collision when held by a player. bounciness Bounciness, value of 0-1. Unity physics material . drag Drag. Unity rigidbody property . drag_selectable When false , the object will not be selected by regular (click and drag) selection boxes that are drawn around the object. Players may proceed to override this behavior by holding the \"Shift\" modifier whilst drag selecting. dynamic_friction Dynamic friction, value of 0-1. Unity physics material . grid_projection If grid lines can appear on the Object if visible grids are turned on. guid The 6 character unique Object identifier within Tabletop Simulator. It is assigned correctly once the spawning member variable becomes false. held_by_color The Color of the Player that is holding the object. held_flip_index 0-23 value. Changes when a Player hits flip or alt + rotate. held_position_offset Position offset from pointer. held_reduce_force When the Object collides with something while moving this is automatically enabled and reduces the movement force. held_rotation_offset Rotation offset from pointer. held_spin_index 0-23 value. Changes when a Player rotates the Object. hide_when_face_down Hide the Object when face-down as if it were in a hand zone. The face is the \"top\" of the Object, the direction of its positive Y coordinate. Cards/decks default to true . ignore_fog_of_war Makes the object not be hidden by Fog of War . interactable If an object can be interacted with by Players. Other object will still be able to interact with it. is_face_down If an Object is roughly face-down (like with cards). The face is the \"top\" of the Object, the direction of its positive Y coordinate. Read only. loading_custom If the Object's custom elements (images/models/etc) are loading. Read only. locked If the object is frozen in place (preventing physics interactions). mass Mass. Unity rigidbody property . max_typed_number Determines the maximum number of digits which a user may type whilst hovering over an object. As soon as a player types the maximum number of digits, the corresponding behavior (e.g. onObjectNumberTyped / onNumberTyped ) is triggered immediately, improving responsiveness. measure_movement Measure Tool will automatically be used when moving the Object. memo A string you can store info in for an object. name Internal resource name for this Object. Read only, and only useful for spawnObjectJSON() . Generally, you want getName() . pick_up_position The position the Object was picked up at. Read only. pick_up_rotation The rotation the Object was picked up at. Read only. remainder If this object is a container that cannot exist with less than two contained objects (e.g. a deck), taking out the second last contained object will result in the container being destroyed. In its place the last remaining object in the container will be spawned. This variable provides a reference to the remaining object when it is being spawned. Otherwise, it's nil . Read only. resting If an Object is at rest. Unity rigidbody property . script_code The Lua Script on the Object. script_state The saved data on the object. See onSave() . spawning If the Object is finished spawning. Read only. static_friction Static friction, value of 0-1. Unity physics material . sticky If other Objects on top of this one are also picked up when this Object is. tag Use type . This object's type. Read only. tooltip If the tooltip opens when a pointer hovers over the object. Tooltips display name and description. type This object's type. Read only. use_gravity If gravity affects this object. use_grid If snapping to grid is enabled or not. use_hands If this object can be held in a hand zone. use_rotation_value_flip Switches the axis an Object rotates around when flipped. use_snap_points If snap points are used or ignored. value The value of the object for summing up selected objects. Only works if the apropriate bits are set in obj.value_flags value_flags A bit field, objects with overlapping value_flag bits are counted together when selected. Bug The value_flags and value member variables do not persist when the object is reloaded (such as loading a save and entering/exiting containers). These member variables are classes of their own, and have their own member variables. Each one is for a special type of Object. Variable Name Description AssetBundle An AssetBundle , which is a type of custom object made in Unity. Book A Book , which is the in-game Custom PDF object. Browser A Browser , which is the in-game Tablet object. Clock A Clock , which is the in-game digital clock. Counter A Counter , which is the in-game digital counter. RPGFigurine An RPGFigurine , which is an in-game animated figurine. TextTool A TextTool , which is an in-game text display system.","title":"Member Variables"},{"location":"object/#function-summary","text":"","title":"Function Summary"},{"location":"object/#transform-functions","text":"These functions handle the physical attributes of an Object: Position, Rotation, Scale, Bounds, Velocity. In other words, moving objects around as well as getting information on how they are moving. Function Name Description Return addForce( vector, force_type) Adds force to an object in a directional Vector. addTorque( vector, force_type) Adds torque to an object in a rotational Vector. getAngularVelocity() Returns a Vector of the current angular velocity. getBounds() Returns a Vector describing the size of an object in Global terms. getBoundsNormalized() Returns a Vector describing the size of an object in Global terms, as if it was rotated to {0,0,0}. getPosition() Returns a Vector of the current World Position . getPositionSmooth() Returns a Vector of the current smooth move target if the object is moving, otherwise returns nil. getRotation() Returns a Vector of the current rotation. getRotationSmooth() Returns a Vector of the current smooth rotation target if the object is moving, otherwise returns nil. getScale() Returns a Vector of the current scale. getTransformForward() Returns a Vector of the forward direction of this object. getTransformRight() Returns a Vector of the right direction of this object. getTransformUp() Returns a Vector of the up direction of this object. getVelocity() Returns a Vector of the current velocity. isSmoothMoving() Indicates if an object is traveling as part of a Smooth move. Smooth moving is performed by setPositionSmooth and setRotationSmooth. positionToLocal( vector) Returns a Vector after converting a world Vector (World Position) to a local Vector ( Local Position ). positionToWorld( vector) Returns a Vector after converting a local Vector (Local Position) to a world Vector ( World Position ). rotate( vector) Rotates Object smoothly in the direction of the given Vector. scale( vector or ) Scales Object by a multiple. setAngularVelocity( vector) Sets a Vector as the current angular velocity. setPosition( vector) Instantly moves an Object to the given Vector. The Vector is interpreted as World Position . setPositionSmooth( vector, collide, fast) Moves the Object smoothly to the given Vector. The Vector is interpreted as World Position . setRotation( vector) Instantly rotates an Object to the given Vector. setRotationSmooth( vector, collide, fast) Rotates the Object smoothly to the given Vector. setScale( vector) Sets a Vector as the current scale. setVelocity( vector) Sets a Vector as the current velocity. translate( vector) Smoothly moves Object by the given Vector offset.","title":"Transform Functions"},{"location":"object/#tag-functions","text":"These functions deal with the Tags attached to the object. An individual tag is reprented by a , and is functionally case-insensitive. Function Name Description Return addTag( tag) Attaches the given tag to the object. getTags() Returns a Table of the tags attached to the object. hasAnyTag() Returns whether the object has any attached tags. hasMatchingTag( other) Returns whether the other object shares at least one attached tag with this object. hasTag( ) Returns whether the given tag is attached to the object. setTags( table) Sets the tags attached to the object. removeTag( ) Removes the given tag from the object. If you want to create your own system in which object tags govern the interactions, the canonical logic is that if the system has no tags it interacts with everything, but if it has any tags then it only interacts with objects which share one of them. i.e. (assuming the system is represented by an in-game object): allow_interaction = not system . hasAnyTag () or system . hasMatchingTag ( object )","title":"Tag Functions"},{"location":"object/#ui-functions","text":"A new UI system was added to Tabletop Simulator which allows for more flexibility in the creation of UI elements on Objects. The old system (Classic UI) and new system (Custom UI) both work, and each has its own strengths.","title":"UI Functions"},{"location":"object/#classic-ui","text":"These functions allow for the creation/editing/removal of functional buttons and text inputs which themselves trigger code within your scripts. These buttons/inputs are attached to the object they are created on. Function Name Description Return clearButtons() Removes all scripted buttons. clearInputs() Removes all scripted inputs. createButton( parameters) Creates a scripted button attached to the Object. createInput( parameters) Creates a scripted input attached to the Object. editButton( parameters) Modify an existing button. editInput( parameters) Modify an existing input. getButtons() Returns a Table of all buttons on this Object. getInputs() Returns a Table of all inputs on this Object. removeButton( index) Removes a specific button. removeInput( index) Removes a specific button.","title":"Classic UI"},{"location":"object/#custom-ui","text":"Custom UI gives you a wide variety of element types, not just buttons and inputs, to place onto an Object. It is an extension of the UI class, and details on its use can be found on the UI page .","title":"Custom UI"},{"location":"object/#get-functions","text":"These functions obtain information from an object. Function Name Description Return getAttachments() Returns a table in the same format as getObjects() for containers. getColorTint() Color tint. getCustomObject() Returns a Table with the Custom Object information of a Custom Object. getData() Returns a table representation of the object, as in getJSON() , but before being serialized. Works with spawnObjectData() . getDescription() Description, also shows as part of Object's tooltip. getFogOfWarReveal() Settings impacting Fog of War being revealed. getGMNotes() Game Master Notes only visible for Player Color Black. getGUID() String of the Object's unique identifier. getJSON() Returns a serialization of the JSON string which represents this item. Works with spawnObjectJSON() . getJoints() Returns information on any joints attached to this object. getLock() If the Object is locked. getName() Name, also shows as part of Object's tooltip. getObjects() Returns a Table of Objects in the script zone/bag/deck. getQuantity() How many objects are in the stack. Returns -1 if the Object is not a stack. getRotationValue() Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice). getRotationValues() Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice). getSelectingPlayers() Returns a table of the player colors currently selecting the object. getStateId() Current state ID (index) an object is in. Returns -1 if there are no other states. State ids (indexes) start at 1. getStates() Returns a Table of information on the states of an Object. getValue() Object value. What the value represents depends on what type of Object this function is used on. isDestroyed() Returns true if an Object is (or will be) destroyed.","title":"Get Functions"},{"location":"object/#set-functions","text":"These functions apply action to an object. They take some property in order to work. Function Name Description Return setColorTint( Color) Sets the Color tint. setCustomObject( parameters) Sets a custom Object's properties. setDescription( description) Sets a description for an Object. Shows in tooltip after delay. setFogOfWarReveal( fog_settings) Establish the settings and enable/disable an Object's revealing of Fog of War . setGMNotes( notes) Sets Game Master Notes only visible for Player Color Black. setLock( lock) Sets if an object is locked in place. setName( name) Sets a name for an Object. Shows in tooltip. setRotationValues( rotation_values) Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). setState( state_id) Sets state of an Object. State ids (indexes) start at 1. setValue( value) Sets an Int as the value. What the value represents depends on what type of Object it is.","title":"Set Functions"},{"location":"object/#action-function","text":"These functions perform general actions on objects. Function Name Description Return addAttachment( Object) The Object supplied as param is destroyed and becomes a dummy Object child. addContextMenuItem( label, toRunFunc, keep_open) Adds a menu item to the objects right-click context menu. clearContextMenu() Clears all menu items added by function addContextMenuItem . removeAttachment( index) Removes a child with the given index. Use getAttachments() to find out the index property. removeAttachments() Detaches the children of this Object. Returns a table of object references destroyAttachment( index) Destroys an attachment with the given index. destroyAttachments() Destroys all attachments. addToPlayerSelection( player_color) Adds object to player's selection. removeFromPlayerSelection( player_color) Removes object from player's selection. flip() Flips Object over. clone( parameters) Copy/Paste this Object, returning a reference to the new Object. cut( count) Cuts (splits) a deck at the given card count. deal( number, player_color, index) Deals Objects. Will deal from decks/bags/stacks/individual items. dealToColorWithOffset( offset, flip, player_color) Deals from a deck to a position relative to the hand zone. destruct() Destroys Object. Allows for self.destruct() . drop() Forces an Object, if held by a player, to be dropped. highlightOn( color, duration) Creates a highlight around an Object. highlightOff( color) Removes a highlight from around an Object. jointTo( object, parameters) Joints objects together, in the same way the Joint tool does. putObject( put_object) Places an object into a container (chip stacks/bags/decks). randomize( color) Shuffles deck/bag, rolls dice/coin, lifts other objects into the air. Same as pressing R by default. If the optional parameter color is used, this function will trigger onObjectRandomized() , passing that player color. registerCollisions( stay) Registers this object for Global collision events. reload() Returns Object reference of itself after it respawns itself. reset() Resets this Object. Resetting a Deck brings all the Cards back into it. Resetting a Bag clears its contents (works for both Loot and Infinite Bags). roll() Rolls dice/coins. shuffle() Shuffles/shakes up contents of a deck or bag. shuffleStates() Returns an Object reference to a new state after randomly selecting and changing to one. split( piles) Splits a deck, as evenly as possible, into a number of piles. spread( distance) Uses the spread action on a deck. takeObject( parameters) Takes an object out of a container (bag/deck/chip stack), returning a reference to the object that was taken out. unregisterCollisions() Unregisters this object for Global collision events.","title":"Action Function"},{"location":"object/#hide-functions","text":"These functions can hide Objects, similar to how hand zones or hidden zones do. Function Name Description Return setHiddenFrom( players) Hides the Object from the specified players, as if it were in a hand zone. setInvisibleTo( players) Hides the Object from the specified players, as if it were in a hidden zone. attachHider( id, hidden, players) A more advanced version of setHiddenFrom(...) . attachInvisibleHider( id, hidden, players) A more advanced version of setInvisibleTo(...) .","title":"Hide Functions"},{"location":"object/#global-function","text":"The functions can be used on Objects, but can also be used on the game world using Global . Examples of Using Global and Object self.getSnapPoints() gets snap points attached to that Object. Global.getSnapPoints() gets snap points not attached to any specific Object but instead are attached to the game world. Function Name Description Return addDecal( parameters) Add a Decal onto an object or the game world. call( func_name, func_params) Used to call a Lua function on another entity. getDecals() Returns information on all decals attached to this object or the world. getLuaScript() Get a Lua script as a string from the entity. getSnapPoints() Returns a table of sub-tables, each sub-table representing one snap point. getTable( table_name) Data value of a variable in another Object's script. Can only return a table. getVar( var_name) Data value of a variable in another entity's script. Cannot return a table. getVectorLines() Returns Table of data representing the current Vector Lines on this entity. See setVectorLines for table format. setDecals( parameters) Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. setLuaScript( script) Input a string as an entity's Lua script. Generally only used after spawning a new Object. setSnapPoints( parameters) Spawns snap points from a list of parameters. setTable( func_name, data) Creates/updates a variable in another entity's script. Only used for tables. setVar( func_name, data) Creates/updates a variable in another entity's script. Cannot set a table. setVectorLines( parameters) Spawns Vector Lines from a list of parameters on this entity.","title":"Global Function"},{"location":"object/#function-details","text":"","title":"Function Details"},{"location":"object/#transform-function-details","text":"","title":"Transform Function Details"},{"location":"object/#addforce","text":"Adds force to an object in a directional Vector. addForce(vector, force_type) vector : A Vector of the direction and magnitude of force. force_type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change)","title":"addForce(...)"},{"location":"object/#addtorque","text":"Adds torque to an object in a rotational Vector. addTorque(vector, force_type) vector : A Vector of the direction and magnitude of rotational force. force_type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change)","title":"addTorque(...)"},{"location":"object/#getbounds","text":"Returns a Table of Vector information describing the size of an object in Global terms. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } }","title":"getBounds()"},{"location":"object/#getboundsnormalized","text":"Returns a Table of Vector information describing the size of an object in Global terms, as if it was rotated to {0,0,0}. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } }","title":"getBoundsNormalized()"},{"location":"object/#getscale","text":"Returns a Vector of the current scale. Scale is not an absolute measurement, it is a multiple of the Object's default model size. So {x=2, y=2, z=2} would be a model twice its default size, not 2 units large.","title":"getScale()"},{"location":"object/#gettransformforward","text":"Returns a Vector of the forward direction of this Object. The direction is relative to how the object is facing. -- Example of moving forward 5 units function onLoad () distance = 5 pos_target = self . getTransformForward () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end","title":"getTransformForward()"},{"location":"object/#gettransformright","text":"Returns a Vector of the forward direction of this object. The direction is relative to how the object is facing. -- Example of moving right 5 units function onLoad () distance = 5 pos_target = self . getTransformRight () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end","title":"getTransformRight()"},{"location":"object/#gettransformup","text":"Returns a Vector of the up direction of this Object. The direction is relative to how the object is facing. -- Example of moving up 5 units function onLoad () distance = 5 pos_target = self . getTransformUp () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end","title":"getTransformUp()"},{"location":"object/#positiontolocal","text":"Returns a Vector after converting a world vector to a local Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The world position to convert into a local position.","title":"positionToLocal(...)"},{"location":"object/#positiontoworld","text":"Returns a Vector after converting a local Vector to a world Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The local position to convert into a world position.","title":"positionToWorld(...)"},{"location":"object/#rotate","text":"Rotates Object smoothly in the direction of the given Vector. This does not set the Object to face a specific rotation, it rotates the Object around by the number of degrees given for x/y/z. rotate(vector) vector : The amount of x/y/z to rotate by. --Rotates object 90 degrees around its Y axis self . rotate ({ x = 0 , y = 90 , z = 0 })","title":"rotate(...)"},{"location":"object/#scale","text":"Scales Object by a multiple. This does not set the Object to a specific scale, it scales the Object by the given multiple. scale(scale) scale : Multiplier for scale. {x=1, y=1, z=1} would not change the scale. scale(scale) scale : Multiplier for scale which is applied to the X/Y/Z. 1 would not change the scale. -- Both examples work to scale an object to be twice its current scale self . scale ({ x = 2 , y = 2 , z = 2 }) self . scale ( 2 )","title":"scale(...)"},{"location":"object/#setpositionsmooth","text":"Moves the Object smoothly to the given Vector. setPositionSmooth(vector, collide, fast) vector : A positional Vector. collide : If the Object will collide with other Objects while moving. fast : If the Object is moved quickly.","title":"setPositionSmooth(...)"},{"location":"object/#setrotationsmooth","text":"Rotates the Object smoothly to the given Vector. setRotationSmooth(vector, collide, fast) vector : A rotational Vector. collide : If the Object will collide with other Objects while rotating. fast : If the Object is rotated quickly.","title":"setRotationSmooth(...)"},{"location":"object/#ui-function-details","text":"","title":"UI Function Details"},{"location":"object/#createbutton","text":"Creates a scripted button attached to the Object. Scripted buttons are buttons that can be clicked while in-game that trigger a function in a script. Button Tips Buttons can not be clicked from their back side. Buttons can not be clicked if there is another object between the pointer and the button. This does not include the Object the button is attached to. Buttons are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. A button width/height of 0 will cause the button not to be drawn, but its label will be. This can be a way to attach text to an Object. You cannot assign an index to a button. It is given one automatically. createButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.click_function : A String of the function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. Optional, Defaults to Global. parameters.label : Text that appears on the button. Optional, defaults to an empty string. parameters.position : Where the button appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the button is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the button, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the button will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the button will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the clickable button. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the label text. Optional, defaults to {r=0, g=0, b=0}. parameters.hover_color : A Color for the background during mouse-over. Optional. parameters.press_color : A Color for the background when clicked. Optional. parameters.tooltip : Popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. click_function(obj, player_clicker_color, alt_click) The click function which is activated by clicking this button has its own parameters it is passed automatically. obj : The Object the button is attached to. player_clicker_color : Player Color of the player that pressed the button. alt_click : True if a button other than left-click was used to click the button. function onLoad () params = { click_function = \"click_func\" , function_owner = self , label = \"Test\" , position = { 0 , 1 , 0 }, rotation = { 0 , 180 , 0 }, width = 800 , height = 400 , font_size = 340 , color = { 0.5 , 0.5 , 0.5 }, font_color = { 1 , 1 , 1 }, tooltip = \"This text appears on mouseover.\" , } self . createButton ( params ) end function click_func ( obj , color , alt_click ) print ( obj ) print ( color ) print ( alt_click ) end Bug Button scale currently distorts button height and width if the button is rotated at anything besides {0,0,0} .","title":"createButton(...)"},{"location":"object/#createinput","text":"Creates a scripted input attached to the Object. Scripted inputs are boxes you can click inside of in-game to input/edit text. Every letter typed triggers the function. The bool that is returned as part of the input_function allows you to determine when a player has finished editing the input. Input Tips Inputs can not be clicked from their back side. Inputs can not be clicked if there is another object between the pointer and the inputs. This does not include the Object the input is attached to. Inputs are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. Font that does not fit in the input window's width/height does NOT display. To know how much height you need for each line, the formula is (font_size * # of lines) + 23 . In other words, multiply how many lines of text you want to display by your font_size and add 23. That is your height value. You cannot assign an index to an input. It is given one automatically. createInput(parameters) parameters : A Table containing the information used to spawn the input. parameters.input_function : A String of the function's name that will be run when a key is used or when it is deselected. parameters.function_owner : The Object which contains the input_function function. Optional, Defaults to Global. parameters.label : Text that appears as greyed out text when there is no value in the input. Optional, defaults to an empty string. parameters.position : Where the input appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the input is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the input, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the input will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the input will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label/value font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the input's background. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the value text. Optional, defaults to {r=0, g=0, b=0}. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. parameters.alignment : How text is aligned in the input box. Optional, defaults to 1. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : Text entered into the input. Optional, defaults to an empty string. parameters.validation : What characters can be input into the input value field. Optional, defaults to 1. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : How the pressing of \"tab\" is handled when inputting. Optional, defaults to 1. 1 : None 2 : Select Next Input 3 : Indent input_function(obj, player_clicker_color, input_value, selected) The click function which is activated by editing the text in this input has its own parameters it is passed automatically. obj : The Object the input is attached to. player_clicker_color : Player Color of the player that has selected/edited the input. input_value : Text currently in the input. selected : If the value box is still being edited or not. function onLoad () self . createInput ({ input_function = \"input_func\" , function_owner = self , label = \"Gold\" , alignment = 4 , position = { x = 0 , y = 1 , z = 0 }, width = 800 , height = 300 , font_size = 323 , validation = 2 , }) end function input_func ( obj , color , input , stillEditing ) print ( input ) if not stillEditing then print ( \"Finished editing.\" ) end end","title":"createInput(...)"},{"location":"object/#editbutton","text":"Modify an existing button. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited button's element to remain. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. editButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.index : Index of the button you want to edit. parameters.click_function : Function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. parameters.label : Text that appears on the button. parameters.position : Where the button appears, relative to the Object's center. parameters.rotation : How the button is rotated, relative to the Object's rotation. parameters.scale : Scale of the button, relative to the Object's scale. parameters.width : How wide the button will be, relative to the Object. parameters.height : How tall the button will be, relative to the Object. parameters.font_size : Size the label font will be, relative to the Object. parameters.color : A Color for the clickable button. parameters.font_color : A Color for the label text. parameters.hover_color : A Color for the background during mouse-over. parameters.press_color : A Color for the background when clicked. parameters.tooltip : Text of a popup of text, similar to how an Object's name is displayed on mouseover. self . editButton ({ index = 0 , label = \"New Label\" })","title":"editButton(...)"},{"location":"object/#editinput","text":"Modify an existing input. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited input's element to remain. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. editInput(parameters) All fields besides index are optional. If not used, the element will default to the element's current setting. parameters : A Table containing the information used to spawn the input. parameters.index : Index of the input you want to edit. parameters.input_function : The function's name that will be run when the input is selected. parameters.function_owner : The Object which contains the input_function function. parameters.label : Text that appears as greyed out text when there is no value in the input. parameters.position : Where the input appears, relative to the Object's center. parameters.rotation : How the input is rotated, relative to the Object's rotation. parameters.scale : Scale of the input, relative to the Object's scale. parameters.width : How wide the input will be, relative to the Object. parameters.height : How tall the input will be, relative to the Object. parameters.font_size : Size the label/value font will be, relative to the Object. parameters.color : A Color for the input's background. parameters.font_color : A Color for the value text. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. parameters.alignment : How text is aligned in the input box. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : A String of the text entered into the input. parameters.validation : An Int which determines what characters can be input into the value. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : An Int which determines how pressing tab is handled when inputting. 1 : None 2 : Select Next Input 3 : Indent self . editInput ({ index = 0 , value = \"New Value\" })","title":"editInput(...)"},{"location":"object/#getbuttons","text":"Returns a Table of all buttons on this Object. The Table contains parameters tables with the same keys as seen in the createButton section, except each Table of parameters also contains an index entry. This is used to identify each button, used by editButton and removeButton . Indexes start at 0.","title":"getButtons()"},{"location":"object/#getinputs","text":"Returns a Table of all inputs on this Object. The Table contains parameters tables with the same keys as seen in the createInput section, except each Table of parameters also contains an index entry. This is used to identify each input, used by editInput and removeInput . Indexes start at 0.","title":"getInputs()"},{"location":"object/#removebutton","text":"Removes a specific button. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeButton(index) index : Button index to remove.","title":"removeButton(...)"},{"location":"object/#removeinput","text":"Removes a specific input. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeInput(index) index : Input index to remove.","title":"removeInput(...)"},{"location":"object/#get-function-details","text":"","title":"Get Function Details"},{"location":"object/#getcustomobject","text":"Returns a Table with the Custom Object information of a Custom Object. See the Custom Game Objects page for the kind of information returned. -- Example returned Table for a custom token { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } Jigsaw Puzzles If you use getCustomObject() on a puzzle piece, it will also return desired_position , which is its position if the puzzle is \"solved\". You can use this to determine where to put the piece.","title":"getCustomObject()"},{"location":"object/#getfogofwarreveal","text":"Settings impacting Fog of War being revealed. In the example returned table, these are the default values of any object. Color Selection \"Black\" and \"All\" are synonymous for Fog of War. Either means that all players can see the revealed area when reveal = true . -- Example returned Table for a custom token { reveal = false , color = 'All' , range = 5 }","title":"getFogOfWarReveal()"},{"location":"object/#getjoints","text":"Returns information on any joints attached to this object. This information included the GUID of the other objects attached via the joints. This function returns a table of sub-tables, each sub-table representing one joint. Example of a return table of an object with 2 joints: { { type = \"Spring\" , joint_object_guid = \"555555\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, { type = \"Spring\" , joint_object_guid = \"888888\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, } Example of printing the first sub-table's information: local jointsInfo = self . getJoints () for k , v in pairs ( jointsInfo [ 1 ]) do print ( k , \": \" , v ) end","title":"getJoints()"},{"location":"object/#getobjects","text":"Returns a Table of objects in the script zone/bag/deck. What it returns varies depending on the type of Object it is used on. If an Object is inside of a container, it does not exist in-game. As a result, you only get data on each Object, not an Object reference. Return Table by Object Type Scripting Zone Returns a Table of Object references to every object in the scripting zone. { object_1 , object_2 , } Bag or Deck Returns a Table of sub-Tables, each sub-Table containing data on 1 bagged item. Indexes start at 0. index : Index of the item, represents the item's order in the container. name : Name of the item. description : Description of the item. guid : GUID of the item. gm_notes : GM Notes on the item. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. { { name = \"Object Name\" , description = \"Object Description\" , guid = \"AAA111\" , index = 0 , lua_script = \"Any Lua Script On This Object\" , lua_script_state = \"Any JSON Save Data On This Object\" }, } This function is often used with takeObject(...) to remove objects from containers.","title":"getObjects()"},{"location":"object/#getrotationvalue","text":"Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice) and are set using scripting or the Gizmo tool. The value returned is for the rotation that is closest to being pointed \"up\". The returned value will either be a number or a string, depending on the value that was given to that rotation. local value = self . getRotationValue () print ( value )","title":"getRotationValue()"},{"location":"object/#getrotationvalues","text":"Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice) based on which side is pointed \"up\". It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. You can manually assign rotation values to objects using the Rotation Value Gizmo tool (in the left side Gizmo menu) or using setRotationValues(...) . Return Table The returned Table contains sub-Tables, each sub-Table containing these 2 key/value pairs. value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation : Rotation of the Object that best represents the given value pointing up. -- Example returned Table for a coin { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, }","title":"getRotationValues()"},{"location":"object/#getstates","text":"Returns a Table of information on the states of an Object. Stated Objects have ids (indexes) starting with 1. The returned table will NOT include data on the current state. Return Table Returns a table of sub-tables. Each sub-table represents one other state. name : Name of the item. description : Description of the item. guid : GUID of the item. id : Index of the item, represents the item's order in the states. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. -- Example returned Table { { name = \"First State\" , description = \"\" , guid = \"AAA111\" , id = 1 , lua_script = \"\" , lua_script_state = \"\" , }, { name = \"Second State\" , description = \"\" , guid = \"BBB222\" , id = 2 , lua_script = \"\" , lua_script_state = \"\" , }, }","title":"getStates()"},{"location":"object/#getvalue","text":"Gets a value. What the value represents depends on what type of Object this function is used on. Object Value Clock Returns Int of stopwatch/timer current time (in seconds) . Counter Returns Int of counter value. Rotation Value Returns Int of the face-up value. For objects with rotation values set using setRotationValues this is an index into the table of rotation values. Hidden Zone Returns String of the Player Color of the zone. Poker Chip Returns Int of the face value. Does not work on custom chips. Tablet Returns String of the current URL.","title":"getValue()"},{"location":"object/#set-function-details","text":"","title":"Set Function Details"},{"location":"object/#setcustomobject","text":"Sets a custom Object's properties. It can be used after spawnObject or on an already existing custom Object. If used on an already existing custom Object, you must use reload on the object after setCustomObject for the changes to be displayed. setCustomObject(parameters) The Table of parameters varies, depending on which type of custom Object it is. See the Custom Game Objects page for the parameters needed. -- Example of a custom token params = { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } obj . setCustomObject ( params )","title":"setCustomObject(...)"},{"location":"object/#setfogofwarreveal","text":"Establish the settings and enable/disable an Object's revealing of Fog of War . setFogOfWarReveal(fog_settings) fog_settings : A Table containing information on if/how this Object should reveal Fog of War. reveal : Can the Object currently If this is not used, the current setting for this Object is kept. color : The rotation Vector of the Object that best represents the given value pointing up. If this is not used, the current setting for this Object is kept. \"Black\" means \"visible to all players.\" \"All\" means \"visible to all players.\" range : How far from the Object the reveal effect reaches (radius, inches). If this is not used, the current setting for this Object is kept. -- Example of enabling reveal for all players at 3 units of radius. params = { reveal = true , color = \"Black\" , range = 3 , } self . setFogOfWarReveal ( params )","title":"setFogOfWarReveal(...)"},{"location":"object/#setrotationvalues","text":"Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. setRotationValues(rotation_values) rotation_values : A Table containing Tables with the following values. 1 sub-Table per \"face\". rotation_values.value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation_values.rotation : The rotation Vector of the Object that best represents the given value pointing up. -- Example setting of rotation values for a coin rotation_values = { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, } self . setRotationValues ( rotation_values )","title":"setRotationValues(...)"},{"location":"object/#setvalue","text":"Sets a value on an Object. What the value represents depends on what type of Object it is. Object Value Clock Set Int for stopwatch/timer current time (in seconds) . Counter Set Int for counter value. Rotation Value Set Int for the face-up value. For objects with rotation values set with setRotationValues this is an index into the table of rotation values. Hidden Zone Set String for the Player Color of the zone. Tablet Set String for the current URL.","title":"setValue(...)"},{"location":"object/#action-function-details","text":"","title":"Action Function Details"},{"location":"object/#addcontextmenuitem","text":"Adds a menu item to the objects right-click context menu. addContextMenuItem(label, toRunFunc, keep_open) label : Label for the menu item. toRunFunc : Execute if menu item is selected. player_color Player Color who selected the menu item. keep_open : Keep context menu open after menu item was selected. Optional, Default: keep_open = false. Close context menu after selection. function onLoad () self . addContextMenuItem ( \"doStuff\" , itemAction ) end function itemAction ( player_color ) print ( player_color ) end","title":"addContextMenuItem(...)"},{"location":"object/#clone","text":"Copy/Paste this Object. clone(parameters) parameters : A Table with information used when pasting. parameters.position : Where the Object is placed. Optional, defaults to {x=0, y=3, z=0}. parameters.snap_to_grid : If the Object snaps to grid. Optional, defaults to false.","title":"clone(...)"},{"location":"object/#cut","text":"Cuts (splits) a deck down to a given card. In other words, it counts down from the top of the deck and makes a new deck of that size and puts the remaining cards in the other pile. After the cut, the resulting decks much each have at least 2 cards. This means the parameter used must be between 2 and totalNumberOfCards - 2 . Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. cut(count) count : How many cards down to cut the deck. Optional, if no value is provided the deck is cut in half. Returned table The table that is returned 1 : The lower deck, containing the remaining cards in the deck. 2 : The upper deck, containing count number of cards. newDecks = deck . cut ( 5 ) --A delay would be required here for these next two lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 )","title":"cut(...)"},{"location":"object/#deal","text":"Deals Objects to hand zones. Will deal from decks/bags/stacks as well as individual items. If dealing an individual item to a hand zone, it is a good idea to make sure that its Member Variable for use_hands is true . deal(number, player_color, index) number : How many to deal. player_color : The Player Color to deal to. Optional, defaults to an empty string. If not supplied, it will attempt to deal to all seated players. index : Index of hand zone to deal to. Optional, defaults to the first created hand zone.","title":"deal(...)"},{"location":"object/#dealtocolorwithoffset","text":"Deals from a deck to a position relative to the hand zone. dealToColorWithOffset(offset, flip, player_color) offset : The x/y/z offset to deal to around the given hand zone. flip : If the card is flipped over when dealt. player_color : Hand zone Player Color to offset dealing to. -- Example of dealing 2 cards in front of the White player, face up. self . dealToColorWithOffset ({ - 2 , 0 , 5 }, true , \"White\" ) self . dealToColorWithOffset ({ 2 , 0 , 5 }, true , \"White\" )","title":"dealToColorWithOffset(...)"},{"location":"object/#jointto","text":"Joints objects together, in the same way the Joint tool does. Using obj.jointTo(), with no object or parameter used as arguments, will remove all joints from that Object. jointTo(object, parameters) object : The Object that the selected object will be jointed to. parameters : A table of parameters. Which parameters depends on the joint type. See below for more. All parameters have defaults, the same as the Joint Tool. Example of Fixed: self . jointTo ( obj , { [ \"type\" ] = \"Fixed\" , [ \"collision\" ] = true , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , }) Example of Spring: self . jointTo ( obj , { [ \"type\" ] = \"Spring\" , [ \"collision\" ] = false , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"spring\" ] = 50 , [ \"damper\" ] = 0.1 , [ \"max_distance\" ] = 10 , [ \"min_distance\" ] = 1 }) Example of Hinge: self . jointTo ( obj , { [ \"type\" ] = \"Hinge\" , [ \"collision\" ] = true , [ \"axis\" ] = { 1 , 1 , 1 }, [ \"anchor\" ] = { 1 , 1 , 1 }, [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"motor_force\" ] = 100.0 , [ \"motor_velocity\" ] = 10.0 , [ \"motor_free_spin\" ] = true })","title":"jointTo(...)"},{"location":"object/#putobject","text":"Places an object into a container (chip stacks/bags/decks). If neither Object is a container, but they are able to be combined (like with 2 cards), then they form a deck/stack. putObject(put_object) put_object : An Object to place into the container. Returned Object The container is returned as the Object reference. Either this is the container/deck/stack the other Object was placed into, or the deck/stack that was formed by the putObject action. Putting Cards into Decks When you call this putObject() to put a card into a deck, the card goes into the end of the deck which is closest to it in Y elevation. So, if both the card and the deck are resting on the table, the card will be put at the bottom of the deck. if the card is hovering above the deck, it will be put at the top.\" -- Example of a script on a bag that places Object into itself local obj = getObjectFromGUID ( \"AAA111\" ) self . putObject ( obj )","title":"putObject(...)"},{"location":"object/#registercollisions","text":"Registers this object for Global collision events, such as onObjectCollisionEnter . Always returns true . registerCollision(stay) stay : Whether we should register for onObjectCollisionStay . Stay events may negatively impact performance, only set this to true if absolutely necessary. Optional, defaults to `false`.","title":"registerCollisions(...)"},{"location":"object/#reload","text":"Returns Object reference of itself after it respawns itself. This function causes the Object to be deleted and respawned instantly to refresh it, so its old Object reference will no longer be valid. Most often this is used after using setCustomObject(...) to modify a custom object.","title":"reload()"},{"location":"object/#split","text":"Splits a deck, as evenly as possible, into a number of piles. Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. split(piles) piles : How many piles to split the deck into. Optional, if no value is provided, it is split into two piles. Minimum Value: 2 Maximum Value: Number-Of-Cards-In-Deck / 2 Returned table The number of Objects in the table is equal to the number of decks created by the split. They are ordered so any larger decks come first. The table that is returned 1 : The first deck created 2 : The second deck created 3 : The third deck created (etc) newDecks = deck . split ( 4 ) --A delay would be required here for these next four lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 ) newDecks [ 3 ]. deal ( 1 ) newDecks [ 4 ]. deal ( 1 )","title":"split(...)"},{"location":"object/#spread","text":"Spreads the cards of a deck out on the table. Important Cards take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. spread(distance) distance : How far apart should the cards be. Optional, if no value is provided, they will be 0.6 inches apart. Negative values will spread to the left instead of the right. Returned table The number of Objects in the table is equal to the number of cards in the deck. They are returned in the order they were in the deck. The table that is returned 1 : The first card in the deck 2 : The second card in the deck 3 : The third card in the deck (etc)","title":"spread(...)"},{"location":"object/#takeobject","text":"Takes an object out of a container (bag/deck/chip stack), returning a reference to the object that was taken. Objects that are taken out of a container will take one or more frames to spawn. Certain interactions (e.g. physics) will not be able to take place until the object has finished spawning. takeObject(parameters) parameters : A Table of parameters used to determine how takeObject will act. parameters.position : A Vector of the position to place Object. Optional, defaults to container's position + 2 on the x axis. parameters.rotation : A Vector of the rotation of the Object. Optional, defaults to the container's rotation. parameters.flip : If the Object is flipped over. Optional, defaults to false. Only used with decks, not bags/stacks. If rotation is used, flip's Bool will be ignored. parameters.guid : GUID of the Object to take. Optional, no default. Only use index or guid, never both. parameters.index : Index of the Object to take. Optional, no default. Only use index or guid, never both. parameters.top : If an object is taken from the top (vs bottom). Optional, defaults to true. parameters.smooth : If the taken Object moves smoothly or instantly. Optional, defaults to true. parameters.callback_function : Callback which will be called when the taken object has finished spawnning. Optional, no default. This function takes a single parameter: the object that was taken. Caution Certain containers only exist whilst they have more than one object contained within them (e.g. decks). Once you remove the second last object from a container, the container will be destroyed and the remaining contained object will spawn in its place. After calling takeObject(...) you can check for a remainder . Example Take an object out of a container. As we take it out we'll instruct the object to smooth move (default positioning behavior) to coordinates (0, 5, 0). Additionally, we're going to add a blue highlight on the object we've taken out. local takenObject = container . takeObject ({ position = { x = 0 , y = 5 , z = 0 }, }) takenObject . highlightOn ( 'Blue' ) Advanced example Take an object out of a container, and then apply an upward force (impulse) shooting it into the air. We can only apply an impulse to an object once its (underlying rigid body) has finished spawning Additionally, freshly spawned objects are frozen in place for a single frame. So we need to wait for the taken object to finish spawning (i.e. callback_function ) then wait one more frame before applying the impulse. container . takeObject ({ callback_function = function ( spawnedObject ) Wait . frames ( function () -- We've just waited a frame, which has given the object time to unfreeze. -- However, it's also given the object time to enter another container, if -- it spawned on one. Thus, we must confirm the object is not destroyed. if not spawnedObject . isDestroyed () then spawnedObject . addForce ({ 0 , 30 , 0 }) end end ) end , smooth = false , -- Smooth moving objects cannot have forces applied to them. })","title":"takeObject(...)"},{"location":"object/#unregistercollisions","text":"Unregisters this object for Global collision events. Returns true if the object was previously registered, false otherwise. unregisterCollision()","title":"unregisterCollisions(...)"},{"location":"object/#hide-function-details","text":"","title":"Hide Function Details"},{"location":"object/#sethiddenfrom","text":"Hides the Object from the specified players, as if it were in a hand zone. Using an empty table will cause the Object to remove the hiding effect. setHiddenFrom(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setHiddenFrom ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card.","title":"setHiddenFrom(...)"},{"location":"object/#setinvisibleto","text":"Hides the Object from the specified players, as if it were in a hidden zone. Using an empty table will cause the Object to remove the hiding effect. setInvisibleTo(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setInvisibleTo ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so.","title":"setInvisibleTo(...)"},{"location":"object/#attachhider","text":"A more advanced version of setHiddenFrom(...) , this function is also used to hide objects as if they were in a hand zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card.","title":"attachHider(...)"},{"location":"object/#attachinvisiblehider","text":"A more advanced version of setInvisibleTo(...) , this function is also used to hide objects as if they were in a hidden zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachInvisibleHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachInvisibleHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachInvisibleHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so.","title":"attachInvisibleHider(...)"},{"location":"object/#global-function-details","text":"","title":"Global Function Details"},{"location":"object/#adddecal","text":"Add a Decal onto an object or the game world. Relative Vectors When using this function, the vector parameters (position, rotation) are relative to what the decal is being placed on. For example, if you put a decal at {0,0,0} on Global, it will attach to the center of the game room. If you do the same to an object, it will place the decal on the origin point of the object. addDecal(parameters) parameters : A Table of parameters used to determine how the function will act. parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local params = { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 0 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = { 1 , 1 , 1 }, } Global . addDecal ( params ) end","title":"addDecal(...)"},{"location":"object/#call","text":"Used to call a Lua function on another entity. Var is only returned if the function called has a return . Otherwise return is nil . See example. This function can also be used directly on the game world using Global. call(func_name, func_params) func_name : Function name you want to activate. func_params : A Table containing any data you want to pass to that function. Optional, will not be sent by default. -- Call, used from an entity's script params = { msg = \"Hello world!\" , color = { r = 0.2 , g = 1 , b = 0.2 }, } -- Success would be set to true by the return value in the function success = Global . call ( \"testFunc\" , params ) -- Function in Global function testFunc ( params ) broadcastToAll ( params . msg , params . color ) return true end","title":"call(...)"},{"location":"object/#getdecals","text":"Returns a table of sub-tables, each sub-table representing one decal. Sub-table elements parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. Example returned table: -- If this object had 2 of the same decal on it decalTable = self . getDecals () --[[ This is what the table would look like { { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, } ]] -- -- Accessing the name of of the second entry would look like this print ( decalTable [ 2 ]. name )","title":"getDecals()"},{"location":"object/#getsnappoints","text":"Returns a table of sub-tables, each sub-table representing one snap point. This function can also be used directly on the game world (game table) using Global. Format of the returned table A table containing numerically indexed sub-tables. Sub-table(s), each representing a snap point: position : Local Position of the snap point. The position is relative to the entity's center. rotation : Local Rotation of the snap point. The rotation is relative to the entity's rotation. rotation_snap : If the snap point is a \"rotation\" snap point. Example: function onLoad () snapPointList = Global . getSnapPoints () log ( snapPointsList ) end Returned table: { { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, }","title":"getSnapPoints()"},{"location":"object/#setdecals","text":"Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. Removing decals Using this function with an empty table will remove all decals from Global or the object it is used on. Global.setDecals({}) setDecals(parameters) parameters : The main table, which will contain all of the sub-tables. subtable : The sub-table containing each individual decal's information. The sub-tables are unnamed. parameters.subtable.name : The name of the decal being placed. parameters.subtable.url : The file path or URL for the image to be displayed. parameters.subtable.position : A Vector of the position to place Object. parameters.subtable.rotation : A Vector of the rotation of the Object. parameters.subtable.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local parameters = { { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { - 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, } Global . setDecals ( parameters ) end","title":"setDecals(...)"},{"location":"object/#setsnappoints","text":"Spawns snap points from a list of parameters. This function can also be used on the game world (game table) itself using Global. setSnapPoints(parameters) parameters : A table containing numerically indexed sub-tables. sub-table : position : Local Position of the snap point. This is relative to the entity's position. Optional, defaults to {0,0,0}. rotation : Local Rotation of the snap point. This is relative to the entity's rotation. Optional, defaults to {0,0,0}. rotation_snap : If the snap point is a \"rotation\" snap point. Optional, defaults to false. self . setSnapPoints ({ { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, })","title":"setSnapPoints(...)"},{"location":"object/#setvectorlines","text":"Spawns Vector Lines from a list of parameters. This function can also be used on the game world itself using Global. setVectorLines(parameters) parameters : The table containing each \"line's\" data. Each contiguous line has its own sub-table. points : Table containing Vector positions for each \"point\" on the line. color : Color the line will be. Optional, defaults to {1,1,1}. thickness : How thick the line is (in Unity units). Optional, defaults to default line size (0.1). rotation : Rotation Vector for the line to be angled. Optional, defaults to {0,0,0}. function onLoad () --Make an X above the middle of the table Global . setVectorLines ({ { points = { { 5 , 1 , 5 }, { - 5 , 1 , - 5 } }, color = { 1 , 1 , 1 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, { points = { { - 5 , 1 , 5 }, { 5 , 1 , - 5 } }, color = { 0 , 0 , 0 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, }) end","title":"setVectorLines(...)"},{"location":"overview/","text":"Available scripting methods In-Game Lua Editor You can access the in-game Lua Editor by clicking on Scripting on the top bar or by right clicking on an object, choosing Scripting, and then selecting Lua Editor from the contextual menu. In the Lua Editor, the tabs on the left of the editor let you switch between the Global and the Object scripts. Once your Lua code is written, you can use the Save and Play button to commit your changes to your save file and reload for quick iteration. Save and Play will only commit your script changes, any changes made that weren't scripting will be lost. The advantage of this method is it requires no additional setup. However it lacks many features included in some of the other options. Official Atom Plugin The preferred method of writing Lua scripts is using our Official Plugin for the Atom Text Editor. It has all of the functionality of the in-game editor plus line numbers, syntax highlighting, autocomplete, and a modern look. Click here for setup instructions. External Editor API It is also possible to edit inside of other envionments which are not officially supported. Using the External Editor API it is possible to work in other enviornments (like Notepad++). Warning This method does not, by default, include many features that Atom provides, like auto-completion of Tabletop Simulator functions/class members. Lua Standard Libraries We include a subset of the Lua standard libraries into our interpreter to provide a safe sandbox for user scripts to run. Library Description Basic The basic methods. Includes assert, collectgarbage, error, print, select, type, tonumber, and tostring. Bit32 The bit32 package. Coroutine The coroutine package. Dynamic The dynamic package (introduced by MoonSharp). ErrorHandling The error handling methods: pcall and xpcall. GlobalConsts The global constants: _G, _VERSION, and _MOONSHARP. Math The math package. Metatables The metatable methods : setmetatable, getmetatable, rawset, rawget, rawequal, and rawlen. OS_Time The time methods of the os package: clock, difftime, date, and time. String The string package. Table The table package. TableIterators The table iterators: next, ipairs, and pairs. For further information Official Lua Website MoonSharp Example Mods BlackJack Chess Clock Roulette Interactable","title":"Overview"},{"location":"overview/#available-scripting-methods","text":"","title":"Available scripting methods"},{"location":"overview/#in-game-lua-editor","text":"You can access the in-game Lua Editor by clicking on Scripting on the top bar or by right clicking on an object, choosing Scripting, and then selecting Lua Editor from the contextual menu. In the Lua Editor, the tabs on the left of the editor let you switch between the Global and the Object scripts. Once your Lua code is written, you can use the Save and Play button to commit your changes to your save file and reload for quick iteration. Save and Play will only commit your script changes, any changes made that weren't scripting will be lost. The advantage of this method is it requires no additional setup. However it lacks many features included in some of the other options.","title":"In-Game Lua Editor"},{"location":"overview/#official-atom-plugin","text":"The preferred method of writing Lua scripts is using our Official Plugin for the Atom Text Editor. It has all of the functionality of the in-game editor plus line numbers, syntax highlighting, autocomplete, and a modern look. Click here for setup instructions.","title":"Official Atom Plugin"},{"location":"overview/#external-editor-api","text":"It is also possible to edit inside of other envionments which are not officially supported. Using the External Editor API it is possible to work in other enviornments (like Notepad++). Warning This method does not, by default, include many features that Atom provides, like auto-completion of Tabletop Simulator functions/class members.","title":"External Editor API"},{"location":"overview/#lua-standard-libraries","text":"We include a subset of the Lua standard libraries into our interpreter to provide a safe sandbox for user scripts to run. Library Description Basic The basic methods. Includes assert, collectgarbage, error, print, select, type, tonumber, and tostring. Bit32 The bit32 package. Coroutine The coroutine package. Dynamic The dynamic package (introduced by MoonSharp). ErrorHandling The error handling methods: pcall and xpcall. GlobalConsts The global constants: _G, _VERSION, and _MOONSHARP. Math The math package. Metatables The metatable methods : setmetatable, getmetatable, rawset, rawget, rawequal, and rawlen. OS_Time The time methods of the os package: clock, difftime, date, and time. String The string package. Table The table package. TableIterators The table iterators: next, ipairs, and pairs.","title":"Lua Standard Libraries"},{"location":"overview/#for-further-information","text":"Official Lua Website MoonSharp","title":"For further information"},{"location":"overview/#example-mods","text":"BlackJack Chess Clock Roulette Interactable","title":"Example Mods"},{"location":"physics/","text":"Physics, a static global class, allows access to casts and gravity. Physics casts are a way to detect Objects. You call these functions like this: Physics.getGravity() . This class also allows you to access elements of the environment. For more information on physics casts in Unity, refer to the Unity documentation under BoxCast/RayCast/SphereCast. Member Variable Summary Member Variables These are variables that affect elements of the environment. It allows you to both read and write values. Read example: print(Physics.play_area) Write Example = Physics.play_area = 0.5 Variable Description Type play_area The play area being used (ie. how far from middle you can get). Values from 0 - 1. Default is 0.5 Function Summary Functions Function Name Description Return cast( parameters) Returns Table containing information on hit Objects. getGravity() Returns directional Vector of the direction gravity is pulling. setGravity( direction) Sets the direction gravity gravity pulls. Function Details cast(...) Returns Table containing information on hit Objects. There are three kinds of casts: Type Description Ray A line. Box A cube, rectangle, plane. Sphere A round ball. You cannot make ovals. It draws the imaginary cast, then moves the rap/box/sphere along that path instantly. The debug Bool in the parameters allows you to see this shape, to aid in setup, but the visual is not instant (due to that making it pointless, if you can't see it). Warning Physics casts are somewhat expensive. When running 30+ at once it will cause your game to stutter and/or crash. Do not overuse. cast(parameters) parameters : A Table of parameters used to guide the function. parameters.origin : Position of the starting point. Optional, defaults to {x=0, y=0, z=0}. parameters.direction : A direction for the cast to move in. Optional, but cast is motionless without a direction. parameters.type : The type of cast. 1 = Ray, 2 = Sphere, 3= Box Optional, defaults to 1. parameters.size : Size of the cast shape. Sphere/Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.orientation : Rotation of the cast shape. Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.max_distance : How far the cast will travel. Optional, defaults to infinity. Won't move without direction. parameters.debug : If the cast is visualized for the user. Optional, defaults to false. Returned Table of Hit Objects table : A numerically indexed Table, one entry for each hit Object. Entries are in the order of being hit. table.point : Position the cast impacted the Object. table.normal : The surface normal of the impact point. table.distance : Distance between cast origin and impact point. table.hit_object : An Object reference to the Object hit by the cast. -- Example usage -- This function, when called, returns a table of hit data function findHitsInRadius ( pos , radius ) local radius = ( radius or 1 ) local hitList = Physics . cast ({ origin = pos , direction = { 0 , 1 , 0 }, type = 2 , size = { radius , radius , radius }, max_distance = 0 , debug = true , }) return hitList end -- Example returned Table { { point = { x = 0 , y = 0 , z = 0 }, normal = { x = 1 , 0 , 0 }, distance = 4 , hit_object = objectreference1 , }, { point = { x = 1 , y = 0 , z = 0 }, normal = { x = 2 , 0 , 0 }, distance = 5 , hit_object = objectreference2 , }, }","title":"Physics"},{"location":"physics/#member-variable-summary","text":"","title":"Member Variable Summary"},{"location":"physics/#member-variables","text":"These are variables that affect elements of the environment. It allows you to both read and write values. Read example: print(Physics.play_area) Write Example = Physics.play_area = 0.5 Variable Description Type play_area The play area being used (ie. how far from middle you can get). Values from 0 - 1. Default is 0.5","title":"Member Variables"},{"location":"physics/#function-summary","text":"","title":"Function Summary"},{"location":"physics/#functions","text":"Function Name Description Return cast( parameters) Returns Table containing information on hit Objects. getGravity() Returns directional Vector of the direction gravity is pulling. setGravity( direction) Sets the direction gravity gravity pulls.","title":"Functions"},{"location":"physics/#function-details","text":"","title":"Function Details"},{"location":"physics/#cast","text":"Returns Table containing information on hit Objects. There are three kinds of casts: Type Description Ray A line. Box A cube, rectangle, plane. Sphere A round ball. You cannot make ovals. It draws the imaginary cast, then moves the rap/box/sphere along that path instantly. The debug Bool in the parameters allows you to see this shape, to aid in setup, but the visual is not instant (due to that making it pointless, if you can't see it). Warning Physics casts are somewhat expensive. When running 30+ at once it will cause your game to stutter and/or crash. Do not overuse. cast(parameters) parameters : A Table of parameters used to guide the function. parameters.origin : Position of the starting point. Optional, defaults to {x=0, y=0, z=0}. parameters.direction : A direction for the cast to move in. Optional, but cast is motionless without a direction. parameters.type : The type of cast. 1 = Ray, 2 = Sphere, 3= Box Optional, defaults to 1. parameters.size : Size of the cast shape. Sphere/Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.orientation : Rotation of the cast shape. Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.max_distance : How far the cast will travel. Optional, defaults to infinity. Won't move without direction. parameters.debug : If the cast is visualized for the user. Optional, defaults to false. Returned Table of Hit Objects table : A numerically indexed Table, one entry for each hit Object. Entries are in the order of being hit. table.point : Position the cast impacted the Object. table.normal : The surface normal of the impact point. table.distance : Distance between cast origin and impact point. table.hit_object : An Object reference to the Object hit by the cast. -- Example usage -- This function, when called, returns a table of hit data function findHitsInRadius ( pos , radius ) local radius = ( radius or 1 ) local hitList = Physics . cast ({ origin = pos , direction = { 0 , 1 , 0 }, type = 2 , size = { radius , radius , radius }, max_distance = 0 , debug = true , }) return hitList end -- Example returned Table { { point = { x = 0 , y = 0 , z = 0 }, normal = { x = 1 , 0 , 0 }, distance = 4 , hit_object = objectreference1 , }, { point = { x = 1 , y = 0 , z = 0 }, normal = { x = 2 , 0 , 0 }, distance = 5 , hit_object = objectreference2 , }, }","title":"cast(...)"},{"location":"player-color/","text":"Each person able to interact with objects in-game is assigned a Player Color to represent them. This is chosen when a Player picks a seat color or is assigned one by the host. Many functions refer to these Players or their hand zones, and it does so via color names. All color names are strings and are case sensitive within functions. Each color also has an RGB value associated with it. For more information on the RGB Color standard, view the Color section . Color Name Color Swatch RGB White {1, 1, 1} Brown {0.443, 0.231, 0.09} Red {0.856, 0.1, 0.094} Orange {0.956, 0.392, 0.113} Yellow {0.905, 0.898, 0.172} Green {0.192, 0.701, 0.168} Teal {0.129, 0.694, 0.607} Blue {0.118, 0.53, 1} Purple {0.627, 0.125, 0.941} Pink {0.96, 0.439, 0.807} Grey (spectator) {0.5, 0.5, 0.5} Black (GM/DM) {0.25, 0.25, 0.25}","title":"Player Color"},{"location":"player/","text":"Player, a static global class, allows control over in-game players and their hand zones . Example Usage: Player[\"White\"].seated or Player[\"Green\"].mute() Member Variables Like Object member variables , Player has its own member variables. Variable Description Type admin If the player is promoted or the host of the game. Read only. blindfolded If the player is blindfolded. color The player's Player Color . Read only. host If the player is the host. Read only. lift_height The lift height for the player. This is how far an object is raised when held in a player's hand. Value is ranged 0 to 1. promoted If the current player is promoted. seated If a player is currently seated at this color. Read only. steam_id The Steam ID of the player. This is unique to each player's Steam account. Read only. steam_name The Steam name of the player. Read only. team The team of the player. Options: \"None\", \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\", \"Jokers\" . Function Summary Class Functions Function Name Description Return attachCameraToObject( parameters) Makes a Player's camera follow an Object. broadcast( message, message_color) Print message on Player's screen and their game chat log. changeColor( player_color) Changes player to this Player Color . clearSelectedObjects() Clears a player's current selection. getHandCount() Number of hand zones owned by this color. getHandObjects( hand_index) Objects that are in this hand zone . getHandTransform( hand_index) Returns a Table of data on this hand zone . getHoldingObjects() Objects a Player is holding in their hand. getHoverObject() Object that the Player's pointer is hovering over. getPointerPosition() Player's pointer coordinates. getPointerRotation() Player's pointer rotation on Y axis. getSelectedObjects() Objects that the Player has selected with an area selection. kick() Kicks Player out of the room. lookAt( parameters) Moves a Player's camera, forcing 3'rd person camera mode. mute() Mutes or unmutes Player, preventing/allowing voice chat. pingTable( position) Emulates the player using the ping tool at the given position (tapping Tab). print( message, message_color) Prints a message into the Player's game chat. promote() Promotes/demotes a Player. Promoted players have access to most host privileges. setCameraMode( camera_mode) Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". setHandTransform( parameters, hand_index) Sets transform elements of a hand zone. Direct Class Functions These functions return direct references to Players, not a Player Color. See details section for usage. Function Name Description Return getAvailableColors() Returns a table of strings of every valid seat color at the current table. Returned colors are in the default order. getColors() Returns a table of strings of every possible seat color. Returned colors are in the default order. getPlayers() Returns Table of all Players in the instance. getSpectators() Returns Table of all Players in spectator (Grey). Function Details Class Function Details attachCameraToObject(...) Makes a Player's camera follow an Object. attachCameraToObject(parameters) parameters : A Table with parameters which guide the function. parameters.object : The Object to attach the camera to. parameters.offset : A Vector to offset the camera by. Optional, defaults to {x=0, y=0, z=0}. self . attachCameraToObject ({ object = self }) broadcast(...) Print message on Player's screen and their game chat log. broadcast(message, message_color) message : The message to be displayed. message_color : Tint of the message text. Optional, defaults to {r=1, g=1, b=1}. changeColor(...) Changes player to this Player Color (seat). changeColor(player_color) player_color : The Player Color seat to move the Player to. Player [ \"White\" ]. changeColor ( \"Red\" ) getHandObjects(...) Returns a Table of Objects that are in this hand zone . getHandObjects(hand_index) hand_index : An index, representing which hand zone to return Objects for. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. getHandTransform(...) Returns a Table of data on this hand zone . getHandTransform(hand_index) hand_index : An index, representing which hand zone to return data on. Optional, defaults to 1. Return Data Table data : The Table the data is returned in. data.position : Position of the hand zone. data.rotation : Rotation of the hand zone. data.scale : Scale of the hand zone. data.forward : Forward direction of the hand zone. data.right : Right direction of the hand zone. data.up : Up direction of the hand zone. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. lookAt(...) Moves a Player's camera, forcing 3'rd person camera mode. lookAt(parameters) parameters : A Table of controlling parameters to point the player camera. parameters.position : Position to center the camera on. parameters.pitch : Pitch angle of the camera. 0 to 90. Optional, defaults to 0. parameters.yaw : Yaw angle of the camera. -180 to 180. Optional, defaults to 0. parameters.distance : Distance the camera is from the position Vector. Optional, defaults to 40. -- Assuming someone is in the White seat Player [ \"White\" ]. lookAt ({ position = { x = 0 , y = 0 , z = 0 }, pitch = 25 , yaw = 180 , distance = 20 , }) print(...) Prints a message into the Player's game chat. print(message, message_color) message : The text to be displayed. message_color : Color for the message text to be tinted. Optional, defaults to {r=1, g=1, b=1}. setCameraMode(...) Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". changeColor(camera_mode) camera_mode : The Camera Mode to set the Player's Camera to. Player [ \"White\" ]. setCameraMode ( \"FirstPerson\" ) setHandTransform(...) Sets transform elements of a hand zone . setHandTransform(parameters, hand_index) parameters : The Table of data to transform the hand zone with. parameters.position : Position of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : Rotation of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the hand zone. Optional, defaults to {x=0, y=0, z=0}. hand_index : Index, representing which hand zone to modify. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. -- Example of moving/rotating/scaling hand zone params = { position = { x = 0 , y = 5 , z = 0 }, rotation = { x = 0 , y = 45 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, } Player [ \"White\" ]. setHandTransform ( params , 2 ) Direct Class Function Details getPlayers() Returns Table of all Players in the instance. -- Blindfolding all players playerList = Player . getPlayers () for _ , playerReference in ipairs ( playerList ) do playerReference . blindfolded = true end getSpectators() Returns Table of all Players in spectator (Grey). -- Printing steam name of all players to host chat playerList = Player . getSpectators () for _ , playerReference in ipairs ( playerList ) do print ( playerReference . steam_name ) end","title":"Player"},{"location":"player/#member-variables","text":"Like Object member variables , Player has its own member variables. Variable Description Type admin If the player is promoted or the host of the game. Read only. blindfolded If the player is blindfolded. color The player's Player Color . Read only. host If the player is the host. Read only. lift_height The lift height for the player. This is how far an object is raised when held in a player's hand. Value is ranged 0 to 1. promoted If the current player is promoted. seated If a player is currently seated at this color. Read only. steam_id The Steam ID of the player. This is unique to each player's Steam account. Read only. steam_name The Steam name of the player. Read only. team The team of the player. Options: \"None\", \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\", \"Jokers\" .","title":"Member Variables"},{"location":"player/#function-summary","text":"","title":"Function Summary"},{"location":"player/#class-functions","text":"Function Name Description Return attachCameraToObject( parameters) Makes a Player's camera follow an Object. broadcast( message, message_color) Print message on Player's screen and their game chat log. changeColor( player_color) Changes player to this Player Color . clearSelectedObjects() Clears a player's current selection. getHandCount() Number of hand zones owned by this color. getHandObjects( hand_index) Objects that are in this hand zone . getHandTransform( hand_index) Returns a Table of data on this hand zone . getHoldingObjects() Objects a Player is holding in their hand. getHoverObject() Object that the Player's pointer is hovering over. getPointerPosition() Player's pointer coordinates. getPointerRotation() Player's pointer rotation on Y axis. getSelectedObjects() Objects that the Player has selected with an area selection. kick() Kicks Player out of the room. lookAt( parameters) Moves a Player's camera, forcing 3'rd person camera mode. mute() Mutes or unmutes Player, preventing/allowing voice chat. pingTable( position) Emulates the player using the ping tool at the given position (tapping Tab). print( message, message_color) Prints a message into the Player's game chat. promote() Promotes/demotes a Player. Promoted players have access to most host privileges. setCameraMode( camera_mode) Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". setHandTransform( parameters, hand_index) Sets transform elements of a hand zone.","title":"Class Functions"},{"location":"player/#direct-class-functions","text":"These functions return direct references to Players, not a Player Color. See details section for usage. Function Name Description Return getAvailableColors() Returns a table of strings of every valid seat color at the current table. Returned colors are in the default order. getColors() Returns a table of strings of every possible seat color. Returned colors are in the default order. getPlayers() Returns Table of all Players in the instance. getSpectators() Returns Table of all Players in spectator (Grey).","title":"Direct Class Functions"},{"location":"player/#function-details","text":"","title":"Function Details"},{"location":"player/#class-function-details","text":"","title":"Class Function Details"},{"location":"player/#attachcameratoobject","text":"Makes a Player's camera follow an Object. attachCameraToObject(parameters) parameters : A Table with parameters which guide the function. parameters.object : The Object to attach the camera to. parameters.offset : A Vector to offset the camera by. Optional, defaults to {x=0, y=0, z=0}. self . attachCameraToObject ({ object = self })","title":"attachCameraToObject(...)"},{"location":"player/#broadcast","text":"Print message on Player's screen and their game chat log. broadcast(message, message_color) message : The message to be displayed. message_color : Tint of the message text. Optional, defaults to {r=1, g=1, b=1}.","title":"broadcast(...)"},{"location":"player/#changecolor","text":"Changes player to this Player Color (seat). changeColor(player_color) player_color : The Player Color seat to move the Player to. Player [ \"White\" ]. changeColor ( \"Red\" )","title":"changeColor(...)"},{"location":"player/#gethandobjects","text":"Returns a Table of Objects that are in this hand zone . getHandObjects(hand_index) hand_index : An index, representing which hand zone to return Objects for. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes.","title":"getHandObjects(...)"},{"location":"player/#gethandtransform","text":"Returns a Table of data on this hand zone . getHandTransform(hand_index) hand_index : An index, representing which hand zone to return data on. Optional, defaults to 1. Return Data Table data : The Table the data is returned in. data.position : Position of the hand zone. data.rotation : Rotation of the hand zone. data.scale : Scale of the hand zone. data.forward : Forward direction of the hand zone. data.right : Right direction of the hand zone. data.up : Up direction of the hand zone. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes.","title":"getHandTransform(...)"},{"location":"player/#lookat","text":"Moves a Player's camera, forcing 3'rd person camera mode. lookAt(parameters) parameters : A Table of controlling parameters to point the player camera. parameters.position : Position to center the camera on. parameters.pitch : Pitch angle of the camera. 0 to 90. Optional, defaults to 0. parameters.yaw : Yaw angle of the camera. -180 to 180. Optional, defaults to 0. parameters.distance : Distance the camera is from the position Vector. Optional, defaults to 40. -- Assuming someone is in the White seat Player [ \"White\" ]. lookAt ({ position = { x = 0 , y = 0 , z = 0 }, pitch = 25 , yaw = 180 , distance = 20 , })","title":"lookAt(...)"},{"location":"player/#print","text":"Prints a message into the Player's game chat. print(message, message_color) message : The text to be displayed. message_color : Color for the message text to be tinted. Optional, defaults to {r=1, g=1, b=1}.","title":"print(...)"},{"location":"player/#setcameramode","text":"Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". changeColor(camera_mode) camera_mode : The Camera Mode to set the Player's Camera to. Player [ \"White\" ]. setCameraMode ( \"FirstPerson\" )","title":"setCameraMode(...)"},{"location":"player/#sethandtransform","text":"Sets transform elements of a hand zone . setHandTransform(parameters, hand_index) parameters : The Table of data to transform the hand zone with. parameters.position : Position of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : Rotation of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the hand zone. Optional, defaults to {x=0, y=0, z=0}. hand_index : Index, representing which hand zone to modify. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. -- Example of moving/rotating/scaling hand zone params = { position = { x = 0 , y = 5 , z = 0 }, rotation = { x = 0 , y = 45 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, } Player [ \"White\" ]. setHandTransform ( params , 2 )","title":"setHandTransform(...)"},{"location":"player/#direct-class-function-details","text":"","title":"Direct Class Function Details"},{"location":"player/#getplayers","text":"Returns Table of all Players in the instance. -- Blindfolding all players playerList = Player . getPlayers () for _ , playerReference in ipairs ( playerList ) do playerReference . blindfolded = true end","title":"getPlayers()"},{"location":"player/#getspectators","text":"Returns Table of all Players in spectator (Grey). -- Printing steam name of all players to host chat playerList = Player . getSpectators () for _ , playerReference in ipairs ( playerList ) do print ( playerReference . steam_name ) end","title":"getSpectators()"},{"location":"rpgfigurine/","text":"An RPGFigurine is an in-game Object of a figurine with built-in animations. It has its own class, RPGFigurine, with functions associated with it. This allows you to manipulate the special properties of these figurines. Function Summary Object Functions These functions are called like this: self.RPGFigurine.attack() . Function Name Description Return attack() Plays a random attack animation. changeMode() Changes the figurine's current mode. What the mode represents is based on the figurine. die() Plays the death animation or causes it to return to life. Event Functions These functions are called by the game whenever a figurine attacks or is attacked. See details for example usage. Function Name Description onAttack( hit_list) Activates when an attack is performed by an identified RPGFigurine Object. onHit( attacker) Activates when an attack is performed on this RPGFigurine Object. Function Details Event Function Details onAttack(...) Activates when an attack is performed by an identified RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If another RPGFigurine is within its attack arch, then the function will be triggered with the figurine hit passed as a parameter. onAttack(hit_list) hit_list : A Table of RPGFigurine Object references within the reach of the attack. -- Monitoring and announcing a cyclops attacks function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onAttack ( hit_list ) for _ , v in ipairs ( hit_list ) do print ( v . getName () .. \" was hit!\" ) end end end onHit(...) Activates when an attack is performed on this RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If this RPGFigurine is within the attack radius, this function is triggered, passing a parameter of the Object which attacked. onHit(attacker) attacker : Reference to the RPGFigurine attacking the indicated RPGFigurine. -- Monitoring and announcing a cyclops being hit function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onHit ( attacker ) print ( attacker . getName () .. \" attacked the Cyclops!\" ) end end","title":"RPGFigurine"},{"location":"rpgfigurine/#function-summary","text":"","title":"Function Summary"},{"location":"rpgfigurine/#object-functions","text":"These functions are called like this: self.RPGFigurine.attack() . Function Name Description Return attack() Plays a random attack animation. changeMode() Changes the figurine's current mode. What the mode represents is based on the figurine. die() Plays the death animation or causes it to return to life.","title":"Object Functions"},{"location":"rpgfigurine/#event-functions","text":"These functions are called by the game whenever a figurine attacks or is attacked. See details for example usage. Function Name Description onAttack( hit_list) Activates when an attack is performed by an identified RPGFigurine Object. onHit( attacker) Activates when an attack is performed on this RPGFigurine Object.","title":"Event Functions"},{"location":"rpgfigurine/#function-details","text":"","title":"Function Details"},{"location":"rpgfigurine/#event-function-details","text":"","title":"Event Function Details"},{"location":"rpgfigurine/#onattack","text":"Activates when an attack is performed by an identified RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If another RPGFigurine is within its attack arch, then the function will be triggered with the figurine hit passed as a parameter. onAttack(hit_list) hit_list : A Table of RPGFigurine Object references within the reach of the attack. -- Monitoring and announcing a cyclops attacks function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onAttack ( hit_list ) for _ , v in ipairs ( hit_list ) do print ( v . getName () .. \" was hit!\" ) end end end","title":"onAttack(...)"},{"location":"rpgfigurine/#onhit","text":"Activates when an attack is performed on this RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If this RPGFigurine is within the attack radius, this function is triggered, passing a parameter of the Object which attacked. onHit(attacker) attacker : Reference to the RPGFigurine attacking the indicated RPGFigurine. -- Monitoring and announcing a cyclops being hit function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onHit ( attacker ) print ( attacker . getName () .. \" attacked the Cyclops!\" ) end end","title":"onHit(...)"},{"location":"systemconsole/","text":"The system console gives you a direct way to interact with Tabletop Simulator's settings. It can be used to automate repetitive actions, and customise your TTS experience. Controls The console accepts basic text input. Additionally, you may hit up arrow and down arrow to cycle back and forth through the command history, and tab to autocomplete your current command (if more than one command is possible from your current prefix then hit it a couple of times to list all matching commands). Hitting the ` key will activate the console. Hitting it again will type the character; if you would rather it deactivated the console input as well as activating it, then you can make it do that by entering this command: +console_hotkey_lock Commands & Variables You interact with the system console by typing commands into it. When you hit enter the command will be perform its action, and then output its results to the console. There is a subset of the commands which have an additional property; these are called variables , and each one stores a value (in addition to behaving like regular commands). Typically these are used for the settings which govern TTS behaviour. For example, the color command is a variable; it holds the seat color you currently occupy. Typing it without any parameters will make it output its current value, while typing it with a parameter will let you set it; you could type color red to switch to the red seat, for instance. You may also create your own variables with the store_number , store_toggle , and store_text commands (or if you are familiar with programming, their aliases: float , bool , and string ); these are especially useful when writing scripts. A lot of variables are toggles: they can be either OFF or ON . For these you can set them in an additional way; by prefixing with + , - , or ! . + will turn it on, - will turn it off, and ! will toggle it, changing it to the opposite of its current value. For example: +measure_in_metric will set measure_in_metric to ON , and !measure_logging when measure_logging is ON will set it to OFF (and vice-versa). Note that some variables are persistent - this means that they will remember their value even after you close the game. There are three commands which are extremely valuable when getting to know the console, these are: commands - Lists all non-variable commands. variables - Lists all variable commands and their current values. help - Lists all commands, with a description of what they do. You may specify a prefix when using these to have them filter to only commands which begin with it; for example you could type variables spectator to see the value of all commands which deal with the spectator window. Additionally, if you ask for help on a specific command it will give you a detailed description of how to use it. You may insert variables into commands by enclosing them in { and } . For example, typing hovered will display the GUID of the object your pointer is hovering over; spectator_camera_target {hovered} will set the spectator camera target with it. If you start a command with the @ symbol then it will be silenced; it will not output anything to the console. Scripts The exec command will execute a series of commands separated either by ; or by being on separate lines. Alternatively, you may use the -v parameter to execute a text variable as a script. For example, exec -v bootexec will execute the commands in the bootexec variable (there is also a run alias, which performs exec -v , so run bootexec will do the same thing). You may also pass exec a -q parameter to make it execute in quiet mode (commands being executed are not echoed to the console, but their output is). There are two special variables: autoexec and bootexec ; these are text variables which load the contents of those two files - autoexec.cfg and bootexec.cfg , respectively - in your TTS user folder (typically C:\\Users\\<username>\\Documents\\My Games\\Tabletop Simulator ). autoexec will be executed every time you arrive at the main menu in TTS, while bootexec is only executed once, when TTS first starts up. Note that the game resets every time you go back to the main menu, so if you want to affect any settings / add bindings / etc you need to do it in autoexec Example bootexec : # Host a game for 8 players using default server name and password host_game 8 # Load game on row 4 slot 5 ui_games_click 4 5 # Switch to system console chat_tab_system # Activate spectator window +spectator_window Example autoexec : # Make easier to type versions of spectator_camera_ commands. # i.e. cam_load instead of spectator_camera_load alias cam_* spectator_camera_* # Set some settings +cam_stay_upright -spectator_show_ui # make right control have camera follow player while held # @ makes it not output to console bind +right_control @+cam_follow_player bind -right_control @-cam_follow_player # make semicolon look at object under pointer # need to add additional { } so hovered isn't evaluated immediately bind semicolon cam_look_at {{ hovered }} # make period toggle object tracking, and comma set tracked object bind period !cam_tracking bind comma cam_target {{ hovered }} # make right shift cycle through first 3 camera positions alias next_camera add cam_load_zero 1 3 bind right_shift next_camera # make some buttons to load specific camera positions ui_button 1 600 0 cam_load 1 ui_button 2 600 -30 cam_load 2 ui_button 3 600 -60 cam_load 3 Special characters @ - Behaves as it does normally; prefix it to a command to silence that command. @@ - Two @ in a row silences the remainder of the script; each command will behave as if it had a @ before it. @@ again will disable this effect. # - At the start of a line is used for comments; the line will be ignored. : - At the start of a line is used to specify a label, which may be skipped to with the skip command. { and } - If you surround a variable with these then it will be evaluated during the script execution; you may add additional braces to delay evaluation. Whenever a command being executed has braces in its parameters it will either strip one layer off (if there is more than one), or evaluate the enclosed variable (if there is only one layer); e.g. {{hovered}} will become {hovered} , whereas {hovered} will become the component currently under the mouse pointer. You can see this used in the above autoexec . Another example; say you wanted a binding which could add a binding to another key. We add this line to the autoexec : bind right_shift bind right_control spectator_camera_target {{{ hovered }}} When the autoexec is executed and the first bind is called, the first layer of braces will be removed, so the command bound to right shift will be: bind right_control spectator_camera_target {{ hovered }} Then when you hit right shift, it will resolve so that the command bound to right control is: spectator_camera_target { hovered } Now when you hit right control while hovering over the object, the hovered object will be evaulated and passed to spectator_camera_target . Script commands The skip command can be used inside a script to jump forward to a label. It may not be used to jump backwards. You may give it an optional variable and then further optional comparison and value parameters: if you do it will only skip if the variable is non-zero, or the result of the comparison is true. The wait command will pause the script for the specified number of seconds. It will always wait at least one frame, so wait 0 will do just that. This can be useful in bootexec and autoexec , as some game systems may take a couple of frames to intialize; if your commands do not appear to work then try putting them at the end of the script, after a wait . Finally, the exit command will cause the script to stop executing. Example autoexec : @@ # silence script ## Set up a `private_room` variable to govern whether server is private or public # Create scripts for each mode store_text private_game_settings host_name Members Only! host_password foobar end private_game_settings store_text public_game_settings host_name All Are Welcome! host_password \"\" end public_game_settings # create variable and assign scripts store_toggle private_room alias +private_room exec -q -v private_game_settings alias -private_room exec -q -v public_game_settings # bind to key, and set to private by default bind KeypadMinus !private_room +private_room ## Set up smart chat keybinding: # Push to activate Team chat input if in team, # or Game chat input if not. store_text smart_chat skip :teamchat team chat_tab_game skip :activate :teamchat chat_tab_team :activate chat_input end smart_chat bind y @exec -v smart_chat ## Display GUID of currently held object, # or if nothing held then currently hovered object. store_text echo_guid_script skip :held grabbed echo {{ hovered }} exit :held echo {{ grabbed }} end echo_guid_script alias echo_guid exec -q -v echo_guid_script bind KeypadEnter echo_guid ## Create key to Tap/Untap card (turn 90 degreees / set upright) # Use seat hand zone rotation to work out orientation. string guid \"\" float facing float y bool untapped string tap_script # use \"\" so if not hovering variable will be cleared guid \"{{hovered}}\" skip :ok guid exit :ok # Find hand zone facing. It faces the player, so spin it 180. component_examine {{ color }} eval facing ( examine_rotation.y - 180 ) % 360 # Is card currently tapped? component_examine {{ guid }} eval y examine_rotation.y % 360 eval untapped ! (( y - 90 < facing + 10 && y - 90 > facing - 10 ) || ( y + 270 < facing + 10 && y + 270 > facing - 10 )) # Bump card up a bit into the air (0.5 along Y axis). component_move {{ guid }} -f - 0 .5 - skip :tap untapped :untap # Set rotation to player facing. Use `-` on X and Z axis so they are unaffected. component_rotation {{ guid }} -f - {{ facing }} - exit :tap eval y facing + 90 component_rotation {{ guid }} -f - {{ y }} - end tap_script bind Mouse4 @run tap_script Some useful commands As noted above, help , commands , and variables will let you find out everything you can do with the system console. Having said that, here is a selection of some of the more useful commands available: add , subtract , and multiply will let you do simple arithmetic on a variable. add is useful for cycling a modal variable (it has an optional third parameter which sets a modulus), while subtract subtracts the variable from the value, so is useful for ping-ponging between two numbers. alias is overloaded with several functions: Its basic use is to create a new name for another command, while retaining any parameters you type in. Good for making shorter names for commands you use a lot. Use with store_text and exec to make your own commands from scripts. It can also be used to attach commands to each value of a toggle variable, which will run when the variable is set to that value. You can see this in the example script above, with the private_room variable. Finally, if there are a collection of commands sharing a prefix which you want to make short versions of you can use * to do so (e.g. alias cam_* spectator_camera_* ) append will append text to a text variable. If you only provide the variable parameter, without text, it will append the last entered command. This is useful for adding commands to autoexec ; you can try the command out in the console until you get it correct, before appending it to the script. bind , unbind control attaching commands to keypresses. You may use + and - before the keycode to specify if you want it to trigger on press or release , respectively. (list of Unity keycodes) broadcast will broadcast the provided message. chat_font_size sets the size of the font in the chat / console window. clear will clear a text variable. color reports/sets your player color. component_examine lets you specify a component, which can then be examined with the examine_position and examine_rotation variables. If you specify a color then that seat's primary hand zone will be examined instead. component_move , component_rotate , component_position , component_rotation let you apply movements to components. The first two add the specified vector to the component's current position/rotation, while the second two set it to the specified vector in world space. You may use '-' in place of a vector axis to indicate that axis is to be left alone. console_hotkey_lock When enabled, locks whichever key is bound to toggling the system console, so that hitting it always toggles the console (this makes the key untypeable in text input boxes). default_host_name and default_password set those values. dice_roll_height_multiplier sets how high dice go when randomized. displays outputs information on currently connected monitors. drawing_erase_all erases all drawings. drawing_render_fully_visible will cause drawings to render fully in 3d space (which is neat if you have VR) echo displays its parameters in the system console. edit allow you to edit a text variable with the in-game GUI (you may also do this by passing the variable the -e parameter, e.g. autoexec -e ) escape will display a text variable in the console, and will escape all the formatting characters (i.e. all the [ and ] characters). eval sets a variable by evaluating a formula. Most arithmetic operators and functions are provided. You may also refer to vector axes, i.e. examine_rotation.y . find finds a component on the table. grabbed , hovered output the GUID of the component you are interacting with. highlight a component. host_game creates a table; you can specify single player, multiplayer, or hotseat. host_name and host_password set those values for current game. last is a special variable which holds the value returned from the most recent command. lua executes lua code as if run by the current mod. mirror_all will mirror all text displayed in every other chat tab into the system console. This means you can always be in the system console without missing any messages. quiet_mode will, when enabled, stop command names being echoed in the console. Unlike silencing commands with @ , this will still display the commands' output. reset will reset a persistent variable to its default value. sendkey will emulate a keypress. Primarily useful for binding things to VR controllers. status will display some key information about the current game. stats_monitor will display some graphs/info which update in real time. team reports/sets your team. ui_anchor lets you set the position on the screen which custom UI components are placed relative to. It defaults to 0,0 which is the center of the screen. ui_button / ui_label / ui_toggle will add custom UI components to the screen which will, respectively, perform a command when clicked / display some text / be attached to a toggle variable. ui_dialog_input will display the text entry UI, and store the typed text in last . ui_games_click will click on a button on the game select UI, if it is open. ui_games_hide will hide the game select UI without clicking on anything. wait is a command which can be inserted into a script to cause it to pause for some amount of time. Useful for fudging a script to work with asynchronous commands which take some time to execute. Commands are named with their topic first, so commands which affect the same part of the game have the same prefix. The following are some useful groups of commands: get more info on them by running help prefix_ . For instance, help camera_ camera_ commands control the position and behaviour of the player camera (i.e. your point-of-view) chat_ commands control the chat window. component_ commands deal with the game components on the table. Notably the component_default_ commands let you specify what toggles new component are created with, which is useful if you are creating a lot of similar components. errors_ commands handle how Lua errors are displayed. jigsaw_ commands let you mess with jigsaws. log_ commands control formatting of lua log calls. mirror_ commands govern mirroring text from other tabs into the system console. mod_ commands control various performance settings when loading mods. music_ commands let you control the in-game music player. say_ commands let you output messages to the chat channels. spectator_ commands control the spectator view. timestamp_ commands let you add timestamps to the chat channels / console. tool_ commands let you check and set the currently used tool (grab, draw, etc). ui_ commands deal with the game's User Interface. vr_ commands perform all VR related tasks.","title":"System Console"},{"location":"systemconsole/#controls","text":"The console accepts basic text input. Additionally, you may hit up arrow and down arrow to cycle back and forth through the command history, and tab to autocomplete your current command (if more than one command is possible from your current prefix then hit it a couple of times to list all matching commands). Hitting the ` key will activate the console. Hitting it again will type the character; if you would rather it deactivated the console input as well as activating it, then you can make it do that by entering this command: +console_hotkey_lock","title":"Controls"},{"location":"systemconsole/#commands-variables","text":"You interact with the system console by typing commands into it. When you hit enter the command will be perform its action, and then output its results to the console. There is a subset of the commands which have an additional property; these are called variables , and each one stores a value (in addition to behaving like regular commands). Typically these are used for the settings which govern TTS behaviour. For example, the color command is a variable; it holds the seat color you currently occupy. Typing it without any parameters will make it output its current value, while typing it with a parameter will let you set it; you could type color red to switch to the red seat, for instance. You may also create your own variables with the store_number , store_toggle , and store_text commands (or if you are familiar with programming, their aliases: float , bool , and string ); these are especially useful when writing scripts. A lot of variables are toggles: they can be either OFF or ON . For these you can set them in an additional way; by prefixing with + , - , or ! . + will turn it on, - will turn it off, and ! will toggle it, changing it to the opposite of its current value. For example: +measure_in_metric will set measure_in_metric to ON , and !measure_logging when measure_logging is ON will set it to OFF (and vice-versa). Note that some variables are persistent - this means that they will remember their value even after you close the game. There are three commands which are extremely valuable when getting to know the console, these are: commands - Lists all non-variable commands. variables - Lists all variable commands and their current values. help - Lists all commands, with a description of what they do. You may specify a prefix when using these to have them filter to only commands which begin with it; for example you could type variables spectator to see the value of all commands which deal with the spectator window. Additionally, if you ask for help on a specific command it will give you a detailed description of how to use it. You may insert variables into commands by enclosing them in { and } . For example, typing hovered will display the GUID of the object your pointer is hovering over; spectator_camera_target {hovered} will set the spectator camera target with it. If you start a command with the @ symbol then it will be silenced; it will not output anything to the console.","title":"Commands &amp; Variables"},{"location":"systemconsole/#scripts","text":"The exec command will execute a series of commands separated either by ; or by being on separate lines. Alternatively, you may use the -v parameter to execute a text variable as a script. For example, exec -v bootexec will execute the commands in the bootexec variable (there is also a run alias, which performs exec -v , so run bootexec will do the same thing). You may also pass exec a -q parameter to make it execute in quiet mode (commands being executed are not echoed to the console, but their output is). There are two special variables: autoexec and bootexec ; these are text variables which load the contents of those two files - autoexec.cfg and bootexec.cfg , respectively - in your TTS user folder (typically C:\\Users\\<username>\\Documents\\My Games\\Tabletop Simulator ). autoexec will be executed every time you arrive at the main menu in TTS, while bootexec is only executed once, when TTS first starts up. Note that the game resets every time you go back to the main menu, so if you want to affect any settings / add bindings / etc you need to do it in autoexec Example bootexec : # Host a game for 8 players using default server name and password host_game 8 # Load game on row 4 slot 5 ui_games_click 4 5 # Switch to system console chat_tab_system # Activate spectator window +spectator_window Example autoexec : # Make easier to type versions of spectator_camera_ commands. # i.e. cam_load instead of spectator_camera_load alias cam_* spectator_camera_* # Set some settings +cam_stay_upright -spectator_show_ui # make right control have camera follow player while held # @ makes it not output to console bind +right_control @+cam_follow_player bind -right_control @-cam_follow_player # make semicolon look at object under pointer # need to add additional { } so hovered isn't evaluated immediately bind semicolon cam_look_at {{ hovered }} # make period toggle object tracking, and comma set tracked object bind period !cam_tracking bind comma cam_target {{ hovered }} # make right shift cycle through first 3 camera positions alias next_camera add cam_load_zero 1 3 bind right_shift next_camera # make some buttons to load specific camera positions ui_button 1 600 0 cam_load 1 ui_button 2 600 -30 cam_load 2 ui_button 3 600 -60 cam_load 3","title":"Scripts"},{"location":"systemconsole/#special-characters","text":"@ - Behaves as it does normally; prefix it to a command to silence that command. @@ - Two @ in a row silences the remainder of the script; each command will behave as if it had a @ before it. @@ again will disable this effect. # - At the start of a line is used for comments; the line will be ignored. : - At the start of a line is used to specify a label, which may be skipped to with the skip command. { and } - If you surround a variable with these then it will be evaluated during the script execution; you may add additional braces to delay evaluation. Whenever a command being executed has braces in its parameters it will either strip one layer off (if there is more than one), or evaluate the enclosed variable (if there is only one layer); e.g. {{hovered}} will become {hovered} , whereas {hovered} will become the component currently under the mouse pointer. You can see this used in the above autoexec . Another example; say you wanted a binding which could add a binding to another key. We add this line to the autoexec : bind right_shift bind right_control spectator_camera_target {{{ hovered }}} When the autoexec is executed and the first bind is called, the first layer of braces will be removed, so the command bound to right shift will be: bind right_control spectator_camera_target {{ hovered }} Then when you hit right shift, it will resolve so that the command bound to right control is: spectator_camera_target { hovered } Now when you hit right control while hovering over the object, the hovered object will be evaulated and passed to spectator_camera_target .","title":"Special characters"},{"location":"systemconsole/#script-commands","text":"The skip command can be used inside a script to jump forward to a label. It may not be used to jump backwards. You may give it an optional variable and then further optional comparison and value parameters: if you do it will only skip if the variable is non-zero, or the result of the comparison is true. The wait command will pause the script for the specified number of seconds. It will always wait at least one frame, so wait 0 will do just that. This can be useful in bootexec and autoexec , as some game systems may take a couple of frames to intialize; if your commands do not appear to work then try putting them at the end of the script, after a wait . Finally, the exit command will cause the script to stop executing. Example autoexec : @@ # silence script ## Set up a `private_room` variable to govern whether server is private or public # Create scripts for each mode store_text private_game_settings host_name Members Only! host_password foobar end private_game_settings store_text public_game_settings host_name All Are Welcome! host_password \"\" end public_game_settings # create variable and assign scripts store_toggle private_room alias +private_room exec -q -v private_game_settings alias -private_room exec -q -v public_game_settings # bind to key, and set to private by default bind KeypadMinus !private_room +private_room ## Set up smart chat keybinding: # Push to activate Team chat input if in team, # or Game chat input if not. store_text smart_chat skip :teamchat team chat_tab_game skip :activate :teamchat chat_tab_team :activate chat_input end smart_chat bind y @exec -v smart_chat ## Display GUID of currently held object, # or if nothing held then currently hovered object. store_text echo_guid_script skip :held grabbed echo {{ hovered }} exit :held echo {{ grabbed }} end echo_guid_script alias echo_guid exec -q -v echo_guid_script bind KeypadEnter echo_guid ## Create key to Tap/Untap card (turn 90 degreees / set upright) # Use seat hand zone rotation to work out orientation. string guid \"\" float facing float y bool untapped string tap_script # use \"\" so if not hovering variable will be cleared guid \"{{hovered}}\" skip :ok guid exit :ok # Find hand zone facing. It faces the player, so spin it 180. component_examine {{ color }} eval facing ( examine_rotation.y - 180 ) % 360 # Is card currently tapped? component_examine {{ guid }} eval y examine_rotation.y % 360 eval untapped ! (( y - 90 < facing + 10 && y - 90 > facing - 10 ) || ( y + 270 < facing + 10 && y + 270 > facing - 10 )) # Bump card up a bit into the air (0.5 along Y axis). component_move {{ guid }} -f - 0 .5 - skip :tap untapped :untap # Set rotation to player facing. Use `-` on X and Z axis so they are unaffected. component_rotation {{ guid }} -f - {{ facing }} - exit :tap eval y facing + 90 component_rotation {{ guid }} -f - {{ y }} - end tap_script bind Mouse4 @run tap_script","title":"Script commands"},{"location":"systemconsole/#some-useful-commands","text":"As noted above, help , commands , and variables will let you find out everything you can do with the system console. Having said that, here is a selection of some of the more useful commands available: add , subtract , and multiply will let you do simple arithmetic on a variable. add is useful for cycling a modal variable (it has an optional third parameter which sets a modulus), while subtract subtracts the variable from the value, so is useful for ping-ponging between two numbers. alias is overloaded with several functions: Its basic use is to create a new name for another command, while retaining any parameters you type in. Good for making shorter names for commands you use a lot. Use with store_text and exec to make your own commands from scripts. It can also be used to attach commands to each value of a toggle variable, which will run when the variable is set to that value. You can see this in the example script above, with the private_room variable. Finally, if there are a collection of commands sharing a prefix which you want to make short versions of you can use * to do so (e.g. alias cam_* spectator_camera_* ) append will append text to a text variable. If you only provide the variable parameter, without text, it will append the last entered command. This is useful for adding commands to autoexec ; you can try the command out in the console until you get it correct, before appending it to the script. bind , unbind control attaching commands to keypresses. You may use + and - before the keycode to specify if you want it to trigger on press or release , respectively. (list of Unity keycodes) broadcast will broadcast the provided message. chat_font_size sets the size of the font in the chat / console window. clear will clear a text variable. color reports/sets your player color. component_examine lets you specify a component, which can then be examined with the examine_position and examine_rotation variables. If you specify a color then that seat's primary hand zone will be examined instead. component_move , component_rotate , component_position , component_rotation let you apply movements to components. The first two add the specified vector to the component's current position/rotation, while the second two set it to the specified vector in world space. You may use '-' in place of a vector axis to indicate that axis is to be left alone. console_hotkey_lock When enabled, locks whichever key is bound to toggling the system console, so that hitting it always toggles the console (this makes the key untypeable in text input boxes). default_host_name and default_password set those values. dice_roll_height_multiplier sets how high dice go when randomized. displays outputs information on currently connected monitors. drawing_erase_all erases all drawings. drawing_render_fully_visible will cause drawings to render fully in 3d space (which is neat if you have VR) echo displays its parameters in the system console. edit allow you to edit a text variable with the in-game GUI (you may also do this by passing the variable the -e parameter, e.g. autoexec -e ) escape will display a text variable in the console, and will escape all the formatting characters (i.e. all the [ and ] characters). eval sets a variable by evaluating a formula. Most arithmetic operators and functions are provided. You may also refer to vector axes, i.e. examine_rotation.y . find finds a component on the table. grabbed , hovered output the GUID of the component you are interacting with. highlight a component. host_game creates a table; you can specify single player, multiplayer, or hotseat. host_name and host_password set those values for current game. last is a special variable which holds the value returned from the most recent command. lua executes lua code as if run by the current mod. mirror_all will mirror all text displayed in every other chat tab into the system console. This means you can always be in the system console without missing any messages. quiet_mode will, when enabled, stop command names being echoed in the console. Unlike silencing commands with @ , this will still display the commands' output. reset will reset a persistent variable to its default value. sendkey will emulate a keypress. Primarily useful for binding things to VR controllers. status will display some key information about the current game. stats_monitor will display some graphs/info which update in real time. team reports/sets your team. ui_anchor lets you set the position on the screen which custom UI components are placed relative to. It defaults to 0,0 which is the center of the screen. ui_button / ui_label / ui_toggle will add custom UI components to the screen which will, respectively, perform a command when clicked / display some text / be attached to a toggle variable. ui_dialog_input will display the text entry UI, and store the typed text in last . ui_games_click will click on a button on the game select UI, if it is open. ui_games_hide will hide the game select UI without clicking on anything. wait is a command which can be inserted into a script to cause it to pause for some amount of time. Useful for fudging a script to work with asynchronous commands which take some time to execute. Commands are named with their topic first, so commands which affect the same part of the game have the same prefix. The following are some useful groups of commands: get more info on them by running help prefix_ . For instance, help camera_ camera_ commands control the position and behaviour of the player camera (i.e. your point-of-view) chat_ commands control the chat window. component_ commands deal with the game components on the table. Notably the component_default_ commands let you specify what toggles new component are created with, which is useful if you are creating a lot of similar components. errors_ commands handle how Lua errors are displayed. jigsaw_ commands let you mess with jigsaws. log_ commands control formatting of lua log calls. mirror_ commands govern mirroring text from other tabs into the system console. mod_ commands control various performance settings when loading mods. music_ commands let you control the in-game music player. say_ commands let you output messages to the chat channels. spectator_ commands control the spectator view. timestamp_ commands let you add timestamps to the chat channels / console. tool_ commands let you check and set the currently used tool (grab, draw, etc). ui_ commands deal with the game's User Interface. vr_ commands perform all VR related tasks.","title":"Some useful commands"},{"location":"tables/","text":"The static global Tables class provides the ability to interact with the Table object. Example Usage: Tables . getTable () . Function Summary Function Name Description Return getTable() Returns a string representation of the Table object. setTable( name) Changes the Table object. getCustomURL() Returns the url of the image for Custom Rectangle and Custom Square. setCustomURL( url) Changes the image for Custom Rectangle and Custom Square getTableObject() Returns a reference to the Table object.","title":"Tables"},{"location":"tables/#function-summary","text":"Function Name Description Return getTable() Returns a string representation of the Table object. setTable( name) Changes the Table object. getCustomURL() Returns the url of the image for Custom Rectangle and Custom Square. setCustomURL( url) Changes the image for Custom Rectangle and Custom Square getTableObject() Returns a reference to the Table object.","title":"Function Summary"},{"location":"texttool/","text":"TextTool is a special Object type for creating text labels in the game instance. It is the same text that is created with the text tool . You call these functions like this: self.TextTool.getFontColor() . Function Summary Object Functions Function Name Description Return getFontColor() Returns Table of font Color. getFontSize() Returns Int of the font size. getValue() Returns the current text. Works the same as Object's getValue() . setFontColor( font_color) Sets font Color. setFontSize( font_size) Sets font size. setValue( text) Sets the current text. Works the same as Object's setValue(...) .","title":"TextTool"},{"location":"texttool/#function-summary","text":"","title":"Function Summary"},{"location":"texttool/#object-functions","text":"Function Name Description Return getFontColor() Returns Table of font Color. getFontSize() Returns Int of the font size. getValue() Returns the current text. Works the same as Object's getValue() . setFontColor( font_color) Sets font Color. setFontSize( font_size) Sets font size. setValue( text) Sets the current text. Works the same as Object's setValue(...) .","title":"Object Functions"},{"location":"time/","text":"Time (not to be confused with the devalued Timer class) is a static global class which provides access to Unity's time information. Example Usage: Time.time Member Variables All of the member variables of time are read only. Function Name Description Return time Returns the current time. Works like os.time() but is more accurate. delta_time Returns the amount of time since the last frame. fixed_time Returns a number like time does, but using Fixed updates. fixed_delta_time Returns a number like delta_time does, but using Fixed updates. frame_count Returns the amount of total frames since the scene began.","title":"Time"},{"location":"time/#member-variables","text":"All of the member variables of time are read only. Function Name Description Return time Returns the current time. Works like os.time() but is more accurate. delta_time Returns the amount of time since the last frame. fixed_time Returns a number like time does, but using Fixed updates. fixed_delta_time Returns a number like delta_time does, but using Fixed updates. frame_count Returns the amount of total frames since the scene began.","title":"Member Variables"},{"location":"timer/","text":"Timer is a static global class which provides methods for executing other functions after a delay and/or repeatedly. Each Timer is tracked by a unique \"identifier\" string. Example Usage: Timer.destroy(...) Important Tip The \"identifiers\" are shared between Global and all Object scripts, so each Timer must have a unique name. Function Summary Function Name Description Return create( parameters) Creates a Timer. It will auto-delete once its repetitions have been completed. destroy( identifier) Destroys a Timer. Function Details create(...) Creates a Timer. It will auto-delete once its repetitions have been completed. create(parameters) parameters : A Table containing the information used to start the Timer. identifier : Timer's name, used to destroy it. Must be unique within all other scripts. function_name : Name of function to trigger when time is reached. function_owner : Where the function from function_name exists. Optional, defaults to the calling Object. parameters : Table containing any data that will be passed to the function. Optional, will not be used by default. delay : Length of time in seconds before the function is triggered. Optional, defaults to 0. 0 results in a delay of 1 frame before the triggered function activates. repetitions : Number of times the countdown repeats. Optional, defaults to 1. Use 0 for infinite repetitions. function onLoad () dataTable = { welcome = \"Hello World!\" } Timer . create ({ identifier = \"A Unique Name\" , function_name = \"fiveAfterOne\" , parameters = dataTable , delay = 1 , repetitions = 5 , }) end function fiveAfterOne ( params ) print ( params . welcome ) end Tip If your timer is on an Object, a good way to establish a unique identifier for it is to use the item's GUID! destroy(...) Destroys a Timer. A timer, if it completes its number of repetitions, will automatically destroy itself. destroy(identifier) identifier : The unique identifier for the timer you want to destroy.","title":"Timer"},{"location":"timer/#function-summary","text":"Function Name Description Return create( parameters) Creates a Timer. It will auto-delete once its repetitions have been completed. destroy( identifier) Destroys a Timer.","title":"Function Summary"},{"location":"timer/#function-details","text":"","title":"Function Details"},{"location":"timer/#create","text":"Creates a Timer. It will auto-delete once its repetitions have been completed. create(parameters) parameters : A Table containing the information used to start the Timer. identifier : Timer's name, used to destroy it. Must be unique within all other scripts. function_name : Name of function to trigger when time is reached. function_owner : Where the function from function_name exists. Optional, defaults to the calling Object. parameters : Table containing any data that will be passed to the function. Optional, will not be used by default. delay : Length of time in seconds before the function is triggered. Optional, defaults to 0. 0 results in a delay of 1 frame before the triggered function activates. repetitions : Number of times the countdown repeats. Optional, defaults to 1. Use 0 for infinite repetitions. function onLoad () dataTable = { welcome = \"Hello World!\" } Timer . create ({ identifier = \"A Unique Name\" , function_name = \"fiveAfterOne\" , parameters = dataTable , delay = 1 , repetitions = 5 , }) end function fiveAfterOne ( params ) print ( params . welcome ) end Tip If your timer is on an Object, a good way to establish a unique identifier for it is to use the item's GUID!","title":"create(...)"},{"location":"timer/#destroy","text":"Destroys a Timer. A timer, if it completes its number of repetitions, will automatically destroy itself. destroy(identifier) identifier : The unique identifier for the timer you want to destroy.","title":"destroy(...)"},{"location":"turns/","text":"Turns, a static global class, is the in-game turns system. It allows you to modify the player turns in the same way that the in-game Turns menu does. Example usage: Turns.reverse_order = true . Member Variables Like Object member variables , Turns has its own member variables. Variable Description Type enable Enable/disable the turns system. type If the turn order is automatic or custom. 1=auto, 2=custom. order A table of strings, representing the player turn order. reverse_order Enable/disable reversing turn rotation direction. skip_empty_hands Enable/disable skipping empty hands. disable_interactations Enable/disable the blocking of players ability to interact with Objects when it is not their turn. pass_turns Enable/disable a player's ability to pass their turn to another. turn_color The color of the Player who's turn it is. Function Summary Functions Function Name Description Return getNextTurnColor() Returns the Player Color string of the next player in the turn order. getPreviousTurnColor() Returns the Player Color string of the previous player in the turn order.","title":"Turns"},{"location":"turns/#member-variables","text":"Like Object member variables , Turns has its own member variables. Variable Description Type enable Enable/disable the turns system. type If the turn order is automatic or custom. 1=auto, 2=custom. order A table of strings, representing the player turn order. reverse_order Enable/disable reversing turn rotation direction. skip_empty_hands Enable/disable skipping empty hands. disable_interactations Enable/disable the blocking of players ability to interact with Objects when it is not their turn. pass_turns Enable/disable a player's ability to pass their turn to another. turn_color The color of the Player who's turn it is.","title":"Member Variables"},{"location":"turns/#function-summary","text":"","title":"Function Summary"},{"location":"turns/#functions","text":"Function Name Description Return getNextTurnColor() Returns the Player Color string of the next player in the turn order. getPreviousTurnColor() Returns the Player Color string of the previous player in the turn order.","title":"Functions"},{"location":"types/","text":"Type refers to the type of information being used. You do not need to declare a type in Lua, but in this API you will see them indicated. This is only so you know what kind of information is required in a given variable/parameter. This API utilizes the following types. Common Standards Tag Type Description Example nil No value. nil int Non-decimal value. 5 float Non-exact decimal value. 2.032 bool true or false value. true string A series of characters. \"Hello.\" table A container with keys and values. {[ \"key\" ] = \"value\" , true , 5 } vector See section Vector for more info. color See section Color for more info. function See section Function for more info. object An in-game physical Object. Sometimes Global. Global or self player An in-game Player. See Player for more info. Player [ \"White\" ] variable A combination of other types. See below for more info. For more information on a type, you can read below or refer to the relevant Lua documentation . Special Standards Some types need to be used in specific ways. For Color and Vector, they are Tables that are used often in Tabletop Simulator. They represent Vectors and Colors, and their contents must be formatted a certain way to be utilized correctly. For Functions, they are used when a delay is required within a running script that have specific requirements. Color Color is a type of Table that is used to define RGB values for tinting. You can use the Color class to manipulate colors. Keys The Table will contain the keys r , g , b , a and/or 1 , 2 , 3 , 4 . The letter and numeric keys are duplicates of each other, and each represents a color or transparency. Color Letter Key Number Key red r 1 green g 2 blue b 3 alpha a 4 As an example, an Object with a white color tint would return this table: { r = 1 , g = 1 , b = 1 , 1 = 1 , 2 = 1 , 3 = 1 , } Notice it does not contain the a or 4 keys. This is because currently only scripted buttons and scripted inputs utilize the alpha channel (transparency). Mixed Keys Only one type of key, number or letter, is required. If both a are present in a Table, the numeric key is ignored and only the letter key is used. --Valid Table for red { r = 1 , g = 0 , b = 0 } --Valid Table for blue { 0 , 0 , 1 } --This Table would be red. { r = 1 , g = 0 , b = 0 , 0 , 0 , 1 } Value Values are between 0 and 1 for each key. If you are using RGB color that is in 0-255, you can use simple math to convert to the proper value. --To display a color that is r=50, b=83, g=199 self . setColorTint ({ 50 / 255 , 83 / 255 , 199 / 255 }) Strings You are also able to use a String in place of a color table. Using a Player Color will automatically fill in that value. It works with any of the 12 color names, as they are written on the Player Color page. Example: printToAll(\"Test\", \"Green\") Vector Vector is a type of Object with x, y, and z coordinates that is used to define a position, rotation or direction. You can use the Vector class to manipulate vectors. Example: target = Vector ( 1 , 0 , 0 ) + Vector ( 0 , 2 , 0 ): normalized () Keys The Table will contain the keys x , y , z and/or 1 , 2 , 3 . The letter and numeric keys are equivalent. Letter Key Number Key x 1 y 2 z 3 As an example, An Object at coordinate X=5, Y=2, Z=-1 would return this Vector : { x = 5 , y = 2 , z =- 1 , } Mixed Keys Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there. Value Range The range of values depend on the type of Vector you are using. Type Description Range Position A point in space. Any number within the bounds of the world. Rotation Angle, in degrees. -180 to 180. Direction Vector direction. -1 to 1. Type Details Position X is right/left, Y is up/down, Z is forward/back. A positional Vector can be either world or local. Most of Tabletop Simulator's functions use world positional Vectors. Type Description World The center of the instance is {x=0, y=0, z=0} . That is usually near the tabletop's center. Local The center of the Object's model is {x=0, y=0, z=0} . The center of an Object is determined by the model's creator. Conversion Between World/Local positionToWorld(...) and positionToLocal(...) can be used to convert between the two types. Rotation X is pitch (nodding your head), Y is yaw (shaking your head), Z is roll (tilting your head). Direction X is right/left, Y is up/down, Z is forward/back. Function A function is a section of code that can be run when triggered. In Lua, you are able to pass (use as a parameter) functions. Some elements in Tabletop Simulator can be passed functions to perform some action with, like triggering it after a delay. Usage To pass a function, first you must create the function. There are multiple ways to do this: --Create it on-the-fly function () print ( \"Like This\" ) end --Create it with a variable name anyFuncName = function () print ( \"Like This\" ) end --Create it with a variable name that can also be passed parameters function anyFuncName ( printString ) print ( printString ) end Warning You need to pass a function, not a result of a function. So this will not work: Wait . frames ( print ( \"Ding\" ), 80 ) Instead, make the print the result of a function running: Wait . frames ( function () print ( \"Ding\" ) end , 80 ) Example As an example, here is Wait.frames(...) used 3 times. It waits a set number of frames and then activates a given function: function onLoad () --Built-in functions with parameters can be called directly --This is done by wrapping the function within `function()` and `end` Wait . frames ( function () print ( \"One\" ) end , 60 ) --You can also call custom functions you have made yourself --Pass them any parameters you wish Wait . frames ( function () sayTwo ( \"Two\" ) end , 120 ) --If you aren't passing any parameters to the function, you can shorten it Wait . frames ( sayThree , 180 ) end --Has its parameter passed to it function sayTwo ( s ) print ( s ) end --Does not have any parameters passed to it function sayThree () print ( \"Three\" ) end Lambda-Style Expressions You are able to replace function() and end with || , allowing for much shorter functions. Important Tips You create a | , on a standard keyboard, by holding shift and pressing the key above enter (backslash). || only work for one line. So if you intend to use a multi-line function, lambda-style will not be an option. When using || for a conditional function with Wait.condition(returnFunc, conditionalFunc) , you do not need to include return. If a parameter is passed to the return function, like with callback_function from spawnObject(...) , you can put a variable between the || characters to represent it. See the next section for an example. Lambda-Style Example Without Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = function ( obj ) printCardCount ( obj ) end }) --Print after 1 second Wait . time ( function () print ( \"One Second\" ) end , 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( function () printString ( \"Two Seconds\" ) end , 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end With Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = | obj | printCardCount ( obj ) }) --Print after 1 second Wait . time ( || print ( \"One Second\" ), 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( || printString ( \"Two Seconds\" ), 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end","title":"Types"},{"location":"types/#common-standards","text":"Tag Type Description Example nil No value. nil int Non-decimal value. 5 float Non-exact decimal value. 2.032 bool true or false value. true string A series of characters. \"Hello.\" table A container with keys and values. {[ \"key\" ] = \"value\" , true , 5 } vector See section Vector for more info. color See section Color for more info. function See section Function for more info. object An in-game physical Object. Sometimes Global. Global or self player An in-game Player. See Player for more info. Player [ \"White\" ] variable A combination of other types. See below for more info. For more information on a type, you can read below or refer to the relevant Lua documentation .","title":"Common Standards"},{"location":"types/#special-standards","text":"Some types need to be used in specific ways. For Color and Vector, they are Tables that are used often in Tabletop Simulator. They represent Vectors and Colors, and their contents must be formatted a certain way to be utilized correctly. For Functions, they are used when a delay is required within a running script that have specific requirements.","title":"Special Standards"},{"location":"types/#color","text":"Color is a type of Table that is used to define RGB values for tinting. You can use the Color class to manipulate colors.","title":"Color"},{"location":"types/#keys","text":"The Table will contain the keys r , g , b , a and/or 1 , 2 , 3 , 4 . The letter and numeric keys are duplicates of each other, and each represents a color or transparency. Color Letter Key Number Key red r 1 green g 2 blue b 3 alpha a 4 As an example, an Object with a white color tint would return this table: { r = 1 , g = 1 , b = 1 , 1 = 1 , 2 = 1 , 3 = 1 , } Notice it does not contain the a or 4 keys. This is because currently only scripted buttons and scripted inputs utilize the alpha channel (transparency).","title":"Keys"},{"location":"types/#mixed-keys","text":"Only one type of key, number or letter, is required. If both a are present in a Table, the numeric key is ignored and only the letter key is used. --Valid Table for red { r = 1 , g = 0 , b = 0 } --Valid Table for blue { 0 , 0 , 1 } --This Table would be red. { r = 1 , g = 0 , b = 0 , 0 , 0 , 1 }","title":"Mixed Keys"},{"location":"types/#value","text":"Values are between 0 and 1 for each key. If you are using RGB color that is in 0-255, you can use simple math to convert to the proper value. --To display a color that is r=50, b=83, g=199 self . setColorTint ({ 50 / 255 , 83 / 255 , 199 / 255 })","title":"Value"},{"location":"types/#strings","text":"You are also able to use a String in place of a color table. Using a Player Color will automatically fill in that value. It works with any of the 12 color names, as they are written on the Player Color page. Example: printToAll(\"Test\", \"Green\")","title":"Strings"},{"location":"types/#vector","text":"Vector is a type of Object with x, y, and z coordinates that is used to define a position, rotation or direction. You can use the Vector class to manipulate vectors. Example: target = Vector ( 1 , 0 , 0 ) + Vector ( 0 , 2 , 0 ): normalized ()","title":"Vector"},{"location":"types/#keys_1","text":"The Table will contain the keys x , y , z and/or 1 , 2 , 3 . The letter and numeric keys are equivalent. Letter Key Number Key x 1 y 2 z 3 As an example, An Object at coordinate X=5, Y=2, Z=-1 would return this Vector : { x = 5 , y = 2 , z =- 1 , }","title":"Keys"},{"location":"types/#mixed-keys_1","text":"Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there.","title":"Mixed Keys"},{"location":"types/#value-range","text":"The range of values depend on the type of Vector you are using. Type Description Range Position A point in space. Any number within the bounds of the world. Rotation Angle, in degrees. -180 to 180. Direction Vector direction. -1 to 1.","title":"Value Range"},{"location":"types/#type-details","text":"","title":"Type Details"},{"location":"types/#position","text":"X is right/left, Y is up/down, Z is forward/back. A positional Vector can be either world or local. Most of Tabletop Simulator's functions use world positional Vectors. Type Description World The center of the instance is {x=0, y=0, z=0} . That is usually near the tabletop's center. Local The center of the Object's model is {x=0, y=0, z=0} . The center of an Object is determined by the model's creator. Conversion Between World/Local positionToWorld(...) and positionToLocal(...) can be used to convert between the two types.","title":"Position"},{"location":"types/#rotation","text":"X is pitch (nodding your head), Y is yaw (shaking your head), Z is roll (tilting your head).","title":"Rotation"},{"location":"types/#direction","text":"X is right/left, Y is up/down, Z is forward/back.","title":"Direction"},{"location":"types/#function","text":"A function is a section of code that can be run when triggered. In Lua, you are able to pass (use as a parameter) functions. Some elements in Tabletop Simulator can be passed functions to perform some action with, like triggering it after a delay.","title":"Function"},{"location":"types/#usage","text":"To pass a function, first you must create the function. There are multiple ways to do this: --Create it on-the-fly function () print ( \"Like This\" ) end --Create it with a variable name anyFuncName = function () print ( \"Like This\" ) end --Create it with a variable name that can also be passed parameters function anyFuncName ( printString ) print ( printString ) end Warning You need to pass a function, not a result of a function. So this will not work: Wait . frames ( print ( \"Ding\" ), 80 ) Instead, make the print the result of a function running: Wait . frames ( function () print ( \"Ding\" ) end , 80 )","title":"Usage"},{"location":"types/#example","text":"As an example, here is Wait.frames(...) used 3 times. It waits a set number of frames and then activates a given function: function onLoad () --Built-in functions with parameters can be called directly --This is done by wrapping the function within `function()` and `end` Wait . frames ( function () print ( \"One\" ) end , 60 ) --You can also call custom functions you have made yourself --Pass them any parameters you wish Wait . frames ( function () sayTwo ( \"Two\" ) end , 120 ) --If you aren't passing any parameters to the function, you can shorten it Wait . frames ( sayThree , 180 ) end --Has its parameter passed to it function sayTwo ( s ) print ( s ) end --Does not have any parameters passed to it function sayThree () print ( \"Three\" ) end","title":"Example"},{"location":"types/#lambda-style-expressions","text":"You are able to replace function() and end with || , allowing for much shorter functions.","title":"Lambda-Style Expressions"},{"location":"types/#important-tips","text":"You create a | , on a standard keyboard, by holding shift and pressing the key above enter (backslash). || only work for one line. So if you intend to use a multi-line function, lambda-style will not be an option. When using || for a conditional function with Wait.condition(returnFunc, conditionalFunc) , you do not need to include return. If a parameter is passed to the return function, like with callback_function from spawnObject(...) , you can put a variable between the || characters to represent it. See the next section for an example.","title":"Important Tips"},{"location":"types/#lambda-style-example","text":"Without Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = function ( obj ) printCardCount ( obj ) end }) --Print after 1 second Wait . time ( function () print ( \"One Second\" ) end , 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( function () printString ( \"Two Seconds\" ) end , 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end With Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = | obj | printCardCount ( obj ) }) --Print after 1 second Wait . time ( || print ( \"One Second\" ), 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( || printString ( \"Two Seconds\" ), 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end","title":"Lambda-Style Example"},{"location":"ui/","text":"UI, a static global class AND an Object class. It is the method to interact with custom UI elements. It allows you to read/write attributes of elements defined in the XML of the UI. It also allows you to receive information from various inputs (like buttons) on-screen and on objects. Attention This class allows for the manipulation of UI at runtime . It does NOT modify or fetch the original XML in the editor, but rather what is displayed as it continues to run during a game. Just like with Lua, you can only get/set dynamic values during runtime. You can use onSave and onLoad to record any data you want to persist through save/load/undo. For more information on how to build UI elements within XML, view the UI API . Global and Object UI can either be placed on the screen by using the Global UI or placed on an Object using Object UI . Depending on which you are using, these commands are used differently. Example of calling a function targeted at the Global UI: UI.getAttributes(id) Example of calling a function targeted at an Object UI: object.UI.getAttributes(id) Inputs Input Elements are able to trigger a function. By default, Global UI will trigger a function in Global and Object UI will trigger a function in the Object's script. To change the target script for an input, view more details here . When creating the input element in XML, you will select the name of the function it activates. Regardless of its name, it always will pass parameters functionName(player, value, id) player : A direct Player reference to the person that triggered the input. value : The value sent by the input. A numeric value or a string, generally. This is not used by buttons! id : This is only passed if the element was given an Id attribute in the XML. function onButtonClick ( player , value , id ) print ( player . steam_name ) print ( id ) end Member Variable Summary Variable Description Type loading Indicates whether (the server) has finished loading all UI custom assets. Function Summary Function Name Description Return getAttribute( id, attribute) Obtains the value of a specified attribute of a UI element. getAttributes( id) Returns the attributes and their values of a UI element. getCustomAssets() Returns information on all custom assets uploaded to the UI ASSETS pane. getValue( id) Obtains the value between elements tags, like: <Text>ValueToGet</Text> getXml() Returns the run-time UI's XML in string format. getXmlTable() Returns the run-time UI's XML formatted as a Lua table. hide( id) Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. setAttribute( id, attribute, value) Sets the value of a specified attribute of a UI element. setAttributes( id, data) Updates the value of the supplied attributes of a UI element. setClass( id, names) Replaces all classes on a UI element. setCustomAssets( assets) Sets the UI ASSETS (like custom images) for global or an Object. setValue( id, value) Updates the value between elements tags, like: <Text>ValueChanged</Text> setXml( xml) Replaces the run-time UI with the XML string. setXmlTable( data) Replaces the run-time UI with an XML string which is generated from a table of data. show( id) Displays the given UI element. Unlike the \"active\" attribute, show triggers animations. Function Details getAttribute(...) Obtains the value of a specified attribute of a UI element. What it returns will typically be a string or a number. getAttribute(id, attribute) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you wish to get the value of. self . UI . getAttribute ( \"testElement\" , \"fontSize\" ) getAttributes(...) Returns the attributes and their values of a UI element. It only returns the attributes (and values) for elements that have had those attributes set by the user. getAttributes(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. Return table parameters : A Table with the attributes as keys and their XML value as the key's value. texture : The name of the image element color : The hex used for the color element's value. IMPORTANT : This return table is an example of one you may get back from using it on a RawImage element type. The attribute keys you get back and their values will depend on the element you use the function on as well as the attributes you, the user, have assigned to it. getCustomAssets() Returns information on all custom assets uploaded to the UI ASSETS pane. Return table table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = UI . getCustomAssets () log ( assets ) end getValue(...) Obtains the value between elements tags, like: <Text>ValueObtained</Text> getValue(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. string = UI . getValue ( \"testElement\" ) print ( string ) getXmlTable() Obtain the run-time UI formatted as a Lua table of data. Example Returned Table: { { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } } What the XML would look like which returns that table: <HorizontalLayout height= \"200\" width= \"1000\" color= \"rgba(0,0,0,0.7)\" > <Text fontSize= \"100\" color= \"red\" > Example </Text> <Text text= \"Message\" fontSize= \"100\" color= \"blue\" /> </HorizontalLayout> hide(...) Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. hide(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . hide ( \"testElement\" ) setAttribute(...) Sets the value of a specified attribute of a UI element. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttribute(id, attribute, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you want to set the value of. value : The value to set for the attribute. self . UI . setAttribute ( \"testElement\" , \"fontSize\" , 200 ) setAttributes(...) Updates the value of the supplied attributes of a UI element. You do not need to set every attribute with the data table, an element will continue using any previous values you do not overwrite. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttributes(id, data) id : The Id that was assigned, as an attribute, to the desired XML UI element. data : A Table with key/value pairs representing attributes and their values. Example data table data : A Table with parameters which guide the function. data.fontSize : Attribute's desired value value data.color : Attribute's desired value IMPORTANT : This table is an example of one you may use when setting a text UI element. The attribute keys you use and their values will depend on the element you use the function on. attributeTable = { fontSize = 300 , color = \"#000000\" } self . UI . setAttributes ( \"exampleText\" , attributeTable ) setClass(...) Replaces all classes on a UI element. setClass(id, names) id : The ID of the UI element that should have its classes replaced. names : Space separated class names. Example Replace all classes on the element with ID someElementId with two classes \"important\" and \"large\". UI . setClass ( \"someElementId\" , \"important large\" ) setCustomAssets(...) Sets the UI ASSETS (like custom images) for Global or an Object. Passing nothing as a parameter results in the clearing of the UI Assets. This function will overwrite any currently existing assets in Custom UI Assets, not add to them. setCustomAssets(table) table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = { { name = \"Image 1\" , url = \"http://placehold.it/120x120&text=image1\" }, { name = \"Image 2\" , url = \"http://placehold.it/120x120&text=image2\" }, } UI . setCustomAssets ( assets ) end setValue(...) Updates the value between elements tags, like: <Text>ValueChanged</Text> setValue(id, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. value : The value to put between the element tags. UI . setValue ( \"testElement\" , \"New Text To Display\" ) setXml(...) Replaces the run-time UI with the XML string. setXml(xml) xml : A single string with the contents of the XML to use self . UI . setXml ( \"<Text>Test</Text>\" ) Warning setXml takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly. setXmlTable(...) Replaces the run-time UI with an XML string which is generated from a table of data. setXmlTable(data) data : A table containing sub-tables. One sub-table for each element being created. tag : The element type. attributes : A table containing attribute names for keys. Available attribute types depend on tag's element type. Optional, defaults to not being used. Example key/value pairs: text=\"Test\", color=\"black\" value : Text that appears <Text>Here</Text> , between the <> and ``. Optional, defaults to an empty string. children : A table containing more sub-tables, formatted as above. This does mean the sub-tables can contain their own children as well, containing sub-sub tables, etc. Optional, defaults to not being used. function onLoad () UI . setXmlTable ({ { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } }) end Warning setXmlTable takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly. show(...) Shows the given UI element. Unlike the \"active\" attribute, show triggers animations. show(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . show ( \"testElement\" )","title":"UI"},{"location":"ui/#global-and-object","text":"UI can either be placed on the screen by using the Global UI or placed on an Object using Object UI . Depending on which you are using, these commands are used differently. Example of calling a function targeted at the Global UI: UI.getAttributes(id) Example of calling a function targeted at an Object UI: object.UI.getAttributes(id)","title":"Global and Object"},{"location":"ui/#inputs","text":"Input Elements are able to trigger a function. By default, Global UI will trigger a function in Global and Object UI will trigger a function in the Object's script. To change the target script for an input, view more details here . When creating the input element in XML, you will select the name of the function it activates. Regardless of its name, it always will pass parameters functionName(player, value, id) player : A direct Player reference to the person that triggered the input. value : The value sent by the input. A numeric value or a string, generally. This is not used by buttons! id : This is only passed if the element was given an Id attribute in the XML. function onButtonClick ( player , value , id ) print ( player . steam_name ) print ( id ) end","title":"Inputs"},{"location":"ui/#member-variable-summary","text":"Variable Description Type loading Indicates whether (the server) has finished loading all UI custom assets.","title":"Member Variable Summary"},{"location":"ui/#function-summary","text":"Function Name Description Return getAttribute( id, attribute) Obtains the value of a specified attribute of a UI element. getAttributes( id) Returns the attributes and their values of a UI element. getCustomAssets() Returns information on all custom assets uploaded to the UI ASSETS pane. getValue( id) Obtains the value between elements tags, like: <Text>ValueToGet</Text> getXml() Returns the run-time UI's XML in string format. getXmlTable() Returns the run-time UI's XML formatted as a Lua table. hide( id) Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. setAttribute( id, attribute, value) Sets the value of a specified attribute of a UI element. setAttributes( id, data) Updates the value of the supplied attributes of a UI element. setClass( id, names) Replaces all classes on a UI element. setCustomAssets( assets) Sets the UI ASSETS (like custom images) for global or an Object. setValue( id, value) Updates the value between elements tags, like: <Text>ValueChanged</Text> setXml( xml) Replaces the run-time UI with the XML string. setXmlTable( data) Replaces the run-time UI with an XML string which is generated from a table of data. show( id) Displays the given UI element. Unlike the \"active\" attribute, show triggers animations.","title":"Function Summary"},{"location":"ui/#function-details","text":"","title":"Function Details"},{"location":"ui/#getattribute","text":"Obtains the value of a specified attribute of a UI element. What it returns will typically be a string or a number. getAttribute(id, attribute) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you wish to get the value of. self . UI . getAttribute ( \"testElement\" , \"fontSize\" )","title":"getAttribute(...)"},{"location":"ui/#getattributes","text":"Returns the attributes and their values of a UI element. It only returns the attributes (and values) for elements that have had those attributes set by the user. getAttributes(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. Return table parameters : A Table with the attributes as keys and their XML value as the key's value. texture : The name of the image element color : The hex used for the color element's value. IMPORTANT : This return table is an example of one you may get back from using it on a RawImage element type. The attribute keys you get back and their values will depend on the element you use the function on as well as the attributes you, the user, have assigned to it.","title":"getAttributes(...)"},{"location":"ui/#getcustomassets","text":"Returns information on all custom assets uploaded to the UI ASSETS pane. Return table table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = UI . getCustomAssets () log ( assets ) end","title":"getCustomAssets()"},{"location":"ui/#getvalue","text":"Obtains the value between elements tags, like: <Text>ValueObtained</Text> getValue(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. string = UI . getValue ( \"testElement\" ) print ( string )","title":"getValue(...)"},{"location":"ui/#getxmltable","text":"Obtain the run-time UI formatted as a Lua table of data. Example Returned Table: { { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } } What the XML would look like which returns that table: <HorizontalLayout height= \"200\" width= \"1000\" color= \"rgba(0,0,0,0.7)\" > <Text fontSize= \"100\" color= \"red\" > Example </Text> <Text text= \"Message\" fontSize= \"100\" color= \"blue\" /> </HorizontalLayout>","title":"getXmlTable()"},{"location":"ui/#hide","text":"Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. hide(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . hide ( \"testElement\" )","title":"hide(...)"},{"location":"ui/#setattribute","text":"Sets the value of a specified attribute of a UI element. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttribute(id, attribute, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you want to set the value of. value : The value to set for the attribute. self . UI . setAttribute ( \"testElement\" , \"fontSize\" , 200 )","title":"setAttribute(...)"},{"location":"ui/#setattributes","text":"Updates the value of the supplied attributes of a UI element. You do not need to set every attribute with the data table, an element will continue using any previous values you do not overwrite. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttributes(id, data) id : The Id that was assigned, as an attribute, to the desired XML UI element. data : A Table with key/value pairs representing attributes and their values. Example data table data : A Table with parameters which guide the function. data.fontSize : Attribute's desired value value data.color : Attribute's desired value IMPORTANT : This table is an example of one you may use when setting a text UI element. The attribute keys you use and their values will depend on the element you use the function on. attributeTable = { fontSize = 300 , color = \"#000000\" } self . UI . setAttributes ( \"exampleText\" , attributeTable )","title":"setAttributes(...)"},{"location":"ui/#setclass","text":"Replaces all classes on a UI element. setClass(id, names) id : The ID of the UI element that should have its classes replaced. names : Space separated class names. Example Replace all classes on the element with ID someElementId with two classes \"important\" and \"large\". UI . setClass ( \"someElementId\" , \"important large\" )","title":"setClass(...)"},{"location":"ui/#setcustomassets","text":"Sets the UI ASSETS (like custom images) for Global or an Object. Passing nothing as a parameter results in the clearing of the UI Assets. This function will overwrite any currently existing assets in Custom UI Assets, not add to them. setCustomAssets(table) table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = { { name = \"Image 1\" , url = \"http://placehold.it/120x120&text=image1\" }, { name = \"Image 2\" , url = \"http://placehold.it/120x120&text=image2\" }, } UI . setCustomAssets ( assets ) end","title":"setCustomAssets(...)"},{"location":"ui/#setvalue","text":"Updates the value between elements tags, like: <Text>ValueChanged</Text> setValue(id, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. value : The value to put between the element tags. UI . setValue ( \"testElement\" , \"New Text To Display\" )","title":"setValue(...)"},{"location":"ui/#setxml","text":"Replaces the run-time UI with the XML string. setXml(xml) xml : A single string with the contents of the XML to use self . UI . setXml ( \"<Text>Test</Text>\" ) Warning setXml takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly.","title":"setXml(...)"},{"location":"ui/#setxmltable","text":"Replaces the run-time UI with an XML string which is generated from a table of data. setXmlTable(data) data : A table containing sub-tables. One sub-table for each element being created. tag : The element type. attributes : A table containing attribute names for keys. Available attribute types depend on tag's element type. Optional, defaults to not being used. Example key/value pairs: text=\"Test\", color=\"black\" value : Text that appears <Text>Here</Text> , between the <> and ``. Optional, defaults to an empty string. children : A table containing more sub-tables, formatted as above. This does mean the sub-tables can contain their own children as well, containing sub-sub tables, etc. Optional, defaults to not being used. function onLoad () UI . setXmlTable ({ { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } }) end Warning setXmlTable takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly.","title":"setXmlTable(...)"},{"location":"ui/#show","text":"Shows the given UI element. Unlike the \"active\" attribute, show triggers animations. show(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . show ( \"testElement\" )","title":"show(...)"},{"location":"vector/","text":"Representation of 3D vectors and points. This structure is used to pass 3D positions and directions around. It also contains functions for doing common vector operations. Besides the functions listed below, other classes can be used to manipulate vectors and points as well. Example Usage: target = Vector ( 1 , 0 , 0 ) + Vector ( 0 , 2 , 0 ): normalized () Check Manipulation examples for more detailed usage. Tip Vector and Color are the first classes to be defined in pure Lua. This means you have to use colon operator (e.g. pos:angle() ) to call member functions, not the dot operator. Failing to do so will fail with cryptic error messages displayed. Constructors summary Tip Every place that returns a coordinate table, like obj . getPosition () , serves a Vector class instance already - you do not have to explicitly construct it. When constructing Vector instances, the .new part can be omitted, making e.g. Vector ( 1 , 2 , 3 ) equivalent to Vector . new ( 1 , 2 , 3 ) . Function Name Description Return Vector( x, y, z) Return a vector with specified (x, y, z) components. Vector( v) Return a vector with x/y/z or 1/2/3 components from source table (x/y/z first). Vector.new(...) Same as Vector(...). Vector.min( vec1, vec2) Returns a vector that is made from the smallest components of two vectors. Vector.max( vec1, vec2) Returns a vector that is made from the largest components of two vectors. Vector.between( vec1, vec2) Return a vector pointing from vec1 to vec2. Constructors examples function onLoad () local vec1 = Vector . new ( 0.5 , 1 , 1.5 ) local vec2 = Vector ( 1 , - 1 , 0 ) -- same as Vector.new(1, -1, 0) print ( Vector . between ( vec1 , vec2 )) --> Vector: {0.5, -2. -1.5} print ( Vector . max ( vec1 , vec2 )) --> Vector: {1, 1. 1.5} print ( Vector . min ( vec1 , vec2 )) --> Vector: {0.5, -1. -0} end Element access summary In addition to accessing vector components by their numeric indices (1, 2, 3) and textual identifiers (x, y, z), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( x, y, z) Sets x , y , z components to given values and returns self. get() Returns x , y , z components as three separate values. copy() Returns a separate Vector with identical component values. Tip Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there. Element access examples function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec . x = 2 -- set the first component vec [ 2 ] = 4 -- set the second component vec : setAt ( 'z' , 6 ) -- set the third component print ( vec : get ()) --> same as print(vec.x, vec.y, vec.z) for axis , value in pairs ( vec ) do print ( axis .. \"=\" .. value ) --> x=2 then y=4 and finally z=6 end vec : copy (): setAt ( 'x' , - 11 ) print ( vec . x ) --> 2, because we only changed 'x' on a copy end Arithmetics summary Vector also allows you to use arithmetic operators to performs basic operations: Operator Description Return one + two Returns a new Vector that is a sum of one and two one - two Returns a new Vector that is a difference of one and two one * factor Returns a new Vector that is one with each component multiplied by the factor. one == two Returns a boolean whether one and two are very similar to each other (less than ~0.03 difference in magnitude) Arithmetics examples function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec : add ( Vector ( 3 , 2 , 1 )) --> vec is now {4, 4, 4} vec : sub ( Vector ( 1 , 0 , 1 )) --> vec is now {3, 4, 3} local another = vec + Vector ( - 1 , - 2 , - 1 ) --> another is {2, 2, 2}, vec remains unchanged print ( another : equals ( Vector ( 1 , 2 , 3 ))) --> false print ( another == Vector ( 2 , 2 , 2 )) --> true print ( another == Vector ( 1.99 , 2.01 , 2 )) --> true, small differences are tolerated end Methods summary Tip Numerous methods of Vector will return the instance to allow easy \"chaining\". That way you can do more complex processing without saving an intermediate result in a variable, like e.g. vec : setAt ( 'y' , 0 ): scale ( 0.5 ): rotateOver ( 'y' , 90 ) . Methods modifying self Method Name Description Return vec:add( otherVec) Adds components of otherVec to self. vec:sub( otherVec) Subtracts components of otherVec from self. vec:scale( otherVec) Multiplies self-components by corresponding components from otherVec. vec:scale( num) Multiplies self-components by a numeric factor. vec:clamp( num) If self-magnitude is higher than provided limit, scale self-down to match it. vec:normalize() Makes self-have a magnitude of 1. vec:project( otherVec) Make self into projection on another vector. vec:projectOnPlane( otherVec) Project self on a plane defined through a normal vector arg. vec:reflect( otherVec) Reflect self over a plane defined through a normal vector arg. vec:inverse() Multiply self-components by -1. vec:moveTowards( otherVec, num) Move self towards another vector, but only up to a provided distance limit. vec:rotateTowards( target, maxAngle) Rotate self towards another vector, but only up to a provided angle limit. vec:rotateTowardsUnit( target, maxAngle) Same as rotateTowards, but only works correctly if target Vector is normalized. Less expensive than rotateTowards . vec:rotateOver( axis, angle) Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ). Methods not modifying self Method Name Description Return vec1:dot( vec2) Return a dot product of two vectors. vec:magnitude() Returns the length of this vector. vec:sqrMagnitude() Returns the squared length of this vector. p1:distance( p2) Returns distance between two points. p1:sqrDistance( p2) Returns squared distance between two points. vec1:equals( vec2, margin) Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec:string( prefix) Return string describing self, optional string prefix. vec1:angle( vec2) Return an angle between two vectors, in degrees [0, 180]. vec1:cross( vec2) Return a cross-product vector of two vectors. p1:lerp( p2, t) Linearly interpolates between two points. Numeric arg [0, 1] is the fraction. vec:normalized() Return a new vector that is normalized (length 1) version of self. vec:orthoNormalize() Return three normalized vectors perpendicular to each other, first one being in the same dir as self. Return base , normal , binormal vectors. vec:orthoNormalize( binormalPlanar) Same as vec:orthoNormalize(), but second vector is guranteed to be on a self-binormalPlanar plane. vec:heading() Returns an angle (In degrees) of rotation of Vector over all axis ( 'x' , 'y' , 'z' ). vec:heading( axis) Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ). Constructors details Vector.min(...) Returns a vector that is made from the smallest components of two vectors. Vector.min(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . min ( vec1 , vec2 )) --> Vector: { 1, 2, 2 } Vector.max(...) Returns a vector that is made from the largest components of two vectors. Vector.max(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . max ( vec1 , vec2 )) --> Vector: { 4, 3, 3 } Vector.between(...) Return a vector pointing from vec1 to vec2. Vector.between(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . between ( vec1 , vec2 )) --> Vector: { 3, 1, -1 } Element access details setAt(...) Update one component of the vector and returning self. setAt(key, num) key : Index of component (1, 2 or 3 for x, y or z). num : New value. vec = Vector ( 1 , 2 , 3 ) vec : setAt ( 1 , 4 ): setAt ( 'y' , 3 ) print ( vec ) --> Vector: { 4, 3, 3 } set(...) Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(x, y, z) x : New value of X component. y : New value of Y component. z : New value of Z component. vec = Vector ( 1 , 2 , 3 ) vec : set ( 4 , 3 , 2 ) print ( vec ) --> Vector: { 4, 3, 2 } get() Returns x , y , z components as three separate values. vec = Vector ( 1 , 2 , 3 ) x , y , z = vec : get () print ( x + y + z ) --> 6 copy() Copy self into a new vector and return it. vec1 = Vector ( 1 , 2 , 3 ) vec2 = vec1 : copy () vec1 : set ( 4 , 3 , 2 ) print ( vec1 ) --> Vector { 4, 3, 2 } print ( vec2 ) --> Vector { 1, 2, 3 } Methods details Methods modifying self details add(...) Adds components of otherVec to self and returning self. add(otherVec) otherVec : The vector to add. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec : add ( otherVec ) print ( vec ) --> Vector: { 5, 7, 9 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec = vec + otherVec print ( vec ) --> Vector: { 5, 7, 9 } sub(...) Subtracts components of otherVec from self and returning self. sub(otherVec) otherVec : The vector to subtracts. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec : sub ( otherVec ) print ( vec ) --> Vector: { -5, -3, -1 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec = vec - otherVec print ( vec ) --> Vector: { -5, -3, -1 } scale(...) Multiplies self-components by corresponding components from otherVec and returning self. Every component in the result is a component of vec multiplied by the same component of otherVec or by a number factor. scale(otherVec) otherVec : The vector to scale. scale(num) num : The numeric factor. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 2 , 3 , 4 ) vec : scale ( otherVec ) print ( vec ) --> Vector: { 2, 6, 12 } vec : scale ( 2 ) print ( vec ) --> Vector: { 4, 12, 24 } clamp(...) If self-magnitude is higher than provided limit, scale self-down to match it and returning self. clamp(num) num : The numeric max magnitude. vec = Vector ( 1 , 2 , 3 ) vec : clamp ( 2 ) print ( vec ) --> Vector: { 0.53, 1.07, 1.60 } normalize() Makes this vector have a magnitude of 1 and returning self. When normalized, a vector keeps the same direction but its length is 1.0. Note that this function will change the current vector. If you want to keep the current vector unchanged, use normalized() method. vec = Vector ( 1 , 2 , 3 ) vec : normalize () print ( vec ) --> Vector: { 0.27, 0.53, 0.80 } project(...) Make self into projection on another vector and return self. To understand vector projection, imagine that otherVec is resting on a line pointing in its direction. Somewhere along that line will be the nearest point to the tip of vector. The projection is just otherVec rescaled so that it reaches that point on the line. project(otherVec) otherVec : The normal vector. vec = Vector ( 2 , 1 , 4 ) vec : project ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 0.67, -1.3, 0.67 } projectOnPlane(...) Projects a vector onto a plane defined by a normal orthogonal to the plane and return self. A Vector stores the position of the given vec in 3d space. A second Vector is given by otherVec and defines a direction from a plane towards vector that passes through the origin. Vector.projectOnPlane uses the two Vector values to generate the position of vector in the otherVec direction, and return the location of the Vector on the plane. projectOnPlane(otherVec) otherVec : The plane normal vector. vec = Vector ( 2 , 1 , 4 ) vec : projectOnPlane ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 1.33, 2.33, 3.33 } reflect(...) Make self into reflection on another vector and return self. The otherVec vector defines a plane (a plane's normal is the vector that is perpendicular to its surface). The vec vector is treated as a directional arrow coming in to the plane. The returned value is a vector of equal magnitude to vec but with its direction reflected. reflect(otherVec) otherVec : The normal vector. vec = Vector ( 1 , 2 , 3 ) vec : reflect ( Vector ( 4 , 3 , 2 )) print ( vec ) --> Vector: { -3.41, -1.31, 0.79 } inverse() Multiply self-components by -1. vec = Vector ( 1 , 2 , 3 ) vec : inverse () print ( vec ) --> Vector: { -1, -2, -3 } moveTowards(...) Move self towards another vector, but only up to a provided distance limit and return self. moveTowards(otherVec, num) target : The position to move towards. num : The distance limit. vec = Vector ( 1 , 2 , 3 ) vec : moveTowards ( Vector ( 4 , 3 , 2 ), 0.5 ) print ( vec ) --> Vector: { 1.45, 2.15, 2.85 } rotateTowards(...) Rotate self towards another vector, but only up to a provided angle limit and return self. This function is similar to moveTowards() except that the vector is treated as a direction rather than a position. The current vector will be rotated round toward the target direction by an angle of maxAngle , although it will land exactly on the target rather than overshoot. If the magnitudes of current and target are different, then the magnitude of the result will be linearly interpolated during the rotation. If a negative value is used for maxAngle , the vector will rotate away from target until it is pointing in exactly the opposite direction, then stops. rotateTowards(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowards ( Vector ( 4 , 3 , 2 ), 45 ) print ( vec ) --> Vector: { 2.78, 2.08, 1.39 } rotateTowardsUnit(...) Same as rotateTowards() , but only works correctly if target Vector is normalized and return self. Less expensive than rotateTowards() . rotateTowardsUnit(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowardsUnit ( Vector ( 4 , 3 , 2 ): normalized (), 45 ) print ( vec ) --> Vector: { 3.29, 0.87, -1.55 } rotateOver(...) Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ) and return self. rotateOver(axis, angle) axis : The axis to rotate around. angle : The angle in degree for this rotation. vec = Vector ( 3 , 2 , 3 ) vec : rotateOver ( 'y' , 45 ) print ( vec ) --> Vector: { 4.24, 2, 0 } Methods not modifying self details dot(...) Return the dot product of two vectors. The dot product is a float value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them. For normalized vectors Dot returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and zero if the vectors are perpendicular. vec1:dot(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 0 , 1 , 2 ) vec2 = Vector ( 0 , 2 , 4 ) print ( vec1 : dot ( vec2 )) --> 10 print ( Vector . dot ( vec1 : normalized (), vec2 : normalized ())) --> 1 magnitude() Returns the length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : magnitude ()) --> 3.74 (sqrt of 14) print ( Vector . magnitude ( vec )) --> 3.74 (sqrt of 14) sqrMagnitude() Returns the squared length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : sqrMagnitude ()) --> 14 print ( Vector . sqrMagnitude ( vec )) --> 14 distance(...) Returns distance between two points. p1:distance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : distance ( p2 )) --> 3.32 print ( Vector . distance ( p1 , p2 )) --> 3.32 print (( p1 - p2 ): magnitude ()) --> 3.32 sqrDistance(...) Returns squared distance between two points. p1:sqrDistance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : sqrDistance ( p2 )) --> 11 print ( Vector . sqrDistance ( p1 , p2 )) --> 11 equals(...) Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec1:equals(vec2, margin) vec1 : First vector. vec2 : Second vector. margin : (Optional) Numeric tolerance. vec1 = Vector ( 1 , 2 , 3.10 ) vec2 = Vector ( 1 , 2 , 3.15 ) print ( vec1 : equals ( vec2 )) --> false print ( Vector . equals ( vec1 , vec2 , 0.01 )) --> true string(...) Return string describing self, optional string prefix. string(prefix) prefix : The prefix of return string. vec = Vector ( 1 , 2 , 3 ) str = vec : string ( 'Prefix' ) print ( str ) --> Prefix: { 1, 2, 3 } print ( vec : string ( 'Prefix' )) --> Prefix: { 1, 2, 3 }0 print ( Vector . string ( vec , 'Prefix' )) --> Prefix: { 1, 2, 3 }0 Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function. angle(...) Returns the angle in degrees between two vectors. The angle returned is the unsigned angle between the two vectors. This means the smaller of the two possible angles between the two vectors is used. The result is never greater than 180 degrees. vec1:angle(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : angle ( vec2 )) --> 37.43 print ( Vector . angle ( vec1 , vec2 )) --> 37.43 cross(...) Return a cross-product vector of two vectors. The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the \"left hand rule\". vec1:cross(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : cross ( vec2 )) --> Vector: { -5, 10, -5 } print ( vec2 : cross ( vec1 )) --> Vector: { -5, -10, 5 } print ( Vector . cross ( vec1 , vec2 )) --> Vector: { -5, 10, -5 } print ( Vector . cross ( vec2 , vec1 )) --> Vector: { -5, -10, 5 } lerp(...) Linearly interpolates between two points. Interpolates between the points a and b by the interpolant t. The parameter t is clamped to the range [0, 1]. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points). The value returned equals (b - a) * t. When t = 0 returns a. When t = 1 returns b. When t = 0.5 returns the point midway between a and b. p1:lerp(p2, t) p1 : First point. p2 : Second point. t : Fraction. p1 = Vector ( 1 , 2 , - 4 ) p2 = Vector ( 1 , 2 , 4 ) print ( p1 : lerp ( p2 , 0.25 )) --> Vector: { 1, 2, -2 } print ( Vector . lerp ( p1 , p2 , 0.25 )) --> Vector: { 1, 2, -2 } normalized() Return a new vector that is normalized (length 1) version of self. vec = Vector ( 1 , 2 , 3 ) print ( vec : normalized ()) --> Vector: { 0.27, 0.53, 0.80} print ( Vector . normalized ( vec )) --> Vector: { 0.27, 0.53, 0.80} orthoNormalize(...) Return three normalized vectors perpendicular to each other, first one being in the same direction as self. If binormalPlaner is provided, the second vector is guaranteed to be on a self-binormalPlanar plane. orthoNormalize(binormalPlanar) binormalPlanar : (optional) The vector for binormal planar. vec = Vector ( 0 , 0 , 2 ) base , normal , binormal = vec : orthoNormalize ( Vector ( 0 , 1 , 0 )) print ( base ) --> Vector: { 0, 0, 1} print ( normal ) --> Vector: { -1, 0, 0} print ( binormal ) --> Vector: { 0, -1, 0} heading(...) Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ). heading(axis) axis : Can be 'x' , 'y' , 'z' . vec = Vector ( 1 , 2 , 3 ) angle = vec : heading ( 'z' ) print ( angle ) --> 26.57 Manipulation examples Moving an object towards a target position in small steps function onLoad () local obj = assert ( getObjectFromGUID ( '555555' ), 'Object not found!' ) obj . lock () local current = Vector ( 10 , 5 , 0 ) -- obj starting position local target = Vector ( - 10 , 5 , 0 ) -- obj destination local movementType = 'linear' -- try with 'spherical' or 'asymptotic' to see how other methods work -- We want out movement stretched over time, a Wait will do it periodically local waitID waitID = Wait . time ( function () -- move the current postion towards destination if movementType == 'linear' then -- simple linear movement, 1 unit at a time current : moveTowards ( target , 1 ) elseif movementType == 'spherical' then -- rotate towards target, 10 degress at a time current : rotateTowards ( target , 5 ) elseif movementType == 'asymptotic' then -- move quarter of the way towards target (take note that lerp does not modify current directly) current = current : lerp ( target , 0.25 ) end obj . setPositionSmooth ( current , true , true ) -- if we reached the destination, stop this timer if current == target then Wait . stop ( waitID ) broadcastToAll ( 'Finished!' , { 0 , 1 , 0 }) end end , 0.5 , -- repeats every half second - 1 -- indefinitely, until stopped because we reached destination ) end","title":"Vector"},{"location":"vector/#constructors-summary","text":"Tip Every place that returns a coordinate table, like obj . getPosition () , serves a Vector class instance already - you do not have to explicitly construct it. When constructing Vector instances, the .new part can be omitted, making e.g. Vector ( 1 , 2 , 3 ) equivalent to Vector . new ( 1 , 2 , 3 ) . Function Name Description Return Vector( x, y, z) Return a vector with specified (x, y, z) components. Vector( v) Return a vector with x/y/z or 1/2/3 components from source table (x/y/z first). Vector.new(...) Same as Vector(...). Vector.min( vec1, vec2) Returns a vector that is made from the smallest components of two vectors. Vector.max( vec1, vec2) Returns a vector that is made from the largest components of two vectors. Vector.between( vec1, vec2) Return a vector pointing from vec1 to vec2.","title":"Constructors summary"},{"location":"vector/#constructors-examples","text":"function onLoad () local vec1 = Vector . new ( 0.5 , 1 , 1.5 ) local vec2 = Vector ( 1 , - 1 , 0 ) -- same as Vector.new(1, -1, 0) print ( Vector . between ( vec1 , vec2 )) --> Vector: {0.5, -2. -1.5} print ( Vector . max ( vec1 , vec2 )) --> Vector: {1, 1. 1.5} print ( Vector . min ( vec1 , vec2 )) --> Vector: {0.5, -1. -0} end","title":"Constructors examples"},{"location":"vector/#element-access-summary","text":"In addition to accessing vector components by their numeric indices (1, 2, 3) and textual identifiers (x, y, z), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( x, y, z) Sets x , y , z components to given values and returns self. get() Returns x , y , z components as three separate values. copy() Returns a separate Vector with identical component values. Tip Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there.","title":"Element access summary"},{"location":"vector/#element-access-examples","text":"function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec . x = 2 -- set the first component vec [ 2 ] = 4 -- set the second component vec : setAt ( 'z' , 6 ) -- set the third component print ( vec : get ()) --> same as print(vec.x, vec.y, vec.z) for axis , value in pairs ( vec ) do print ( axis .. \"=\" .. value ) --> x=2 then y=4 and finally z=6 end vec : copy (): setAt ( 'x' , - 11 ) print ( vec . x ) --> 2, because we only changed 'x' on a copy end","title":"Element access examples"},{"location":"vector/#arithmetics-summary","text":"Vector also allows you to use arithmetic operators to performs basic operations: Operator Description Return one + two Returns a new Vector that is a sum of one and two one - two Returns a new Vector that is a difference of one and two one * factor Returns a new Vector that is one with each component multiplied by the factor. one == two Returns a boolean whether one and two are very similar to each other (less than ~0.03 difference in magnitude)","title":"Arithmetics summary"},{"location":"vector/#arithmetics-examples","text":"function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec : add ( Vector ( 3 , 2 , 1 )) --> vec is now {4, 4, 4} vec : sub ( Vector ( 1 , 0 , 1 )) --> vec is now {3, 4, 3} local another = vec + Vector ( - 1 , - 2 , - 1 ) --> another is {2, 2, 2}, vec remains unchanged print ( another : equals ( Vector ( 1 , 2 , 3 ))) --> false print ( another == Vector ( 2 , 2 , 2 )) --> true print ( another == Vector ( 1.99 , 2.01 , 2 )) --> true, small differences are tolerated end","title":"Arithmetics examples"},{"location":"vector/#methods-summary","text":"Tip Numerous methods of Vector will return the instance to allow easy \"chaining\". That way you can do more complex processing without saving an intermediate result in a variable, like e.g. vec : setAt ( 'y' , 0 ): scale ( 0.5 ): rotateOver ( 'y' , 90 ) .","title":"Methods summary"},{"location":"vector/#methods-modifying-self","text":"Method Name Description Return vec:add( otherVec) Adds components of otherVec to self. vec:sub( otherVec) Subtracts components of otherVec from self. vec:scale( otherVec) Multiplies self-components by corresponding components from otherVec. vec:scale( num) Multiplies self-components by a numeric factor. vec:clamp( num) If self-magnitude is higher than provided limit, scale self-down to match it. vec:normalize() Makes self-have a magnitude of 1. vec:project( otherVec) Make self into projection on another vector. vec:projectOnPlane( otherVec) Project self on a plane defined through a normal vector arg. vec:reflect( otherVec) Reflect self over a plane defined through a normal vector arg. vec:inverse() Multiply self-components by -1. vec:moveTowards( otherVec, num) Move self towards another vector, but only up to a provided distance limit. vec:rotateTowards( target, maxAngle) Rotate self towards another vector, but only up to a provided angle limit. vec:rotateTowardsUnit( target, maxAngle) Same as rotateTowards, but only works correctly if target Vector is normalized. Less expensive than rotateTowards . vec:rotateOver( axis, angle) Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ).","title":"Methods modifying self"},{"location":"vector/#methods-not-modifying-self","text":"Method Name Description Return vec1:dot( vec2) Return a dot product of two vectors. vec:magnitude() Returns the length of this vector. vec:sqrMagnitude() Returns the squared length of this vector. p1:distance( p2) Returns distance between two points. p1:sqrDistance( p2) Returns squared distance between two points. vec1:equals( vec2, margin) Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec:string( prefix) Return string describing self, optional string prefix. vec1:angle( vec2) Return an angle between two vectors, in degrees [0, 180]. vec1:cross( vec2) Return a cross-product vector of two vectors. p1:lerp( p2, t) Linearly interpolates between two points. Numeric arg [0, 1] is the fraction. vec:normalized() Return a new vector that is normalized (length 1) version of self. vec:orthoNormalize() Return three normalized vectors perpendicular to each other, first one being in the same dir as self. Return base , normal , binormal vectors. vec:orthoNormalize( binormalPlanar) Same as vec:orthoNormalize(), but second vector is guranteed to be on a self-binormalPlanar plane. vec:heading() Returns an angle (In degrees) of rotation of Vector over all axis ( 'x' , 'y' , 'z' ). vec:heading( axis) Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ).","title":"Methods not modifying self"},{"location":"vector/#constructors-details","text":"","title":"Constructors details"},{"location":"vector/#vectormin","text":"Returns a vector that is made from the smallest components of two vectors. Vector.min(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . min ( vec1 , vec2 )) --> Vector: { 1, 2, 2 }","title":"Vector.min(...)"},{"location":"vector/#vectormax","text":"Returns a vector that is made from the largest components of two vectors. Vector.max(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . max ( vec1 , vec2 )) --> Vector: { 4, 3, 3 }","title":"Vector.max(...)"},{"location":"vector/#vectorbetween","text":"Return a vector pointing from vec1 to vec2. Vector.between(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . between ( vec1 , vec2 )) --> Vector: { 3, 1, -1 }","title":"Vector.between(...)"},{"location":"vector/#element-access-details","text":"","title":"Element access details"},{"location":"vector/#setat","text":"Update one component of the vector and returning self. setAt(key, num) key : Index of component (1, 2 or 3 for x, y or z). num : New value. vec = Vector ( 1 , 2 , 3 ) vec : setAt ( 1 , 4 ): setAt ( 'y' , 3 ) print ( vec ) --> Vector: { 4, 3, 3 }","title":"setAt(...)"},{"location":"vector/#set","text":"Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(x, y, z) x : New value of X component. y : New value of Y component. z : New value of Z component. vec = Vector ( 1 , 2 , 3 ) vec : set ( 4 , 3 , 2 ) print ( vec ) --> Vector: { 4, 3, 2 }","title":"set(...)"},{"location":"vector/#get","text":"Returns x , y , z components as three separate values. vec = Vector ( 1 , 2 , 3 ) x , y , z = vec : get () print ( x + y + z ) --> 6","title":"get()"},{"location":"vector/#copy","text":"Copy self into a new vector and return it. vec1 = Vector ( 1 , 2 , 3 ) vec2 = vec1 : copy () vec1 : set ( 4 , 3 , 2 ) print ( vec1 ) --> Vector { 4, 3, 2 } print ( vec2 ) --> Vector { 1, 2, 3 }","title":"copy()"},{"location":"vector/#methods-details","text":"","title":"Methods details"},{"location":"vector/#methods-modifying-self-details","text":"","title":"Methods modifying self details"},{"location":"vector/#add","text":"Adds components of otherVec to self and returning self. add(otherVec) otherVec : The vector to add. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec : add ( otherVec ) print ( vec ) --> Vector: { 5, 7, 9 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec = vec + otherVec print ( vec ) --> Vector: { 5, 7, 9 }","title":"add(...)"},{"location":"vector/#sub","text":"Subtracts components of otherVec from self and returning self. sub(otherVec) otherVec : The vector to subtracts. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec : sub ( otherVec ) print ( vec ) --> Vector: { -5, -3, -1 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec = vec - otherVec print ( vec ) --> Vector: { -5, -3, -1 }","title":"sub(...)"},{"location":"vector/#scale","text":"Multiplies self-components by corresponding components from otherVec and returning self. Every component in the result is a component of vec multiplied by the same component of otherVec or by a number factor. scale(otherVec) otherVec : The vector to scale. scale(num) num : The numeric factor. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 2 , 3 , 4 ) vec : scale ( otherVec ) print ( vec ) --> Vector: { 2, 6, 12 } vec : scale ( 2 ) print ( vec ) --> Vector: { 4, 12, 24 }","title":"scale(...)"},{"location":"vector/#clamp","text":"If self-magnitude is higher than provided limit, scale self-down to match it and returning self. clamp(num) num : The numeric max magnitude. vec = Vector ( 1 , 2 , 3 ) vec : clamp ( 2 ) print ( vec ) --> Vector: { 0.53, 1.07, 1.60 }","title":"clamp(...)"},{"location":"vector/#normalize","text":"Makes this vector have a magnitude of 1 and returning self. When normalized, a vector keeps the same direction but its length is 1.0. Note that this function will change the current vector. If you want to keep the current vector unchanged, use normalized() method. vec = Vector ( 1 , 2 , 3 ) vec : normalize () print ( vec ) --> Vector: { 0.27, 0.53, 0.80 }","title":"normalize()"},{"location":"vector/#project","text":"Make self into projection on another vector and return self. To understand vector projection, imagine that otherVec is resting on a line pointing in its direction. Somewhere along that line will be the nearest point to the tip of vector. The projection is just otherVec rescaled so that it reaches that point on the line. project(otherVec) otherVec : The normal vector. vec = Vector ( 2 , 1 , 4 ) vec : project ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 0.67, -1.3, 0.67 }","title":"project(...)"},{"location":"vector/#projectonplane","text":"Projects a vector onto a plane defined by a normal orthogonal to the plane and return self. A Vector stores the position of the given vec in 3d space. A second Vector is given by otherVec and defines a direction from a plane towards vector that passes through the origin. Vector.projectOnPlane uses the two Vector values to generate the position of vector in the otherVec direction, and return the location of the Vector on the plane. projectOnPlane(otherVec) otherVec : The plane normal vector. vec = Vector ( 2 , 1 , 4 ) vec : projectOnPlane ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 1.33, 2.33, 3.33 }","title":"projectOnPlane(...)"},{"location":"vector/#reflect","text":"Make self into reflection on another vector and return self. The otherVec vector defines a plane (a plane's normal is the vector that is perpendicular to its surface). The vec vector is treated as a directional arrow coming in to the plane. The returned value is a vector of equal magnitude to vec but with its direction reflected. reflect(otherVec) otherVec : The normal vector. vec = Vector ( 1 , 2 , 3 ) vec : reflect ( Vector ( 4 , 3 , 2 )) print ( vec ) --> Vector: { -3.41, -1.31, 0.79 }","title":"reflect(...)"},{"location":"vector/#inverse","text":"Multiply self-components by -1. vec = Vector ( 1 , 2 , 3 ) vec : inverse () print ( vec ) --> Vector: { -1, -2, -3 }","title":"inverse()"},{"location":"vector/#movetowards","text":"Move self towards another vector, but only up to a provided distance limit and return self. moveTowards(otherVec, num) target : The position to move towards. num : The distance limit. vec = Vector ( 1 , 2 , 3 ) vec : moveTowards ( Vector ( 4 , 3 , 2 ), 0.5 ) print ( vec ) --> Vector: { 1.45, 2.15, 2.85 }","title":"moveTowards(...)"},{"location":"vector/#rotatetowards","text":"Rotate self towards another vector, but only up to a provided angle limit and return self. This function is similar to moveTowards() except that the vector is treated as a direction rather than a position. The current vector will be rotated round toward the target direction by an angle of maxAngle , although it will land exactly on the target rather than overshoot. If the magnitudes of current and target are different, then the magnitude of the result will be linearly interpolated during the rotation. If a negative value is used for maxAngle , the vector will rotate away from target until it is pointing in exactly the opposite direction, then stops. rotateTowards(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowards ( Vector ( 4 , 3 , 2 ), 45 ) print ( vec ) --> Vector: { 2.78, 2.08, 1.39 }","title":"rotateTowards(...)"},{"location":"vector/#rotatetowardsunit","text":"Same as rotateTowards() , but only works correctly if target Vector is normalized and return self. Less expensive than rotateTowards() . rotateTowardsUnit(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowardsUnit ( Vector ( 4 , 3 , 2 ): normalized (), 45 ) print ( vec ) --> Vector: { 3.29, 0.87, -1.55 }","title":"rotateTowardsUnit(...)"},{"location":"vector/#rotateover","text":"Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ) and return self. rotateOver(axis, angle) axis : The axis to rotate around. angle : The angle in degree for this rotation. vec = Vector ( 3 , 2 , 3 ) vec : rotateOver ( 'y' , 45 ) print ( vec ) --> Vector: { 4.24, 2, 0 }","title":"rotateOver(...)"},{"location":"vector/#methods-not-modifying-self-details","text":"","title":"Methods not modifying self details"},{"location":"vector/#dot","text":"Return the dot product of two vectors. The dot product is a float value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them. For normalized vectors Dot returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and zero if the vectors are perpendicular. vec1:dot(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 0 , 1 , 2 ) vec2 = Vector ( 0 , 2 , 4 ) print ( vec1 : dot ( vec2 )) --> 10 print ( Vector . dot ( vec1 : normalized (), vec2 : normalized ())) --> 1","title":"dot(...)"},{"location":"vector/#magnitude","text":"Returns the length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : magnitude ()) --> 3.74 (sqrt of 14) print ( Vector . magnitude ( vec )) --> 3.74 (sqrt of 14)","title":"magnitude()"},{"location":"vector/#sqrmagnitude","text":"Returns the squared length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : sqrMagnitude ()) --> 14 print ( Vector . sqrMagnitude ( vec )) --> 14","title":"sqrMagnitude()"},{"location":"vector/#distance","text":"Returns distance between two points. p1:distance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : distance ( p2 )) --> 3.32 print ( Vector . distance ( p1 , p2 )) --> 3.32 print (( p1 - p2 ): magnitude ()) --> 3.32","title":"distance(...)"},{"location":"vector/#sqrdistance","text":"Returns squared distance between two points. p1:sqrDistance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : sqrDistance ( p2 )) --> 11 print ( Vector . sqrDistance ( p1 , p2 )) --> 11","title":"sqrDistance(...)"},{"location":"vector/#equals","text":"Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec1:equals(vec2, margin) vec1 : First vector. vec2 : Second vector. margin : (Optional) Numeric tolerance. vec1 = Vector ( 1 , 2 , 3.10 ) vec2 = Vector ( 1 , 2 , 3.15 ) print ( vec1 : equals ( vec2 )) --> false print ( Vector . equals ( vec1 , vec2 , 0.01 )) --> true","title":"equals(...)"},{"location":"vector/#string","text":"Return string describing self, optional string prefix. string(prefix) prefix : The prefix of return string. vec = Vector ( 1 , 2 , 3 ) str = vec : string ( 'Prefix' ) print ( str ) --> Prefix: { 1, 2, 3 } print ( vec : string ( 'Prefix' )) --> Prefix: { 1, 2, 3 }0 print ( Vector . string ( vec , 'Prefix' )) --> Prefix: { 1, 2, 3 }0 Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function.","title":"string(...)"},{"location":"vector/#angle","text":"Returns the angle in degrees between two vectors. The angle returned is the unsigned angle between the two vectors. This means the smaller of the two possible angles between the two vectors is used. The result is never greater than 180 degrees. vec1:angle(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : angle ( vec2 )) --> 37.43 print ( Vector . angle ( vec1 , vec2 )) --> 37.43","title":"angle(...)"},{"location":"vector/#cross","text":"Return a cross-product vector of two vectors. The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the \"left hand rule\". vec1:cross(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : cross ( vec2 )) --> Vector: { -5, 10, -5 } print ( vec2 : cross ( vec1 )) --> Vector: { -5, -10, 5 } print ( Vector . cross ( vec1 , vec2 )) --> Vector: { -5, 10, -5 } print ( Vector . cross ( vec2 , vec1 )) --> Vector: { -5, -10, 5 }","title":"cross(...)"},{"location":"vector/#lerp","text":"Linearly interpolates between two points. Interpolates between the points a and b by the interpolant t. The parameter t is clamped to the range [0, 1]. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points). The value returned equals (b - a) * t. When t = 0 returns a. When t = 1 returns b. When t = 0.5 returns the point midway between a and b. p1:lerp(p2, t) p1 : First point. p2 : Second point. t : Fraction. p1 = Vector ( 1 , 2 , - 4 ) p2 = Vector ( 1 , 2 , 4 ) print ( p1 : lerp ( p2 , 0.25 )) --> Vector: { 1, 2, -2 } print ( Vector . lerp ( p1 , p2 , 0.25 )) --> Vector: { 1, 2, -2 }","title":"lerp(...)"},{"location":"vector/#normalized","text":"Return a new vector that is normalized (length 1) version of self. vec = Vector ( 1 , 2 , 3 ) print ( vec : normalized ()) --> Vector: { 0.27, 0.53, 0.80} print ( Vector . normalized ( vec )) --> Vector: { 0.27, 0.53, 0.80}","title":"normalized()"},{"location":"vector/#orthonormalize","text":"Return three normalized vectors perpendicular to each other, first one being in the same direction as self. If binormalPlaner is provided, the second vector is guaranteed to be on a self-binormalPlanar plane. orthoNormalize(binormalPlanar) binormalPlanar : (optional) The vector for binormal planar. vec = Vector ( 0 , 0 , 2 ) base , normal , binormal = vec : orthoNormalize ( Vector ( 0 , 1 , 0 )) print ( base ) --> Vector: { 0, 0, 1} print ( normal ) --> Vector: { -1, 0, 0} print ( binormal ) --> Vector: { 0, -1, 0}","title":"orthoNormalize(...)"},{"location":"vector/#heading","text":"Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ). heading(axis) axis : Can be 'x' , 'y' , 'z' . vec = Vector ( 1 , 2 , 3 ) angle = vec : heading ( 'z' ) print ( angle ) --> 26.57","title":"heading(...)"},{"location":"vector/#manipulation-examples","text":"Moving an object towards a target position in small steps function onLoad () local obj = assert ( getObjectFromGUID ( '555555' ), 'Object not found!' ) obj . lock () local current = Vector ( 10 , 5 , 0 ) -- obj starting position local target = Vector ( - 10 , 5 , 0 ) -- obj destination local movementType = 'linear' -- try with 'spherical' or 'asymptotic' to see how other methods work -- We want out movement stretched over time, a Wait will do it periodically local waitID waitID = Wait . time ( function () -- move the current postion towards destination if movementType == 'linear' then -- simple linear movement, 1 unit at a time current : moveTowards ( target , 1 ) elseif movementType == 'spherical' then -- rotate towards target, 10 degress at a time current : rotateTowards ( target , 5 ) elseif movementType == 'asymptotic' then -- move quarter of the way towards target (take note that lerp does not modify current directly) current = current : lerp ( target , 0.25 ) end obj . setPositionSmooth ( current , true , true ) -- if we reached the destination, stop this timer if current == target then Wait . stop ( waitID ) broadcastToAll ( 'Finished!' , { 0 , 1 , 0 }) end end , 0.5 , -- repeats every half second - 1 -- indefinitely, until stopped because we reached destination ) end","title":"Manipulation examples"},{"location":"vr/","text":"VR Beta VR in Tabletop Simulator is under active development, and as such is changing all the time. This thread will be updated each patch with any changes relevant to playing in VR. Both Vive and Rift are supported, though control layout may change where necessary (due to thumbstick for instance). Reverting to original controls If you would rather just go back to how the VR controls used to work then you can do that in the VR settings UI or via this command in system console: +vr_controls_original Note that this will is likely to be deprecated at some point. v11.1 VR changes Updated to SteamVR action+binding system. VR controllers can now act as a joypad for control binding; turn on Joypad Emulation in the VR settings, and make sure the Controller option at the bottom of the Controls window is ticked. Using above, most normal control bindings should work where approriate in VR (e.g. Copy , Paste , Flip , etc.) Can now attach the VR UI screen to a controller: rotate your wrist as if you were looking at your watch. Added Drawings, Text, Gizmo, Snap, and Decal tools. Fixed Zone tools, Line tool (displays measurement, arrow ping). Fixed objects (such as chess pieces) warping into upright rotation on grab (now smooth-moves) Trigger Click Effect now known as Orient Object Orient Object action should now work on all card-like objects (dominos, mahjong tiles, etc). Also works on jigsaw pieces: will rotate them to next 90-degree angle. Fixed snap points. Made resize room visual effect less opaque. Fixed non-hands objects being picked up by VR virtual hand. Fixed tooltips & icons on Oculus Rift. Pad bindings now use compass notation (i.e. vr_left_pad_north = left controller, up on pad) VR settings The VR settings UI allows you to tailor your VR experience to your own preferences. All the settings it contains also have a console command; you may script them or bind them in the console (see VR Commands below). New items added to the VR settings dialog in v11.1: Physical UI Screen , Attached UI Screen , UI Scale - Control how the VR UI Screen is displayed. Display VR Players - Can select whether other VR players are visible (off, hands-only, hands+headset) Wall mode - will rotate room so the table is vertical. Align Zoomed Object - Zoom object now matches rotation of the object it is displaying. Grabbing Hides Gem - Hides controller gem when holding on object. Hover Tooltips - Display UI hover tooltips above controller. Interface Click Threshold - When the interface click action is bound to an analog input it will use this value. Laser Activation Threshold - When laser activation is bound to an analog input it will use this value. Laser Beam Thickness , Laser Dot Size - Control how big the laser pointer is. Left Tool Hotkeys & Right Tool Hotkeys - Bind the default tool select hotkeys to the pad. Tooltips Action Enabled - Can be turned off here to disable tooltips (instead of having to unbind the action). Floor of mist - change the floor. Current VR Controls* *Subject to change! Vive Touching the pad will activate the laser, and clicking the center will Click on whatever you are aiming at. Grab/Tool is bound to Trigger. Movement is bound to Grip. Menu is bound to the Application button. Rift Squeeze the trigger to activate the laser, and pull it to Click on what you're aiming at. Grab/Tool is bound to Grip Movement is bound to A/X Menu is bound to B/Y Other VR Hardware For information on other VR hardware see the section on SteamVR Action+Binding Here is an overview of Tabletop Simulator's default bindings for Vive and Rift Common Hold the Movement button on one controller to move as if you are pulling yourself around, or on both controllers to rotate + scale. Hit the Menu button to display the system menu on the UI screen, or hold the Menu button for 3 seconds to reset your position. Pad Left, Right and Up are used as tool hotkeys: click them to use the tool they show, or hold them to store your current tool. (You may disable tool bindings on either or both controllers, inside the VR settings window). Pad Down is Zoom. Zoom turns the controller into a zoomed-in version of the last active object. Clicking Pad Down will keep the controller in zoom mode until you click it again, and if you touch Pad Left or Pad Right while zoomed you can alter the scale of the object. Objects may be activated either by touching them with the gem, or by pointing at them with the laser beam. If an object is active then you can Grab it or Click on it (for context menu). While holding an object the pad will change function depending on what the object is. In general pad left and pad right will rotate it, and pad up will flip it. Clicking the Trigger while holding an object will toggle the Orient Object action: a card/domino will straighten and hide from other players, a jigsaw piece will rotate to next 90-degree step. SteamVR Action+Binding : Customize Controls SteamVR's new action + binding system means that you may customize the control scheme almost without limitation. It also means that you can get unsupported hardware to work simply by setting up your own control scheme. You may access the controller binding interface inside VR or on your desktop in a web browser. VR: in SteamVR settings go to Controller Binding Desktop: go to http://localhost:8998/dashboard/controllerbinding.html (you must be running SteamVR in ther background) Click on TableTop Simulator , then on the binding you want to edit, or create binding to make a new one. There are some actions deemed \"Mandatory\" that you will need to assign (Grab and Main Menu), and a lot more that are \"Suggested\". This would be a simple minimal setup: Grab on grip (use as button : held) Main Menu on a button (click) Enable Movement on a button (held) Activate Laser Pointer on trigger pull Interface Click on trigger pull Orient Object on trigger click Peek on trigger press Display Tooltips on the same binding as Enable Movement Touchpad for context actions: * North/South/East/West/Center Touch on relevant Touchpad Touch * North/South/East/West/Center Click on relevant Touchpad Click * Pad Click on touchpad use as button : click Joystick for context actions: * North/South/East/West Touch + Click on joystick directions * Center Click & Pad Click on joystick click (use as button) * Center Touch on joystick touch (use as button) You might have to add Pose and Haptic bindings: in Pose set Left Hand Raw / Right Hand Raw to Pose , and all Haptics set to Haptics . Walkthrough of Tabletop Simulator's default bindings for Vive and Rift Of course, you are free to bind everything to suit yourself, and if you make a good layout you can upload to the workshop for others to use too. For example, say you wanted to only use the right controller to pick up and manipulate objects, thus freeing up the left controller's pad for any other actions you wished. Go into the Controller Binding in SteamVR settings, hit the Edit these bindings button (and untick Mirror Mode if it is on), and on the left controller hit the bin icon next to the pad sections which are bound to NORTH_TOUCH , NORTH_CLICK , etc. The left controller will now no longer send those actions to TTS - make sure you leave its Button # bindings intact. In TTS, turn on Joypad Emulation in the VR Settings UI, and then on the standard Controls window you can tick the Controller checkbox at the bottom, and then use each direction on the left pad for any useful action in that window you wish. Note that some actions have a VR specific version which is not compatible with the standard actions (don't use the standard Grab action for instance; use the Grab action in the SteamVR Controller Binding UI instead). Editting autoexec You can do this in TTS by typing edit autoexec in the system console, or out-with the game (with notepad for example) by editing this file in your user folder: Documents\\My Games\\Tabletop Simulator\\autoexec.cfg As of v11 you no longer need to do this to make most commands store their setting; they will do that automatically. However, you may wish to edit autoexec in order to set up more personalized bindings (see below). VR commands You no longer need to use console commands to customize your VR experience as you can access all the most relevant ones for VR in the VR Settings UI. However, the commands are still there and if you want to use them you are free to do so. Any command which is an ON/OFF command can be set by typing it with a prefix: + will turn on that setting, - will turn it off, ! will toggle it. For example, +vr_wall_mode will enable wall mode, while !vr_wall_mode will turn it off if it is on, and on if it is off. The command version of the settings is probably most useful for allowing you to bind the setting to a button on the VR controller. To make this persist you must put it in your autoexec. For example, if you unticked the Left Tool Hotkeys option in the VR settings, you would free up the left controller pad for your own bindings (while not holding something). You could then edit your autoexec to something like: bind vr_left_pad_west sendkey Keypad1 bind vr_left_pad_north !vr_ui_floating bind vr_left_pad_east add vr_mode_ui_attachment 1 3 This sets the left pad to: * left on the pad (west) emulates a keypress: 1 on the numeric keypad, i.e. Scripting 1 * up on the pad (north) toggles whether the UI screen will be on the wall or floating in world space. * right on the pad (east) will cycle the UI screen attachment when it is not on the wall: floating above the table, attached to left controller, attached to right controller. To investigate the VR commands in the console, type help vr ; this will give you a summary of them all. Type help <command> to get specific info on . New in v11.1: sendkey vr_display_network_players_off vr_display_network_players_hands vr_display_network_players_all vr_grabbing_hides_gem vr_hover_tooltips vr_interface_click_threshold vr_joypad_emulation vr_laser_activation_threshold vr_laser_beam_thickness vr_laser_dot_size vr_left_controller_bind_tool_hotkeys vr_mode_display_network_players vr_mode_ui_attachment vr_right_controller_bind_tool_hotkeys vr_tooltips_action_enabled vr_ui_attach_left vr_ui_attach_right vr_ui_detached vr_ui_floating vr_ui_scale vr_ui_suppressed vr_wall_mode vr_zoom_object_aligned Renamed vr_thumbstick_repeat_duration -> vr_interface_repeat_duration vr_trigger_click_effect_delay -> vr_orient_object_delay Removed vr_cards_held_like_in_hand vr_tooltips_when_gripping vr_trigger_activates_laser vr_trigger_activates_ui vr_trigger_click_effect","title":"Virtual Reality"},{"location":"vr/#vr-beta","text":"VR in Tabletop Simulator is under active development, and as such is changing all the time. This thread will be updated each patch with any changes relevant to playing in VR. Both Vive and Rift are supported, though control layout may change where necessary (due to thumbstick for instance).","title":"VR Beta"},{"location":"vr/#reverting-to-original-controls","text":"If you would rather just go back to how the VR controls used to work then you can do that in the VR settings UI or via this command in system console: +vr_controls_original Note that this will is likely to be deprecated at some point.","title":"Reverting to original controls"},{"location":"vr/#v111-vr-changes","text":"Updated to SteamVR action+binding system. VR controllers can now act as a joypad for control binding; turn on Joypad Emulation in the VR settings, and make sure the Controller option at the bottom of the Controls window is ticked. Using above, most normal control bindings should work where approriate in VR (e.g. Copy , Paste , Flip , etc.) Can now attach the VR UI screen to a controller: rotate your wrist as if you were looking at your watch. Added Drawings, Text, Gizmo, Snap, and Decal tools. Fixed Zone tools, Line tool (displays measurement, arrow ping). Fixed objects (such as chess pieces) warping into upright rotation on grab (now smooth-moves) Trigger Click Effect now known as Orient Object Orient Object action should now work on all card-like objects (dominos, mahjong tiles, etc). Also works on jigsaw pieces: will rotate them to next 90-degree angle. Fixed snap points. Made resize room visual effect less opaque. Fixed non-hands objects being picked up by VR virtual hand. Fixed tooltips & icons on Oculus Rift. Pad bindings now use compass notation (i.e. vr_left_pad_north = left controller, up on pad)","title":"v11.1 VR changes"},{"location":"vr/#vr-settings","text":"The VR settings UI allows you to tailor your VR experience to your own preferences. All the settings it contains also have a console command; you may script them or bind them in the console (see VR Commands below). New items added to the VR settings dialog in v11.1: Physical UI Screen , Attached UI Screen , UI Scale - Control how the VR UI Screen is displayed. Display VR Players - Can select whether other VR players are visible (off, hands-only, hands+headset) Wall mode - will rotate room so the table is vertical. Align Zoomed Object - Zoom object now matches rotation of the object it is displaying. Grabbing Hides Gem - Hides controller gem when holding on object. Hover Tooltips - Display UI hover tooltips above controller. Interface Click Threshold - When the interface click action is bound to an analog input it will use this value. Laser Activation Threshold - When laser activation is bound to an analog input it will use this value. Laser Beam Thickness , Laser Dot Size - Control how big the laser pointer is. Left Tool Hotkeys & Right Tool Hotkeys - Bind the default tool select hotkeys to the pad. Tooltips Action Enabled - Can be turned off here to disable tooltips (instead of having to unbind the action). Floor of mist - change the floor.","title":"VR settings"},{"location":"vr/#current-vr-controls","text":"*Subject to change!","title":"Current VR Controls*"},{"location":"vr/#vive","text":"Touching the pad will activate the laser, and clicking the center will Click on whatever you are aiming at. Grab/Tool is bound to Trigger. Movement is bound to Grip. Menu is bound to the Application button.","title":"Vive"},{"location":"vr/#rift","text":"Squeeze the trigger to activate the laser, and pull it to Click on what you're aiming at. Grab/Tool is bound to Grip Movement is bound to A/X Menu is bound to B/Y","title":"Rift"},{"location":"vr/#other-vr-hardware","text":"For information on other VR hardware see the section on SteamVR Action+Binding Here is an overview of Tabletop Simulator's default bindings for Vive and Rift","title":"Other VR Hardware"},{"location":"vr/#common","text":"Hold the Movement button on one controller to move as if you are pulling yourself around, or on both controllers to rotate + scale. Hit the Menu button to display the system menu on the UI screen, or hold the Menu button for 3 seconds to reset your position. Pad Left, Right and Up are used as tool hotkeys: click them to use the tool they show, or hold them to store your current tool. (You may disable tool bindings on either or both controllers, inside the VR settings window). Pad Down is Zoom. Zoom turns the controller into a zoomed-in version of the last active object. Clicking Pad Down will keep the controller in zoom mode until you click it again, and if you touch Pad Left or Pad Right while zoomed you can alter the scale of the object. Objects may be activated either by touching them with the gem, or by pointing at them with the laser beam. If an object is active then you can Grab it or Click on it (for context menu). While holding an object the pad will change function depending on what the object is. In general pad left and pad right will rotate it, and pad up will flip it. Clicking the Trigger while holding an object will toggle the Orient Object action: a card/domino will straighten and hide from other players, a jigsaw piece will rotate to next 90-degree step.","title":"Common"},{"location":"vr/#steamvr-actionbinding-customize-controls","text":"SteamVR's new action + binding system means that you may customize the control scheme almost without limitation. It also means that you can get unsupported hardware to work simply by setting up your own control scheme. You may access the controller binding interface inside VR or on your desktop in a web browser. VR: in SteamVR settings go to Controller Binding Desktop: go to http://localhost:8998/dashboard/controllerbinding.html (you must be running SteamVR in ther background) Click on TableTop Simulator , then on the binding you want to edit, or create binding to make a new one. There are some actions deemed \"Mandatory\" that you will need to assign (Grab and Main Menu), and a lot more that are \"Suggested\". This would be a simple minimal setup: Grab on grip (use as button : held) Main Menu on a button (click) Enable Movement on a button (held) Activate Laser Pointer on trigger pull Interface Click on trigger pull Orient Object on trigger click Peek on trigger press Display Tooltips on the same binding as Enable Movement Touchpad for context actions: * North/South/East/West/Center Touch on relevant Touchpad Touch * North/South/East/West/Center Click on relevant Touchpad Click * Pad Click on touchpad use as button : click Joystick for context actions: * North/South/East/West Touch + Click on joystick directions * Center Click & Pad Click on joystick click (use as button) * Center Touch on joystick touch (use as button) You might have to add Pose and Haptic bindings: in Pose set Left Hand Raw / Right Hand Raw to Pose , and all Haptics set to Haptics . Walkthrough of Tabletop Simulator's default bindings for Vive and Rift Of course, you are free to bind everything to suit yourself, and if you make a good layout you can upload to the workshop for others to use too. For example, say you wanted to only use the right controller to pick up and manipulate objects, thus freeing up the left controller's pad for any other actions you wished. Go into the Controller Binding in SteamVR settings, hit the Edit these bindings button (and untick Mirror Mode if it is on), and on the left controller hit the bin icon next to the pad sections which are bound to NORTH_TOUCH , NORTH_CLICK , etc. The left controller will now no longer send those actions to TTS - make sure you leave its Button # bindings intact. In TTS, turn on Joypad Emulation in the VR Settings UI, and then on the standard Controls window you can tick the Controller checkbox at the bottom, and then use each direction on the left pad for any useful action in that window you wish. Note that some actions have a VR specific version which is not compatible with the standard actions (don't use the standard Grab action for instance; use the Grab action in the SteamVR Controller Binding UI instead).","title":"SteamVR Action+Binding : Customize Controls"},{"location":"vr/#editting-autoexec","text":"You can do this in TTS by typing edit autoexec in the system console, or out-with the game (with notepad for example) by editing this file in your user folder: Documents\\My Games\\Tabletop Simulator\\autoexec.cfg As of v11 you no longer need to do this to make most commands store their setting; they will do that automatically. However, you may wish to edit autoexec in order to set up more personalized bindings (see below).","title":"Editting autoexec"},{"location":"vr/#vr-commands","text":"You no longer need to use console commands to customize your VR experience as you can access all the most relevant ones for VR in the VR Settings UI. However, the commands are still there and if you want to use them you are free to do so. Any command which is an ON/OFF command can be set by typing it with a prefix: + will turn on that setting, - will turn it off, ! will toggle it. For example, +vr_wall_mode will enable wall mode, while !vr_wall_mode will turn it off if it is on, and on if it is off. The command version of the settings is probably most useful for allowing you to bind the setting to a button on the VR controller. To make this persist you must put it in your autoexec. For example, if you unticked the Left Tool Hotkeys option in the VR settings, you would free up the left controller pad for your own bindings (while not holding something). You could then edit your autoexec to something like: bind vr_left_pad_west sendkey Keypad1 bind vr_left_pad_north !vr_ui_floating bind vr_left_pad_east add vr_mode_ui_attachment 1 3 This sets the left pad to: * left on the pad (west) emulates a keypress: 1 on the numeric keypad, i.e. Scripting 1 * up on the pad (north) toggles whether the UI screen will be on the wall or floating in world space. * right on the pad (east) will cycle the UI screen attachment when it is not on the wall: floating above the table, attached to left controller, attached to right controller. To investigate the VR commands in the console, type help vr ; this will give you a summary of them all. Type help <command> to get specific info on .","title":"VR commands"},{"location":"vr/#new-in-v111","text":"sendkey vr_display_network_players_off vr_display_network_players_hands vr_display_network_players_all vr_grabbing_hides_gem vr_hover_tooltips vr_interface_click_threshold vr_joypad_emulation vr_laser_activation_threshold vr_laser_beam_thickness vr_laser_dot_size vr_left_controller_bind_tool_hotkeys vr_mode_display_network_players vr_mode_ui_attachment vr_right_controller_bind_tool_hotkeys vr_tooltips_action_enabled vr_ui_attach_left vr_ui_attach_right vr_ui_detached vr_ui_floating vr_ui_scale vr_ui_suppressed vr_wall_mode vr_zoom_object_aligned","title":"New in v11.1:"},{"location":"vr/#renamed","text":"vr_thumbstick_repeat_duration -> vr_interface_repeat_duration vr_trigger_click_effect_delay -> vr_orient_object_delay","title":"Renamed"},{"location":"vr/#removed","text":"vr_cards_held_like_in_hand vr_tooltips_when_gripping vr_trigger_activates_laser vr_trigger_activates_ui vr_trigger_click_effect","title":"Removed"},{"location":"wait/","text":"The Wait class is a static global class which allows you to schedule code (functions) to be executed later on. Important Please note that Wait does not pause Lua script execution, because that would freeze Tabletop Simulator! The next line of code after a Wait function call will always be executed immediately. Function Summary Function Name Description Return condition( toRunFunc, conditionFunc, timeout, timeoutFunc) Schedules a function to be executed after the specified condition has been met. frames( toRunFunc, numberFrames) Schedules a function to be executed after the specified number of frames have elapsed. stop( id) Cancels a Wait-scheduled function. stopAll() Cancels all Wait-scheduled functions. time( toRunFunc, seconds, repetitions) Schedules a function to be executed after the specified amount of time (in seconds) has elapsed. Function Details condition(...) Schedules a function to be executed after the specified condition has been met. The return value is a unique ID that may be used to stop the scheduled function before it runs. condition(toRunFunc, conditionFunc, timeout, timeoutFunc) toRunFunc : The function to be executed after the specified condition is met. conditionFunc : The function that will be executed repeatedly, until it returns true (or the timeout is reached). timeout : The amount of time (in seconds) that may elapse before the scheduled function is cancelled. Optional, defaults to never timing out. timeoutFunc : The function that will be executed if the timeout is reached. Optional conditionFunc will be executed (possibly several times) until it returns true , at which point the scheduled function ( toRunFunc ) will be executed, and conditionFunc will no longer be executed again. Optionally, a timeout and timeoutFunc may be specified. If conditionFunc does not return true before the specified timeout (seconds) has elapsed, then the scheduled function is cancelled i.e. will not be called. If a timeoutFunc is provided, then it will be called when the timeout is reached. Example Roll a die, and wait until it comes to rest. die . randomize () -- Roll a die Wait . condition ( function () -- Executed after our condition is met if die . isDestroyed () then print ( \"Die was destroyed before it came to rest.\" ) else print ( die . getRotationValue () .. \" was rolled.\" ) end end , function () -- Condition function return die . isDestroyed () or die . resting end ) Example Launch an object into the air with a random impulse and wait until it comes to rest. However, if it's taking too long (more than two seconds), give up waiting. local upwardImpulse = math.random ( 5 , 25 ) object . addForce ({ 0 , upwardImpulse , 0 }) Wait . condition ( function () if object . isDestroyed () then print ( \"Object was destroyed before it came to rest.\" ) else print ( \"The object came to rest in under two seconds.\" ) end end , function () return object . isDestroyed () or object . resting end , 2 , -- second timeout function () -- Executed if our timeout is reached print ( \"Took too long to come to rest.\" ) end ) frames(...) Schedules a function to be executed after the specified number of frames have elapsed. The return value is a unique ID that may be used to stop the scheduled function before it runs. frames(toRunFunc, frameCount) toRunFunc : The function to be executed after the specified number of frames have elapsed. numberFrames : The number of frames that must elapse before toRunFunc is executed. Optional, defaults to `1`. Example Prints \"Hello!\" after 60 frames have elapsed. Wait . frames ( function () print ( \"Hello!\" ) end , 60 ) It's a matter of personal preference, but it's quite common to see the above compacted into one line, like: Wait . frames ( function () print ( \"Hello!\" ) end , 60 ) Advanced Example Prints \"1\", \"2\", \"3\", \"4\", \"5\", waiting 60 frames before each printed number. Note that the scheduled function, upon execution, will reschedule itself unless count has reached 5. local count = 1 local function printAndReschedule () print ( count ) if count < 5 then count = count + 1 Wait . frames ( printAndReschedule , 60 ) end end Wait . frames ( printAndReschedule , 60 ) stop(...) Cancels a Wait-scheduled function. stop(id) id : A wait ID (returned from Wait scheduling functions). Example Schedules two functions: one that says \"Hello!\", and one that says \"Goodbye!\". However, the latter is stopped before it has a chance to execute i.e. We'll see \"Hello!\" printed, but we won't see \"Goodbye!\" Wait . time ( function () print ( \"Hello!\" ) end , 1 ) local goodbyeId = Wait . time ( function () print ( \"Goodbye!\" ) end , 2 ) Wait . stop ( goodbyeId ) stopAll(...) Cancels all Wait-scheduled functions. Warning You should be extremely careful using this function. Generally you should cancel individual scheduled functions with stop instead. Example Schedules two functions: one that says \"Hello!\", and one that says \"Goodbye!\". However, both are stopped before either has the chance to execute. Wait . time ( function () print ( \"Hello!\" ) end , 1 ) Wait . time ( function () print ( \"Goodbye!\" ) end , 2 ) Wait . stopAll () time(...) Schedules a function to be executed after the specified amount of time (in seconds) has elapsed. The return value is a unique ID that may be used to stop the scheduled function before it runs. time(toRunFunc, seconds, repetitions) toRunFunc : The function to be executed after the specified amount of time has elapsed. seconds : The amount of time that must elapse before toRunFunc is executed. repetitions : Number of times toRunFunc will be (re)scheduled. -1 is infinite repetitions. Optional, defaults to `1`. repetitions is optional and defaults to 1 . When repetitions is a positive number, toRunFunc will execute for the specified number of repetitions, with the specified time delay before and between each execution. When repetitions is -1 , toRunFunc will be re-scheduled indefinitely (i.e. infinite repetitions). Example Prints \"Hello!\" after 1 second has elapsed. Wait . time ( function () print ( \"Hello!\" ) end , 1 ) It's a matter of personal preference, but it's quite common to see the above compacted into one line, like: Wait . time ( function () print ( \"Hello!\" ) end , 1 ) Example Prints \"1\", \"2\", \"3\", \"4\", \"5\", waiting 1 second before each printed number. local count = 1 Wait . time ( function () print ( count ) count = count + 1 end , 1 , -- second delay 5 -- repetitions )","title":"Wait"},{"location":"wait/#function-summary","text":"Function Name Description Return condition( toRunFunc, conditionFunc, timeout, timeoutFunc) Schedules a function to be executed after the specified condition has been met. frames( toRunFunc, numberFrames) Schedules a function to be executed after the specified number of frames have elapsed. stop( id) Cancels a Wait-scheduled function. stopAll() Cancels all Wait-scheduled functions. time( toRunFunc, seconds, repetitions) Schedules a function to be executed after the specified amount of time (in seconds) has elapsed.","title":"Function Summary"},{"location":"wait/#function-details","text":"","title":"Function Details"},{"location":"wait/#condition","text":"Schedules a function to be executed after the specified condition has been met. The return value is a unique ID that may be used to stop the scheduled function before it runs. condition(toRunFunc, conditionFunc, timeout, timeoutFunc) toRunFunc : The function to be executed after the specified condition is met. conditionFunc : The function that will be executed repeatedly, until it returns true (or the timeout is reached). timeout : The amount of time (in seconds) that may elapse before the scheduled function is cancelled. Optional, defaults to never timing out. timeoutFunc : The function that will be executed if the timeout is reached. Optional conditionFunc will be executed (possibly several times) until it returns true , at which point the scheduled function ( toRunFunc ) will be executed, and conditionFunc will no longer be executed again. Optionally, a timeout and timeoutFunc may be specified. If conditionFunc does not return true before the specified timeout (seconds) has elapsed, then the scheduled function is cancelled i.e. will not be called. If a timeoutFunc is provided, then it will be called when the timeout is reached. Example Roll a die, and wait until it comes to rest. die . randomize () -- Roll a die Wait . condition ( function () -- Executed after our condition is met if die . isDestroyed () then print ( \"Die was destroyed before it came to rest.\" ) else print ( die . getRotationValue () .. \" was rolled.\" ) end end , function () -- Condition function return die . isDestroyed () or die . resting end ) Example Launch an object into the air with a random impulse and wait until it comes to rest. However, if it's taking too long (more than two seconds), give up waiting. local upwardImpulse = math.random ( 5 , 25 ) object . addForce ({ 0 , upwardImpulse , 0 }) Wait . condition ( function () if object . isDestroyed () then print ( \"Object was destroyed before it came to rest.\" ) else print ( \"The object came to rest in under two seconds.\" ) end end , function () return object . isDestroyed () or object . resting end , 2 , -- second timeout function () -- Executed if our timeout is reached print ( \"Took too long to come to rest.\" ) end )","title":"condition(...)"},{"location":"wait/#frames","text":"Schedules a function to be executed after the specified number of frames have elapsed. The return value is a unique ID that may be used to stop the scheduled function before it runs. frames(toRunFunc, frameCount) toRunFunc : The function to be executed after the specified number of frames have elapsed. numberFrames : The number of frames that must elapse before toRunFunc is executed. Optional, defaults to `1`. Example Prints \"Hello!\" after 60 frames have elapsed. Wait . frames ( function () print ( \"Hello!\" ) end , 60 ) It's a matter of personal preference, but it's quite common to see the above compacted into one line, like: Wait . frames ( function () print ( \"Hello!\" ) end , 60 ) Advanced Example Prints \"1\", \"2\", \"3\", \"4\", \"5\", waiting 60 frames before each printed number. Note that the scheduled function, upon execution, will reschedule itself unless count has reached 5. local count = 1 local function printAndReschedule () print ( count ) if count < 5 then count = count + 1 Wait . frames ( printAndReschedule , 60 ) end end Wait . frames ( printAndReschedule , 60 )","title":"frames(...)"},{"location":"wait/#stop","text":"Cancels a Wait-scheduled function. stop(id) id : A wait ID (returned from Wait scheduling functions). Example Schedules two functions: one that says \"Hello!\", and one that says \"Goodbye!\". However, the latter is stopped before it has a chance to execute i.e. We'll see \"Hello!\" printed, but we won't see \"Goodbye!\" Wait . time ( function () print ( \"Hello!\" ) end , 1 ) local goodbyeId = Wait . time ( function () print ( \"Goodbye!\" ) end , 2 ) Wait . stop ( goodbyeId )","title":"stop(...)"},{"location":"wait/#stopall","text":"Cancels all Wait-scheduled functions. Warning You should be extremely careful using this function. Generally you should cancel individual scheduled functions with stop instead. Example Schedules two functions: one that says \"Hello!\", and one that says \"Goodbye!\". However, both are stopped before either has the chance to execute. Wait . time ( function () print ( \"Hello!\" ) end , 1 ) Wait . time ( function () print ( \"Goodbye!\" ) end , 2 ) Wait . stopAll ()","title":"stopAll(...)"},{"location":"wait/#time","text":"Schedules a function to be executed after the specified amount of time (in seconds) has elapsed. The return value is a unique ID that may be used to stop the scheduled function before it runs. time(toRunFunc, seconds, repetitions) toRunFunc : The function to be executed after the specified amount of time has elapsed. seconds : The amount of time that must elapse before toRunFunc is executed. repetitions : Number of times toRunFunc will be (re)scheduled. -1 is infinite repetitions. Optional, defaults to `1`. repetitions is optional and defaults to 1 . When repetitions is a positive number, toRunFunc will execute for the specified number of repetitions, with the specified time delay before and between each execution. When repetitions is -1 , toRunFunc will be re-scheduled indefinitely (i.e. infinite repetitions). Example Prints \"Hello!\" after 1 second has elapsed. Wait . time ( function () print ( \"Hello!\" ) end , 1 ) It's a matter of personal preference, but it's quite common to see the above compacted into one line, like: Wait . time ( function () print ( \"Hello!\" ) end , 1 ) Example Prints \"1\", \"2\", \"3\", \"4\", \"5\", waiting 1 second before each printed number. local count = 1 Wait . time ( function () print ( count ) count = count + 1 end , 1 , -- second delay 5 -- repetitions )","title":"time(...)"},{"location":"webrequest/","text":"The static global WebRequest class allows you to interact with the web via get, post and put. This is a more advanced feature that allows you to store/retrieve data to/from an external database. Example Usage: WebRequest . get ( \u201c https : // www . google . com / \u201d , self , \u201c webRequestCallback \u201d ) Member Variables Like Object member variables , WebRequests have their own member variables. A WebRequest is returned as part of a function, and these member variables are how your access its information. Variable Description Type download_progress Download percentage, represented as a value from 0-1. error Error text. is_error If there is an error with the WebRequest. is_done If the WebRequest has finished. text Returned data. upload_progress Upload percentage, represented as a value from 0-1. url The targeted URL. Function Summary All functions return a WebRequest. Function Name Description get( url, callback_function) Get data from the current URL. post( url, form, callback_function) Post the form to the URL. put( url, data, callback_function) Post the data to the URL. Function Details get(...) Get data from the current URL. get(url, callback_function) url : The url to pull data from. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used. function onLoad () print ( \"Web Request Called\" ) WebRequest . get ( \"https://www.google.com\" , function ( a ) webRequestCallback ( a ) end ) end function webRequestCallback ( webReturn ) print ( \"Web Request Returned\" ) print ( webReturn . is_done ) end post(...) Post the form to the URL. post(url, form, callback_function) url : The url to pull post to. form : The form of data to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used. put(...) Post the data to the URL. put(url, data, callback_function) url : The url to pull post to. data : The data string to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used.","title":"Web Request"},{"location":"webrequest/#member-variables","text":"Like Object member variables , WebRequests have their own member variables. A WebRequest is returned as part of a function, and these member variables are how your access its information. Variable Description Type download_progress Download percentage, represented as a value from 0-1. error Error text. is_error If there is an error with the WebRequest. is_done If the WebRequest has finished. text Returned data. upload_progress Upload percentage, represented as a value from 0-1. url The targeted URL.","title":"Member Variables"},{"location":"webrequest/#function-summary","text":"All functions return a WebRequest. Function Name Description get( url, callback_function) Get data from the current URL. post( url, form, callback_function) Post the form to the URL. put( url, data, callback_function) Post the data to the URL.","title":"Function Summary"},{"location":"webrequest/#function-details","text":"","title":"Function Details"},{"location":"webrequest/#get","text":"Get data from the current URL. get(url, callback_function) url : The url to pull data from. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used. function onLoad () print ( \"Web Request Called\" ) WebRequest . get ( \"https://www.google.com\" , function ( a ) webRequestCallback ( a ) end ) end function webRequestCallback ( webReturn ) print ( \"Web Request Returned\" ) print ( webReturn . is_done ) end","title":"get(...)"},{"location":"webrequest/#post","text":"Post the form to the URL. post(url, form, callback_function) url : The url to pull post to. form : The form of data to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used.","title":"post(...)"},{"location":"webrequest/#put","text":"Post the data to the URL. put(url, data, callback_function) url : The url to pull post to. data : The data string to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used.","title":"put(...)"},{"location":"ui/attributes/","text":"As mentioned in the Introduction , attributes are modifiers that can be applied to elements. They can be applied to individual elements or to whole groups of them. Important They consists of two parts, a tag and a value . The value is always in quotation marks. Attribute types For XML, most of the attribute types are self-explanatory, like string or float (See Lua Scripting section for details on those). However XML has some unique types. HTML 6 Char Hex : #FFFFFF (white 100% opacity) 8 Char Hex : #FFFFFFCC (white 80% opacity) RGB Color : rgb(1,1,1) (white 100% opacity) RGBA Color : rgba(1,1,1,0.8) (white 80% opacity) Player Color : White (white 100% opacity) Color block values are used to specify the colors for elements such as buttons and input fields. Format: (normalColor|highlightedColor|pressedColor|disabledColor) where each color is formatted as above, e.g. #FFFFFF|White|#C8C8C8|rgba(0.78,0.78,0.78,0.5) True : 1 or true False : 0 or false Common Attributes Elements all share some common attributes which are not repeated under their separate entries. They can be broker down into category. General Attributes Attribute Name Description Type / Options Default Value active Specifies whether or not this element and its children are visible and contribute to layout. Modifying this via script will not trigger animations. bool true class A list of classes, separated by spaces. An element will inherit attributes from any of its classes defined in Defaults . string (none) id A unique string used to identify the element from Lua scripting. string (none) visibility A pipe-separated list of visibility targets. An element is always treated as inactive to players not specified here. string (visible to all) Visibility Targets Targets for the visibility attribute are as follows: The game host: Host Any promoted player (including the host): Admin Every player color : White , Brown , Red , Orange , Yellow , Green , Teal , Blue , Purple , Pink , Grey , and Black Every team : Clubs , Diamonds , Hearts , Spades , Jokers , and None Not setting the visibility attribute (or setting it to an empty string) does not limit the visibility of the element. Multiple targets can be listed by separating them with a pipe ( | ). In this case if any of the targets applies to a player then the element will be active for that player. Example: \"Red|Blue|Host\" would be visible to the red seat, blue seat, and the host of the server. Text Attributes Many, but not all, elements have a text attribute. Attribute Name Description Type / Options Default Value text Text to be displayed. string (none) alignment Typographic alignment of the text within its bounding box. UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color Color of the text. Elements that also take an image color use textColor for this. #323232 fontStyle Typographic emphasis on the text. Normal Bold Italic BoldAndItalic Normal fontSize Height of the text in pixels. float 14 resizeTextForBestFit If set then fontSize is ignored and the text will be sized to be as large as possible while still fitting within its bounding box. false resizeTextMinSize When resizeTextForBestFit is set, text will not be sized smaller than this. float 10 resizeTextMaxSize When resizeTextForBestFit is set, text will not be sized larger than this. float 40 horizontalOverflow Defines what happens when text extends beyond the left or right edges of its bounding box. Wrap Overflow Overflow verticalOverflow Defines what happens when text extends beyond the top or bottom edges of its bounding box. Truncate Overflow Truncate Image Attributes Applies to elements with an image component. The string that image s all take is the NAME THE IMAGE WAS GIVEN WHEN YOU PUT IT IN THE IN-GAME ASSET MANAGER . Attribute Name Description Type / Options Default Value image Name of the image in the asset manager. string (none) preserveAspect If set, the image will not stretch beyond its original aspect ratio, potentially leaving gaps around the image. (varies) color Color to tint the image, or a flat color to display if no image is given. clear or #FFFFFF type Defines how the image is drawn. Simple Sliced Filled Tiled (varies) raycastTarget If the element blocks clicks. true Appearance Attributes Attribute Name Description Type / Options Default Value shadow Defines the shadow color of this element. (none) shadowDistance Defines the distance of the shadow for this element. float(x) float(y) 1 -1 outline Defines the outline color of this element. (none) outlineSize Defines the size of this elements outline. float(x) float(y) 1 -1 Layout Element Attributes These will only apply to elements within a layout group. Attribute Name Description Type / Options Default Value ignoreLayout If this element ignores its parent's layout group behavior and treats it as a regular Panel. (This means it would obey regular position/size attributes.) false minWidth Elements will not be sized thinner than this. float (varies) minHeight Elements will not be sized shorter than this. float (varies) preferredWidth If there is space after minWidth s are sized, then element widths are sized according to this. float (varies) preferredHeight If there is space after minHeight s are sized, then element heights are sized according to this. float (varies) flexibleWidth If there is additional space after preferredWidth s are sized, defines how much the element expands to fill the available horizontal space, relative to other elements. float (varies) flexibleHeight If there is additional space after preferredHeights s are sized, defines how much the element expands to fill the available vertical space, relative to other elements. float (varies) On Sizing Elements Minimum and preferred sizes are defined in regular units, while the flexible sizes are defined in relative units. If any layout element has flexible size greater than zero, it means that all the available space will be filled out. The relative flexible size values of the siblings determines how big a proportion of the available space each sibling fills out. Most commonly, flexible width and height is set to just 0 or 1. Position/Size Attributes (Basic) Important These attributes do not apply to elements that are direct children of layout groups. To size those elements see Layout Element Attributes . Attribute Name Description Type / Options Default Value rectAlignment The element's anchor and pivot point, relative to its parent element. UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter width The width of this element in pixels or as a percentage of the width of its parent. float (fixed width) or a Percentage value 100% height The height of this element in pixels or as a percentage of the height of its parent. float (fixed width) or a Percentage value 100% offsetXY An offset to the position of this element, e.g. a value of -32 10 will cause this element to be 10 pixels up and 32 pixels to the left of where it would otherwise be. float(x) float(y) 0 0 Position/Size Attributes (Advanced) These provide deeper access to Unity's RectTransform properties. Important Besides rotation and scale , these attributes do not apply to elements that are direct children of layout groups. To size those elements see Layout Element Attributes . Attribute Name Description Type / Options Default Value anchorMin The anchor point for the bottom-left corner of the element, where 0 0 is its parent's bottom-left corner and 1 1 is its parent's top-right corner. float(x) float(y) (varies) anchorMax The anchor point for the top-right corner of the element, where 0 0 is its parent's bottom-left corner and 1 1 is its parent's top-right corner. float(x) float(y) (varies) sizeDelta An offset to the size of the element, e.g. a value of 15 -20 will cause this element to be 15 pixels wider and 32 pixels shorter than what it would otherwise be. float(x) float(y) (varies) pivot The pivot point this element is positioned, rotated, and scaled around. 0 0 is the element's bottom-left corner and 1 1 is its top-right corner. float(x) float(y) 0.5 0.5 position An offset to the position of this element in 3D space. Z moves the element in and out. float(x) float(y) float(z) 0 0 0 rotation Rotates the element in 3D space. X and Y tilt it like a dish, Z turns it like a steering wheel. float(x) float(y) float(z) 0 0 0 scale Scales the component around its pivot. Note that this does not add more pixel detail, text with small font and other elements may appear pixelated or blurry. Z does not affect the thickness of the element (it is always flat), but does affect the transforms of its children. float(x) float(y) float(z) 1 1 1 offsetMin An offset in pixels from anchorMin to be used as the bottom-left corner of the element. float(x) float(y) (varies) offsetMax An offset in pixels from anchorMax to be used as the top-right corner of the element. float(x) float(y) (varies) Mixing Attributes Some Advanced Position/Size Attributes affect the same underlying properties as the Basic Position/Size Attributes and other Advanced Position/Size Attributes. Using these overlapping attributes on the same element will cause one attribute to be effectively overwritten, and may result in unexpected behaviour. Elements in 3D Space Moving elements in 3D space can achieve parallax and perspective effects, but elements later in the XML will always be drawn on top of elements earlier in the same XML, and will not occlude as other 3d objects would. To avoid any visual glitches, try to make sure unrelated UI elements can't be seen overlapping when viewed from most angles. Global UI has no perspective and is always 2D. Dragging Attributes Allow users to move elements by clicking/dragging. Note There is currently no reliable way to read the positions of elements, and dragged positions reset when the UI is reloaded. Attribute Name Description Type / Options Default Value allowDragging Allows the element to be dragged around. Does not work on child elements of layout groups) false restrictDraggingToParentBounds If set, prevents the element from being dragged outside the bounding box of its parent. true returnToOriginalPositionWhenReleased If this is set to true, then the element will return to its original position when it is released. true Animation Attributes Attribute Name Description Type / Options Default Value showAnimation Animation to play when show() is called for the element. None Grow FadeIn SlideIn_Left SlideIn_Right SlideIn_Top SlideIn_Bottom None hideAnimation Animation to play when hide() is called for the element. None Shrink FadeOut SlideOut_Left SlideOut_Right SlideOut_Top SlideOut_Bottom None showAnimationDelay Time in seconds to wait before playing this element's show animation. Useful for staggering the animations of multiple elements. float 0 hideAnimationDelay Time in seconds to wait before playing this element's hide animation. Useful for staggering the animations of multiple elements. float 0 animationDuration Time in seconds that show/hide animations take to play. float 0.25 Tooltip Attributes Allow any element to have a tooltip (text that appears when the element is hovered over by the mouse). Attribute Name Description Type / Options Default Value tooltip Text to display when the element is hovered over. string (none) tooltipBorderColor Color of the tooltip's border. #FFFFFF tooltipBackgroundColor Color of the tooltip's background. rgba(0,0,0,0.62) tooltipBorderImage Image used for the tooltip's border. See Image Attributes . string tooltipBackgroundImage Image used for the tooltip's background. See Image Attributes . string tooltipTextColor Color of the text within this tooltip. #FFFFFF tooltipPosition Position of this tooltip in relation to the element. Above Below Left Right Right tooltipOffset Distance in pixels that this tooltip will appear from the element. float 8 Event Attributes Allows Lua scripting functions to be triggered by an element, through a variety of interactions. All elements have no events by default, listed below is the default value passed as the 2 nd parameter to the triggered function. See the Input Elements page for how to interact with Lua scripting. Attribute Name Description Type / Options Default Argument onClick Called when the mouse is pressed while over the element and then released while still over it. string The click button onMouseEnter Called when the pointer enters the boundary of the element. string \"-1\" onMouseExit Called when the pointer leaves the boundary of the element. string \"-1\" onDrag Called every frame if the element is being dragged and has moved that frame. string nil onBeginDrag Called once when the element starts being dragged. string nil onEndDrag Called once when the element stops being dragged and the mouse button is released. string nil onMouseDown Called when the mouse is pressed while over the element. string The click button onMouseUp Called when the mouse is released, if it had previously been pressed while over the element (no matter where the cursor currently is). string The click button onSubmit Called when the Enter/Return key is pressed on an Input Element . string The value of the input element Note onClick , onMouseDown and onMouseUp all pass the click button. They hold digits, but their data type is string . The possible values are: \"-1\" : Left mouse button \"-2\" : Right mouse button \"-3\" : Middle mouse button \"1\" : Single touch \"2\" : Double touch \"3\" : Triple touch onMouseEnter and onMouseExit also pass click buttons, but the value is always \"-1\" . Usage Single Element Attributes This is how you would assign attributes to a single element. One Attribute <Button onClick= \"test\" > Hello </Button> Multiple Attributes <Button onClick= \"test\" allowDragging= \"true\" > Hello </Button> Many Attributes <Button height= \"100\" width= \"200\" color= \"blue\" onClick= \"test\" allowDragging= \"true\" rectAlignment= \"MiddleRight\" tooltip= \"Test Tooltip\" tooltipPosition= \"Above\" fontSize= \"32\" textColor= \"#ff0000\" > Hello </Button>","title":"Attributes"},{"location":"ui/attributes/#attribute-types","text":"For XML, most of the attribute types are self-explanatory, like string or float (See Lua Scripting section for details on those). However XML has some unique types. HTML 6 Char Hex : #FFFFFF (white 100% opacity) 8 Char Hex : #FFFFFFCC (white 80% opacity) RGB Color : rgb(1,1,1) (white 100% opacity) RGBA Color : rgba(1,1,1,0.8) (white 80% opacity) Player Color : White (white 100% opacity) Color block values are used to specify the colors for elements such as buttons and input fields. Format: (normalColor|highlightedColor|pressedColor|disabledColor) where each color is formatted as above, e.g. #FFFFFF|White|#C8C8C8|rgba(0.78,0.78,0.78,0.5) True : 1 or true False : 0 or false","title":"Attribute types"},{"location":"ui/attributes/#common-attributes","text":"Elements all share some common attributes which are not repeated under their separate entries. They can be broker down into category.","title":"Common Attributes"},{"location":"ui/attributes/#general-attributes","text":"Attribute Name Description Type / Options Default Value active Specifies whether or not this element and its children are visible and contribute to layout. Modifying this via script will not trigger animations. bool true class A list of classes, separated by spaces. An element will inherit attributes from any of its classes defined in Defaults . string (none) id A unique string used to identify the element from Lua scripting. string (none) visibility A pipe-separated list of visibility targets. An element is always treated as inactive to players not specified here. string (visible to all) Visibility Targets Targets for the visibility attribute are as follows: The game host: Host Any promoted player (including the host): Admin Every player color : White , Brown , Red , Orange , Yellow , Green , Teal , Blue , Purple , Pink , Grey , and Black Every team : Clubs , Diamonds , Hearts , Spades , Jokers , and None Not setting the visibility attribute (or setting it to an empty string) does not limit the visibility of the element. Multiple targets can be listed by separating them with a pipe ( | ). In this case if any of the targets applies to a player then the element will be active for that player. Example: \"Red|Blue|Host\" would be visible to the red seat, blue seat, and the host of the server.","title":"General Attributes"},{"location":"ui/attributes/#text-attributes","text":"Many, but not all, elements have a text attribute. Attribute Name Description Type / Options Default Value text Text to be displayed. string (none) alignment Typographic alignment of the text within its bounding box. UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color Color of the text. Elements that also take an image color use textColor for this. #323232 fontStyle Typographic emphasis on the text. Normal Bold Italic BoldAndItalic Normal fontSize Height of the text in pixels. float 14 resizeTextForBestFit If set then fontSize is ignored and the text will be sized to be as large as possible while still fitting within its bounding box. false resizeTextMinSize When resizeTextForBestFit is set, text will not be sized smaller than this. float 10 resizeTextMaxSize When resizeTextForBestFit is set, text will not be sized larger than this. float 40 horizontalOverflow Defines what happens when text extends beyond the left or right edges of its bounding box. Wrap Overflow Overflow verticalOverflow Defines what happens when text extends beyond the top or bottom edges of its bounding box. Truncate Overflow Truncate","title":"Text Attributes"},{"location":"ui/attributes/#image-attributes","text":"Applies to elements with an image component. The string that image s all take is the NAME THE IMAGE WAS GIVEN WHEN YOU PUT IT IN THE IN-GAME ASSET MANAGER . Attribute Name Description Type / Options Default Value image Name of the image in the asset manager. string (none) preserveAspect If set, the image will not stretch beyond its original aspect ratio, potentially leaving gaps around the image. (varies) color Color to tint the image, or a flat color to display if no image is given. clear or #FFFFFF type Defines how the image is drawn. Simple Sliced Filled Tiled (varies) raycastTarget If the element blocks clicks. true","title":"Image Attributes"},{"location":"ui/attributes/#appearance-attributes","text":"Attribute Name Description Type / Options Default Value shadow Defines the shadow color of this element. (none) shadowDistance Defines the distance of the shadow for this element. float(x) float(y) 1 -1 outline Defines the outline color of this element. (none) outlineSize Defines the size of this elements outline. float(x) float(y) 1 -1","title":"Appearance Attributes"},{"location":"ui/attributes/#layout-element-attributes","text":"These will only apply to elements within a layout group. Attribute Name Description Type / Options Default Value ignoreLayout If this element ignores its parent's layout group behavior and treats it as a regular Panel. (This means it would obey regular position/size attributes.) false minWidth Elements will not be sized thinner than this. float (varies) minHeight Elements will not be sized shorter than this. float (varies) preferredWidth If there is space after minWidth s are sized, then element widths are sized according to this. float (varies) preferredHeight If there is space after minHeight s are sized, then element heights are sized according to this. float (varies) flexibleWidth If there is additional space after preferredWidth s are sized, defines how much the element expands to fill the available horizontal space, relative to other elements. float (varies) flexibleHeight If there is additional space after preferredHeights s are sized, defines how much the element expands to fill the available vertical space, relative to other elements. float (varies) On Sizing Elements Minimum and preferred sizes are defined in regular units, while the flexible sizes are defined in relative units. If any layout element has flexible size greater than zero, it means that all the available space will be filled out. The relative flexible size values of the siblings determines how big a proportion of the available space each sibling fills out. Most commonly, flexible width and height is set to just 0 or 1.","title":"Layout Element Attributes"},{"location":"ui/attributes/#positionsize-attributes-basic","text":"Important These attributes do not apply to elements that are direct children of layout groups. To size those elements see Layout Element Attributes . Attribute Name Description Type / Options Default Value rectAlignment The element's anchor and pivot point, relative to its parent element. UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter width The width of this element in pixels or as a percentage of the width of its parent. float (fixed width) or a Percentage value 100% height The height of this element in pixels or as a percentage of the height of its parent. float (fixed width) or a Percentage value 100% offsetXY An offset to the position of this element, e.g. a value of -32 10 will cause this element to be 10 pixels up and 32 pixels to the left of where it would otherwise be. float(x) float(y) 0 0","title":"Position/Size Attributes (Basic)"},{"location":"ui/attributes/#positionsize-attributes-advanced","text":"These provide deeper access to Unity's RectTransform properties. Important Besides rotation and scale , these attributes do not apply to elements that are direct children of layout groups. To size those elements see Layout Element Attributes . Attribute Name Description Type / Options Default Value anchorMin The anchor point for the bottom-left corner of the element, where 0 0 is its parent's bottom-left corner and 1 1 is its parent's top-right corner. float(x) float(y) (varies) anchorMax The anchor point for the top-right corner of the element, where 0 0 is its parent's bottom-left corner and 1 1 is its parent's top-right corner. float(x) float(y) (varies) sizeDelta An offset to the size of the element, e.g. a value of 15 -20 will cause this element to be 15 pixels wider and 32 pixels shorter than what it would otherwise be. float(x) float(y) (varies) pivot The pivot point this element is positioned, rotated, and scaled around. 0 0 is the element's bottom-left corner and 1 1 is its top-right corner. float(x) float(y) 0.5 0.5 position An offset to the position of this element in 3D space. Z moves the element in and out. float(x) float(y) float(z) 0 0 0 rotation Rotates the element in 3D space. X and Y tilt it like a dish, Z turns it like a steering wheel. float(x) float(y) float(z) 0 0 0 scale Scales the component around its pivot. Note that this does not add more pixel detail, text with small font and other elements may appear pixelated or blurry. Z does not affect the thickness of the element (it is always flat), but does affect the transforms of its children. float(x) float(y) float(z) 1 1 1 offsetMin An offset in pixels from anchorMin to be used as the bottom-left corner of the element. float(x) float(y) (varies) offsetMax An offset in pixels from anchorMax to be used as the top-right corner of the element. float(x) float(y) (varies) Mixing Attributes Some Advanced Position/Size Attributes affect the same underlying properties as the Basic Position/Size Attributes and other Advanced Position/Size Attributes. Using these overlapping attributes on the same element will cause one attribute to be effectively overwritten, and may result in unexpected behaviour. Elements in 3D Space Moving elements in 3D space can achieve parallax and perspective effects, but elements later in the XML will always be drawn on top of elements earlier in the same XML, and will not occlude as other 3d objects would. To avoid any visual glitches, try to make sure unrelated UI elements can't be seen overlapping when viewed from most angles. Global UI has no perspective and is always 2D.","title":"Position/Size Attributes (Advanced)"},{"location":"ui/attributes/#dragging-attributes","text":"Allow users to move elements by clicking/dragging. Note There is currently no reliable way to read the positions of elements, and dragged positions reset when the UI is reloaded. Attribute Name Description Type / Options Default Value allowDragging Allows the element to be dragged around. Does not work on child elements of layout groups) false restrictDraggingToParentBounds If set, prevents the element from being dragged outside the bounding box of its parent. true returnToOriginalPositionWhenReleased If this is set to true, then the element will return to its original position when it is released. true","title":"Dragging Attributes"},{"location":"ui/attributes/#animation-attributes","text":"Attribute Name Description Type / Options Default Value showAnimation Animation to play when show() is called for the element. None Grow FadeIn SlideIn_Left SlideIn_Right SlideIn_Top SlideIn_Bottom None hideAnimation Animation to play when hide() is called for the element. None Shrink FadeOut SlideOut_Left SlideOut_Right SlideOut_Top SlideOut_Bottom None showAnimationDelay Time in seconds to wait before playing this element's show animation. Useful for staggering the animations of multiple elements. float 0 hideAnimationDelay Time in seconds to wait before playing this element's hide animation. Useful for staggering the animations of multiple elements. float 0 animationDuration Time in seconds that show/hide animations take to play. float 0.25","title":"Animation Attributes"},{"location":"ui/attributes/#tooltip-attributes","text":"Allow any element to have a tooltip (text that appears when the element is hovered over by the mouse). Attribute Name Description Type / Options Default Value tooltip Text to display when the element is hovered over. string (none) tooltipBorderColor Color of the tooltip's border. #FFFFFF tooltipBackgroundColor Color of the tooltip's background. rgba(0,0,0,0.62) tooltipBorderImage Image used for the tooltip's border. See Image Attributes . string tooltipBackgroundImage Image used for the tooltip's background. See Image Attributes . string tooltipTextColor Color of the text within this tooltip. #FFFFFF tooltipPosition Position of this tooltip in relation to the element. Above Below Left Right Right tooltipOffset Distance in pixels that this tooltip will appear from the element. float 8","title":"Tooltip Attributes"},{"location":"ui/attributes/#event-attributes","text":"Allows Lua scripting functions to be triggered by an element, through a variety of interactions. All elements have no events by default, listed below is the default value passed as the 2 nd parameter to the triggered function. See the Input Elements page for how to interact with Lua scripting. Attribute Name Description Type / Options Default Argument onClick Called when the mouse is pressed while over the element and then released while still over it. string The click button onMouseEnter Called when the pointer enters the boundary of the element. string \"-1\" onMouseExit Called when the pointer leaves the boundary of the element. string \"-1\" onDrag Called every frame if the element is being dragged and has moved that frame. string nil onBeginDrag Called once when the element starts being dragged. string nil onEndDrag Called once when the element stops being dragged and the mouse button is released. string nil onMouseDown Called when the mouse is pressed while over the element. string The click button onMouseUp Called when the mouse is released, if it had previously been pressed while over the element (no matter where the cursor currently is). string The click button onSubmit Called when the Enter/Return key is pressed on an Input Element . string The value of the input element Note onClick , onMouseDown and onMouseUp all pass the click button. They hold digits, but their data type is string . The possible values are: \"-1\" : Left mouse button \"-2\" : Right mouse button \"-3\" : Middle mouse button \"1\" : Single touch \"2\" : Double touch \"3\" : Triple touch onMouseEnter and onMouseExit also pass click buttons, but the value is always \"-1\" .","title":"Event Attributes"},{"location":"ui/attributes/#usage","text":"","title":"Usage"},{"location":"ui/attributes/#single-element-attributes","text":"This is how you would assign attributes to a single element.","title":"Single Element Attributes"},{"location":"ui/attributes/#one-attribute","text":"<Button onClick= \"test\" > Hello </Button>","title":"One Attribute"},{"location":"ui/attributes/#multiple-attributes","text":"<Button onClick= \"test\" allowDragging= \"true\" > Hello </Button>","title":"Multiple Attributes"},{"location":"ui/attributes/#many-attributes","text":"<Button height= \"100\" width= \"200\" color= \"blue\" onClick= \"test\" allowDragging= \"true\" rectAlignment= \"MiddleRight\" tooltip= \"Test Tooltip\" tooltipPosition= \"Above\" fontSize= \"32\" textColor= \"#ff0000\" > Hello </Button>","title":"Many Attributes"},{"location":"ui/basicelements/","text":"These are display-type elements for the UI. They cannot send information to any Lua scripts. Each element has its own attributes specific to its type that work in addition to the common attributes . Element Summary Element Name Description <Text></Text> Adds basic text. <Image></Image> Adds an image. <ProgressBar></ProgressBar> Displays a progress bar which can be updated dynamically via script. Element Details Text Adds basic text. This tag supports Rich Text as shown in the example below. Attribute Name Description Type / Options Default Value text This can be used to determine the text that appears. It can also be modified externally by the script. string (none) alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color #323232 fontStyle Normal Bold Italic BoldItalic Normal fontSize float 14 resizeTextForBestFit Resize text to fit? false resizeTextMinSize Minimum font size float 10 resizeTextMaxSize Maximum font size float 40 horizontalOverflow Wrap Overflow Overflow verticalOverflow Truncate Overflow Truncate Example: <!-- Standard Text element --> <Text> Some Text </Text> <!-- Rich Text --> <Text> This text is <b> Bold </b> , <i> Italic </i> , and <textcolor color= \"#00FF00\" > Green </textcolor> . This text is <textsize size= \"18\" > Larger </textsize> . </Text> Image Adds an image. Attribute Name Description Type / Options Default Value image The name of the file in the asset manager (upper right corner of the scripting window in-game). string (none) color #FFFFFF type Image Type Simple Sliced Filled Tiled Simple raycastTarget Should this image block clicks from passing through it? true ProgressBar Displays a progress bar which can be updated dynamically via script. Attribute Name Description Type / Options Default Value image Background Image (path to image) (none) color Background Color #FFFFFF fillImage Fill Image string (none) fillImageColor Fill Color #FFFFFF percentage Percentage to Display float 0 showPercentageText Is the percentage text displayed? true percentageTextFormat Format to use for the percentage text string 0.00 textColor Percentage Text Color #000000 textShadow Percentage Text Shadow Color (none) textOutline Percentage Text Outline Color (none) textAlignment Percentage Text Alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter","title":"Basic Elements"},{"location":"ui/basicelements/#element-summary","text":"Element Name Description <Text></Text> Adds basic text. <Image></Image> Adds an image. <ProgressBar></ProgressBar> Displays a progress bar which can be updated dynamically via script.","title":"Element Summary"},{"location":"ui/basicelements/#element-details","text":"","title":"Element Details"},{"location":"ui/basicelements/#text","text":"Adds basic text. This tag supports Rich Text as shown in the example below. Attribute Name Description Type / Options Default Value text This can be used to determine the text that appears. It can also be modified externally by the script. string (none) alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color #323232 fontStyle Normal Bold Italic BoldItalic Normal fontSize float 14 resizeTextForBestFit Resize text to fit? false resizeTextMinSize Minimum font size float 10 resizeTextMaxSize Maximum font size float 40 horizontalOverflow Wrap Overflow Overflow verticalOverflow Truncate Overflow Truncate Example: <!-- Standard Text element --> <Text> Some Text </Text> <!-- Rich Text --> <Text> This text is <b> Bold </b> , <i> Italic </i> , and <textcolor color= \"#00FF00\" > Green </textcolor> . This text is <textsize size= \"18\" > Larger </textsize> . </Text>","title":"Text"},{"location":"ui/basicelements/#image","text":"Adds an image. Attribute Name Description Type / Options Default Value image The name of the file in the asset manager (upper right corner of the scripting window in-game). string (none) color #FFFFFF type Image Type Simple Sliced Filled Tiled Simple raycastTarget Should this image block clicks from passing through it? true","title":"Image"},{"location":"ui/basicelements/#progressbar","text":"Displays a progress bar which can be updated dynamically via script. Attribute Name Description Type / Options Default Value image Background Image (path to image) (none) color Background Color #FFFFFF fillImage Fill Image string (none) fillImageColor Fill Color #FFFFFF percentage Percentage to Display float 0 showPercentageText Is the percentage text displayed? true percentageTextFormat Format to use for the percentage text string 0.00 textColor Percentage Text Color #000000 textShadow Percentage Text Shadow Color (none) textOutline Percentage Text Outline Color (none) textAlignment Percentage Text Alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter","title":"ProgressBar"},{"location":"ui/defaults/","text":"The Default element allows you to set default values for UI elements. Primarily this will be used to set styles and the like, but there is no restriction on what default values you can set. Defaults can be applied to all instances of a particular tag type, or only those of a particular class (as set by the class attribute). Please note that elements may use more than one class (separated by spaces). As with its HTML counterpart (CSS), XmlLayout Defaults are applied in a cascading fashion. This means that an element will always use the most recent value for an attribute - for example, if an element implements a class, it will use the attribute values defined by that class except when the element itself also defines those attributes (attributes defined on the element will always take precedence). Defaults tags can be placed anywhere in the Xml document, but will only apply to elements after it. Example: <Defaults> <!-- Set the default color and font size for all Text elements --> <Text color= \"#DDDDDD\" fontSize= \"16\" /> <!-- Set the default color for all Text elements using the 'darker' class --> <Text class= \"darker\" color= \"#AAAAAA\" /> </Defaults> <!-- This text's color will be \"#DDDDDD\" and its font size will be \"16\" --> <Text> Text </Text> <!-- This text's color will be \"#AAAAAA\" and its font size will be \"16\" --> <Text class= \"darker\" > Text </Text> <!-- Set the default border and text color for all tooltips --> <Tooltip tooltipBorderColor= \"rgb(1,1,1)\" tooltipTextColor= \"rgb(1,1,1)\" />","title":"Defaults"},{"location":"ui/inputelements/","text":"All input elements allow for the XML UI to interact with the Lua scripts in the game instance. Tip Be sure to check out the UI section of the Lua Scripting API for how to receive the input from these element types. With Lua scripting, you can even modify the UI elements! Targeting Triggers When using an attribute that triggers scripting, like onValueChanged or onClick, the UI will target a default location. Global UI targets Global script, Object UI targets the Object's script. This behavior can be overwritten. For example: <Button onClick= \"uiClickFunc\" > Click Me </Button> If this was in the Global UI, this would trigger a function in the Global Lua script function uiClickFunc() . But if you want to target a function on an Object's script? Place the GUID for the object before the function name, like so: <Button onClick= \"aaa111/uiClickFunc\" > Click Me </Button> Now when the button is clicked, it will still try to activate function uiClickFunc() but it will try to do so on the Object Lua script of the Object with the GUID of \"aaa111\". <Button onClick= \"Global/uiClickFunc\" > Click Me </Button> And if this was in an Object's UI, it would direct the function activation to Global instead of that Object. Remember you can also use the Id attribute to identify which UI element triggered the function. Element Summary Element Name Description <InputField></InputField> A text input for single or multiple lines. Is able to send the text (during edit and when finished). <Button></Button> A button. Is able to send a trigger event. <Toggle></Toggle> A simple on/off toggle. Is able to send on/off status. <ToggleButton></ToggleButton> A toggle, but styled as a button. <ToggleGroup></ToggleGroup> Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. <Slider></Slider> A value slider. Is able to send Value. <Dropdown></Dropdown> A dropdown menu. Is able to send the contents of the selection made in it. Element Details InputField A text input for single or multiple lines. Is able to send the text (during edit and when finished). Attribute Name Description Type / Options Default Value onValueChanged Each time the text is changed, a Lua function with this name will be triggered. string (none) onEndEdit When the input box is deselected, a Lua function with this name will be triggered. string (none) text The string in the text box, if any. Is the value sent to onValueChanged's or onEndEdit's function. string (none) placeholder A string that is semi-visible when there is no text in the input. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) lineType SingleLine MultiLineSubmit MultiLineNewLine SingleLine characterValidation None Integer Decimal Alphanumeric Name EmailAddress None caretBlinkRate float 0.85 caretWidth float 1 caretColor #323232 selectionColor rgba(0.65,0.8,1,0.75) readOnly false textColor #323232 characterLimit int 0 (no limit) Example: <InputField> Default Text </InputField> Button A button. Is able to send a trigger event. Attribute Name Description Type / Options Default Value onClick When clicked, a Lua function with this name will be triggered. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 transition None ColorTint SpriteSwap Animation ColorTint highlightedSprite string pressedSprite string disabledSprite string Example: <!-- Standard Button --> <Button> Button Text </Button> <!-- Button with Icon --> <Button icon= \"SomeName\" /> <!-- Button with Icon and Text --> <Button icon= \"SomeName\" > Button With Icon </Button> Tip onClick passes nil for the value by default. However, you can assign a string that will be passed in onClick. <Button onClick= \"clickFunction(stringName)\" /> The above example passes a string with the name of \"stringName\" to the Lua function for the value property. Toggle A simple on/off toggle. Is able to send on/off status. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false Example: <Toggle> Toggle Text </Toggle> <!-- Toggle which is selected by default --> <Toggle isOn= \"true\" > Toggle Text </Toggle> ToggleButton A toggle, but styled as a button. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 <ToggleButton> Toggle Button Text </Toggle> ToggleGroup Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. Works with Toggle or ToggleButton Attribute Name Description Type / Options Default Value allowSwitchOff If this is set to true, then the user may clear their selection from within the ToggleGroup by clicking on the selected Toggle. false toggleBackgroundImage Sets the default background image to use for nested Toggle elements. string toggleBackgroundColor #FFFFFF toggleSelectedImage Sets the default image to use for selected (checked) nested Toggle elements. string toggleSelectedColor #FFFFFF <ToggleGroup> <VerticalLayout> <Toggle> Toggle A </Toggle> <Toggle> Toggle B </Toggle> <Toggle> Toggle C </Toggle> </VerticalLayout> </ToggleGroup> <ToggleGroup> <HorizontalLayout> <ToggleButton> ToggleButton A </ToggleButton> <ToggleButton> ToggleButton B </ToggleButton> <ToggleButton> ToggleButton C </ToggleButton> </HorizontalLayout> </ToggleGroup> Slider A value slider. Is able to send Value. Attribute Name Description Type / Options Default Value onValueChanged When the slider is moved, a Lua function with this name will be triggered. (rapidly) string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) minValue float 0 maxValue float 1 value The value currently selected. Is the value sent to onValueChanged's function. float 0 wholeNumbers false direction LeftToRight RightToLeft TopToBottom BottomToTop LeftToRight backgroundColor (none) fillColor (none) fillImage string handleColor (none) handleImage string Example: <Slider minValue= \"0\" maxValue= \"1\" value= \"0.5\" /> Dropdown A dropdown menu. Is able to send the contents of the selection made in it. Attribute Name Description Type / Options Default Value onValueChanged When an option is selected, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 itemBackgroundColors #FFFFFF itemTextColor #000000 checkColor #000000 checkImage string arrowColor #000000 arrowImage string dropdownBackgroundColor #000000 dropdownBackgroundImage string scrollbarColors scrollbarImage string itemHeight float Example: <Dropdown id=\"Selection\" onValueChanged=\"optionSelected\"> <Option selected=\"true\">Option 1</Option> <Option>Option 2</Option> <Option>Option 3</Option> <Option>Option 4</Option> </Dropdown> function optionSelected(player, option, id) print(player.steam_name .. \" selected: \" .. option) end","title":"Input Elements"},{"location":"ui/inputelements/#targeting-triggers","text":"When using an attribute that triggers scripting, like onValueChanged or onClick, the UI will target a default location. Global UI targets Global script, Object UI targets the Object's script. This behavior can be overwritten. For example: <Button onClick= \"uiClickFunc\" > Click Me </Button> If this was in the Global UI, this would trigger a function in the Global Lua script function uiClickFunc() . But if you want to target a function on an Object's script? Place the GUID for the object before the function name, like so: <Button onClick= \"aaa111/uiClickFunc\" > Click Me </Button> Now when the button is clicked, it will still try to activate function uiClickFunc() but it will try to do so on the Object Lua script of the Object with the GUID of \"aaa111\". <Button onClick= \"Global/uiClickFunc\" > Click Me </Button> And if this was in an Object's UI, it would direct the function activation to Global instead of that Object. Remember you can also use the Id attribute to identify which UI element triggered the function.","title":"Targeting Triggers"},{"location":"ui/inputelements/#element-summary","text":"Element Name Description <InputField></InputField> A text input for single or multiple lines. Is able to send the text (during edit and when finished). <Button></Button> A button. Is able to send a trigger event. <Toggle></Toggle> A simple on/off toggle. Is able to send on/off status. <ToggleButton></ToggleButton> A toggle, but styled as a button. <ToggleGroup></ToggleGroup> Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. <Slider></Slider> A value slider. Is able to send Value. <Dropdown></Dropdown> A dropdown menu. Is able to send the contents of the selection made in it.","title":"Element Summary"},{"location":"ui/inputelements/#element-details","text":"","title":"Element Details"},{"location":"ui/inputelements/#inputfield","text":"A text input for single or multiple lines. Is able to send the text (during edit and when finished). Attribute Name Description Type / Options Default Value onValueChanged Each time the text is changed, a Lua function with this name will be triggered. string (none) onEndEdit When the input box is deselected, a Lua function with this name will be triggered. string (none) text The string in the text box, if any. Is the value sent to onValueChanged's or onEndEdit's function. string (none) placeholder A string that is semi-visible when there is no text in the input. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) lineType SingleLine MultiLineSubmit MultiLineNewLine SingleLine characterValidation None Integer Decimal Alphanumeric Name EmailAddress None caretBlinkRate float 0.85 caretWidth float 1 caretColor #323232 selectionColor rgba(0.65,0.8,1,0.75) readOnly false textColor #323232 characterLimit int 0 (no limit) Example: <InputField> Default Text </InputField>","title":"InputField"},{"location":"ui/inputelements/#button","text":"A button. Is able to send a trigger event. Attribute Name Description Type / Options Default Value onClick When clicked, a Lua function with this name will be triggered. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 transition None ColorTint SpriteSwap Animation ColorTint highlightedSprite string pressedSprite string disabledSprite string Example: <!-- Standard Button --> <Button> Button Text </Button> <!-- Button with Icon --> <Button icon= \"SomeName\" /> <!-- Button with Icon and Text --> <Button icon= \"SomeName\" > Button With Icon </Button> Tip onClick passes nil for the value by default. However, you can assign a string that will be passed in onClick. <Button onClick= \"clickFunction(stringName)\" /> The above example passes a string with the name of \"stringName\" to the Lua function for the value property.","title":"Button"},{"location":"ui/inputelements/#toggle","text":"A simple on/off toggle. Is able to send on/off status. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false Example: <Toggle> Toggle Text </Toggle> <!-- Toggle which is selected by default --> <Toggle isOn= \"true\" > Toggle Text </Toggle>","title":"Toggle"},{"location":"ui/inputelements/#togglebutton","text":"A toggle, but styled as a button. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 <ToggleButton> Toggle Button Text </Toggle>","title":"ToggleButton"},{"location":"ui/inputelements/#togglegroup","text":"Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. Works with Toggle or ToggleButton Attribute Name Description Type / Options Default Value allowSwitchOff If this is set to true, then the user may clear their selection from within the ToggleGroup by clicking on the selected Toggle. false toggleBackgroundImage Sets the default background image to use for nested Toggle elements. string toggleBackgroundColor #FFFFFF toggleSelectedImage Sets the default image to use for selected (checked) nested Toggle elements. string toggleSelectedColor #FFFFFF <ToggleGroup> <VerticalLayout> <Toggle> Toggle A </Toggle> <Toggle> Toggle B </Toggle> <Toggle> Toggle C </Toggle> </VerticalLayout> </ToggleGroup> <ToggleGroup> <HorizontalLayout> <ToggleButton> ToggleButton A </ToggleButton> <ToggleButton> ToggleButton B </ToggleButton> <ToggleButton> ToggleButton C </ToggleButton> </HorizontalLayout> </ToggleGroup>","title":"ToggleGroup"},{"location":"ui/inputelements/#slider","text":"A value slider. Is able to send Value. Attribute Name Description Type / Options Default Value onValueChanged When the slider is moved, a Lua function with this name will be triggered. (rapidly) string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) minValue float 0 maxValue float 1 value The value currently selected. Is the value sent to onValueChanged's function. float 0 wholeNumbers false direction LeftToRight RightToLeft TopToBottom BottomToTop LeftToRight backgroundColor (none) fillColor (none) fillImage string handleColor (none) handleImage string Example: <Slider minValue= \"0\" maxValue= \"1\" value= \"0.5\" />","title":"Slider"},{"location":"ui/inputelements/#dropdown","text":"A dropdown menu. Is able to send the contents of the selection made in it. Attribute Name Description Type / Options Default Value onValueChanged When an option is selected, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 itemBackgroundColors #FFFFFF itemTextColor #000000 checkColor #000000 checkImage string arrowColor #000000 arrowImage string dropdownBackgroundColor #000000 dropdownBackgroundImage string scrollbarColors scrollbarImage string itemHeight float Example: <Dropdown id=\"Selection\" onValueChanged=\"optionSelected\"> <Option selected=\"true\">Option 1</Option> <Option>Option 2</Option> <Option>Option 3</Option> <Option>Option 4</Option> </Dropdown> function optionSelected(player, option, id) print(player.steam_name .. \" selected: \" .. option) end","title":"Dropdown"},{"location":"ui/introUI/","text":"The Custom UI system allows users to create custom UIs to support their game. The UI system is unique because the elements are created using a simple XML system. These UI elements can be created on screen using a Global UI or on individual in-game Objects. Core Features There are 3 main pieces to the UI system. Create Elements You are able to create individual elements and position them on the screen/object in a variety of ways. Import Assets By clicking the button in the upper-right corner of the scripting window in-game, you open a menu that lets you upload/manage assets that can be utilized by the UI. When you save your table after uploading images here, they are saved forever. Communicate with Lua Your scripts can be triggered by UI elements and your Lua scripts can also modify elements in the UI during gameplay. Getting Started Once you load a saved table, click the Scripting button at the top of the screen. The traditional scripting window will now be visible, but you will also see a button labeled UI . Using this button, you can toggle back and forth between Lua scripting and UI XML. In this UI window you will input your XML. Once you are finished, click Save & Play in its upper-left hand corner and the save file will re-load with your changes applied to it. If you do not see your UI elements appearing, it is possible your code has an error in it. Look down to the In-Game chat box for the error message It will indicate the line and character position the issue was discovered when trying to parse your code. Basics of XML In the UI XML, you create elements and modify them with attributes . Each element is created using tags. Here is an element being created. <Text> Displayed Text </Text> Those elements can be modified with attributes to change how they look and, in some cases, function. <Text fontSize= \"200\" > Bigger Displayed Text </Text> Input types are able to communicate to a Lua script in-game. <Button onClick= \"uibutton\" > Example Button </Button> There are even organizational methods you can do to easily group these elements together. Important The value for any attribute is ALWAYS in quotes. INCORRECT : <Text fontSize= 200 > Bigger Displayed Text </Text> CORRECT : <Text fontSize= \"200\" > Bigger Displayed Text </Text> Example UI Below you will find a variety of example projects to help you understand how the UI works. * Example Score Sheet By Gikerl * Example Splash Screen + Collapsible Die Roller by MrStump * Example Grid Menu by UnrealEd * Example Rulebook by UnrealEd","title":"Introduction"},{"location":"ui/introUI/#core-features","text":"There are 3 main pieces to the UI system. Create Elements You are able to create individual elements and position them on the screen/object in a variety of ways. Import Assets By clicking the button in the upper-right corner of the scripting window in-game, you open a menu that lets you upload/manage assets that can be utilized by the UI. When you save your table after uploading images here, they are saved forever. Communicate with Lua Your scripts can be triggered by UI elements and your Lua scripts can also modify elements in the UI during gameplay.","title":"Core Features"},{"location":"ui/introUI/#getting-started","text":"Once you load a saved table, click the Scripting button at the top of the screen. The traditional scripting window will now be visible, but you will also see a button labeled UI . Using this button, you can toggle back and forth between Lua scripting and UI XML. In this UI window you will input your XML. Once you are finished, click Save & Play in its upper-left hand corner and the save file will re-load with your changes applied to it. If you do not see your UI elements appearing, it is possible your code has an error in it. Look down to the In-Game chat box for the error message It will indicate the line and character position the issue was discovered when trying to parse your code.","title":"Getting Started"},{"location":"ui/introUI/#basics-of-xml","text":"In the UI XML, you create elements and modify them with attributes . Each element is created using tags. Here is an element being created. <Text> Displayed Text </Text> Those elements can be modified with attributes to change how they look and, in some cases, function. <Text fontSize= \"200\" > Bigger Displayed Text </Text> Input types are able to communicate to a Lua script in-game. <Button onClick= \"uibutton\" > Example Button </Button> There are even organizational methods you can do to easily group these elements together. Important The value for any attribute is ALWAYS in quotes. INCORRECT : <Text fontSize= 200 > Bigger Displayed Text </Text> CORRECT : <Text fontSize= \"200\" > Bigger Displayed Text </Text>","title":"Basics of XML"},{"location":"ui/introUI/#example-ui","text":"Below you will find a variety of example projects to help you understand how the UI works. * Example Score Sheet By Gikerl * Example Splash Screen + Collapsible Die Roller by MrStump * Example Grid Menu by UnrealEd * Example Rulebook by UnrealEd","title":"Example UI"},{"location":"ui/layoutgrouping/","text":"By nesting elements within layouts/groupings, you are able to easily group elements together in-game. It allows for adjusting/moving them together, uniform padding and additional visual flair possibilities. Each layout element has its own attributes specific to its type. Additionally, elements within a layout are subject to common common layout element attributes . Element Summary Layout Summary Element Name Description <Panel></Panel> A \"window\" in which elements can be confined. <HorizontalLayout></HorizontalLayout> A horizontal row of elements. <VerticalLayout></VerticalLayout> A vertical column of elements. <GridLayout></GridLayout> A grid of elements. <TableLayout></TableLayout> A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. <Row></Row> A row within a TableLayout. <Cell></Cell> A cell within a TableLayout. Scroll View Summary Element Name Description <HorizontalScrollView></HorizontalScrollView> A scrollable horizontal row of elements. <VerticalScrollView></VerticalScrollView> A scrollable vertical column of elements. Layout Element Details Layout Details Panel A \"window\" in which elements can be confined. Attribute Name Description Type / Options Default Value padding Specifies the padding for this panel. Please note that if padding is specified, the panel will function as a LayoutGroup (which it does not do by default). float(left) float(right) float(top) float(bottom) (none) <Panel> <Text> Text contained within Panel </Text> </Panel> HorizontalLayout A horizontal row of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <HorizontalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </HorizontalLayout> VerticalLayout A vertical column of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <VerticalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </VerticalLayout> GridLayout A grid of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements float(x) float(y) 0 0 cellSize float(x) float(y) 100 100 startCorner UpperLeft UpperRight LowerLeft LowerRight UpperLeft startAxis Horizontal Vertical Horizontal childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft constraint Flexible FixedColumnCount FixedRowCount Flexible constraintCount integer 2 <GridLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </GridLayout> TableLayout A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 cellSpacing Spacing between each cell. float 0 columnWidths (Optional) Explicitly set the width of each column. Use a value of 0 to auto-size a specific column. float list - e.g. '32 0 0 32' (none) automaticallyAddColumns If more cells are added to a row than are accounted for by columnWidths, should this TableLayout automatically add one or more new auto-sized entries (0) to columnWidths? true automaticallyRemoveEmptyColumns If there are more entries in columnWidths than there are cells in any row, should this TableLayout automatically remove entries from columnWidths until their are no 'empty' columns? true autoCalculateHeight If set to true, then the height of this TableLayout will automatically be calculated as the sum of each rows preferredHeight value. This option cannot be used without explicitly sized rows. false useGlobalCellPadding If set to true, then all cells will use this TableLayout's cellPadding value. true cellPadding Padding for each cell. float(left) float(right) float(top) float(bottom) 0 0 0 0 cellBackgroundImage Image to use as the background for each cell. string cellBackgroundColor Color for each cells background. rgba(1,1,1,0.4) rowBackgroundImage Image to use as the background for each row. string rowBackgroundColor Color to use for each rows background. clear <TableLayout> <!-- Row 1 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Two </Button></Cell> </Row> <!-- Row 2 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Three </Button></Cell> </Row> </TableLayout> Row A row within a TableLayout. Attribute Name Description Type / Options Default Value preferredHeight Sets the height for this row. Use a value of '0' to specify that this row should be auto-sized. float 0 dontUseTableRowBackground If set to true, then this row will ignore the tables' rowBackgroundImage and rowBackgroundColor values, allowing you to override those values for this row. false Cell A cell within a TableLayout. Attribute Name Description Type / Options Default Value columnSpan __ int 1 dontUseTableCellBackground If set to true, then this cell will ignore the tables' cellBackgroundImage and values, allowing you to override those values for this cell. false overrideGlobalCellPadding If set to true, then this cell will ignore the tables' cellPadding value, allowing you to set unique cell padding for this cell. false padding Padding values to use for this cell if overrideGlobalCellPadding is set to true. float(left) float(right) float(top) float(bottom) 0 0 0 0 childForceExpandWidth true childForceExpandHeight true Scroll View Details HorizontalScrollView A scrollable horizontal row of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal true vertical false movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <HorizontalScrollView> <HorizontalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </HorizontalLayout> </HorizontalScrollView> VerticalScrollView A scrollable vertical column of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal false vertical true movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <VerticalScrollView> <VerticalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </VerticalLayout> </VerticalScrollView>","title":"Layout/Grouping"},{"location":"ui/layoutgrouping/#element-summary","text":"","title":"Element Summary"},{"location":"ui/layoutgrouping/#layout-summary","text":"Element Name Description <Panel></Panel> A \"window\" in which elements can be confined. <HorizontalLayout></HorizontalLayout> A horizontal row of elements. <VerticalLayout></VerticalLayout> A vertical column of elements. <GridLayout></GridLayout> A grid of elements. <TableLayout></TableLayout> A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. <Row></Row> A row within a TableLayout. <Cell></Cell> A cell within a TableLayout.","title":"Layout Summary"},{"location":"ui/layoutgrouping/#scroll-view-summary","text":"Element Name Description <HorizontalScrollView></HorizontalScrollView> A scrollable horizontal row of elements. <VerticalScrollView></VerticalScrollView> A scrollable vertical column of elements.","title":"Scroll View Summary"},{"location":"ui/layoutgrouping/#layout-element-details","text":"","title":"Layout Element Details"},{"location":"ui/layoutgrouping/#layout-details","text":"","title":"Layout Details"},{"location":"ui/layoutgrouping/#panel","text":"A \"window\" in which elements can be confined. Attribute Name Description Type / Options Default Value padding Specifies the padding for this panel. Please note that if padding is specified, the panel will function as a LayoutGroup (which it does not do by default). float(left) float(right) float(top) float(bottom) (none) <Panel> <Text> Text contained within Panel </Text> </Panel>","title":"Panel"},{"location":"ui/layoutgrouping/#horizontallayout","text":"A horizontal row of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <HorizontalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </HorizontalLayout>","title":"HorizontalLayout"},{"location":"ui/layoutgrouping/#verticallayout","text":"A vertical column of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <VerticalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </VerticalLayout>","title":"VerticalLayout"},{"location":"ui/layoutgrouping/#gridlayout","text":"A grid of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements float(x) float(y) 0 0 cellSize float(x) float(y) 100 100 startCorner UpperLeft UpperRight LowerLeft LowerRight UpperLeft startAxis Horizontal Vertical Horizontal childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft constraint Flexible FixedColumnCount FixedRowCount Flexible constraintCount integer 2 <GridLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </GridLayout>","title":"GridLayout"},{"location":"ui/layoutgrouping/#tablelayout","text":"A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 cellSpacing Spacing between each cell. float 0 columnWidths (Optional) Explicitly set the width of each column. Use a value of 0 to auto-size a specific column. float list - e.g. '32 0 0 32' (none) automaticallyAddColumns If more cells are added to a row than are accounted for by columnWidths, should this TableLayout automatically add one or more new auto-sized entries (0) to columnWidths? true automaticallyRemoveEmptyColumns If there are more entries in columnWidths than there are cells in any row, should this TableLayout automatically remove entries from columnWidths until their are no 'empty' columns? true autoCalculateHeight If set to true, then the height of this TableLayout will automatically be calculated as the sum of each rows preferredHeight value. This option cannot be used without explicitly sized rows. false useGlobalCellPadding If set to true, then all cells will use this TableLayout's cellPadding value. true cellPadding Padding for each cell. float(left) float(right) float(top) float(bottom) 0 0 0 0 cellBackgroundImage Image to use as the background for each cell. string cellBackgroundColor Color for each cells background. rgba(1,1,1,0.4) rowBackgroundImage Image to use as the background for each row. string rowBackgroundColor Color to use for each rows background. clear <TableLayout> <!-- Row 1 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Two </Button></Cell> </Row> <!-- Row 2 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Three </Button></Cell> </Row> </TableLayout>","title":"TableLayout"},{"location":"ui/layoutgrouping/#row","text":"A row within a TableLayout. Attribute Name Description Type / Options Default Value preferredHeight Sets the height for this row. Use a value of '0' to specify that this row should be auto-sized. float 0 dontUseTableRowBackground If set to true, then this row will ignore the tables' rowBackgroundImage and rowBackgroundColor values, allowing you to override those values for this row. false","title":"Row"},{"location":"ui/layoutgrouping/#cell","text":"A cell within a TableLayout. Attribute Name Description Type / Options Default Value columnSpan __ int 1 dontUseTableCellBackground If set to true, then this cell will ignore the tables' cellBackgroundImage and values, allowing you to override those values for this cell. false overrideGlobalCellPadding If set to true, then this cell will ignore the tables' cellPadding value, allowing you to set unique cell padding for this cell. false padding Padding values to use for this cell if overrideGlobalCellPadding is set to true. float(left) float(right) float(top) float(bottom) 0 0 0 0 childForceExpandWidth true childForceExpandHeight true","title":"Cell"},{"location":"ui/layoutgrouping/#scroll-view-details","text":"","title":"Scroll View Details"},{"location":"ui/layoutgrouping/#horizontalscrollview","text":"A scrollable horizontal row of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal true vertical false movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <HorizontalScrollView> <HorizontalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </HorizontalLayout> </HorizontalScrollView>","title":"HorizontalScrollView"},{"location":"ui/layoutgrouping/#verticalscrollview","text":"A scrollable vertical column of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal false vertical true movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <VerticalScrollView> <VerticalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </VerticalLayout> </VerticalScrollView>","title":"VerticalScrollView"}]}